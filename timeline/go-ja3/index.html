<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="在这篇文章中将会简单回顾https的握手流程，并基于读者的提问题解释什么是JA3指纹以及如何用Go定制专属的JA3指纹。
本文大纲如下，请各位读者跟着老许的思路逐步构建自己专属的JA3指纹。
回顾HTTPS握手流程 在正式开始了解什么是JA3指纹之前，我们先回顾一下HTTPS的握手流程，这将有助于对后文的理解。
在码了2000多行代码就是为了讲清楚TLS握手流程这篇文章中主要分析了HTTPS单向认证和双向认证流程(TLS1.3)。
在单向认证中，客户端不需要证书，只需验证服务端证书合法即可。其握手流程和交换的msg如下。
在双向认证中，服务端和客户端均需验证对方证书的合法性。其握手流程和交换的msg如下。
单向认证和双向认证的对比：
  单向认证和双向认证中，总的数据收发仅三次，单次发送的数据中包含一个或者多个消息
  clientHelloMsg和serverHelloMsg未经过加密，之后发送的消息均做了加密处理
  Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后
  双向认证和单向认证相比，服务端多发送了certificateRequestMsgTLS13消息
  双向认证和单向认证相比，客户端多发送了certificateMsgTLS13和certificateVerifyMsg两个消息
  无论是单向认证还是双向认证，Server对于Client的基本信息了解完全依赖于Client主动告知Server，而其中比较关键的信息分别是客户端支持的TLS版本、客户端支持的加密套件（cipherSuites）、客户端支持的签名算法和客户端支持的密钥交换协议以及其对应的公钥。这些信息均在包含clientHelloMsg中，而这些信息也是生成JA3指纹的关键信息，并且clientHelloMsg和serverHelloMsg未经过加密。未加密意味着修改难度降低，这也就为我们定制自己专属的JA3指纹提供了可能。
 如果有兴趣了解HTTPS握手流程的更多细节，请阅读下面文章：
码了2000多行代码就是为了讲清楚TLS握手流程
码了2000多行代码就是为了讲清楚TLS握手流程（续）
 什么是JA3指纹 前面说了这么多，那么到底什么是JA3指纹呢。根据Open Sourcing JA3这篇文章，老许简单将其理解为JA3就是一种在线识别TLS客户端指纹的方法。
该方法用于收集clientHelloMsg数据包中以下字段的十进制字节值：TLS Version、Accepted Ciphers、List of Extensions、Elliptic Curves和Elliptic Curve Formats。然后，它将这些值串联起来，使用“,”来分隔各个字段，同时使用“-”来分隔各个字段中的值。最后，计算这些字符串的md5哈希值，即得到易于使用和共享的长度为32字符的指纹。
为了更近一步描述清楚这些数据的来源，老许将John Althouse文章中的抓包图结合Go源码中的clientHelloMsg结构体做了字段一一映射。
细心的同学可能已经发现了，根据前文描述JA3指纹总共有5个数据字段，而上图却只映射了4个。那是因为TLS的extension字段比较多，老许就不一一整理了。虽然没有一一列举，但老许准备了一个单元测试，有兴趣深入研究的同学可以通过这个单元测试进行调试分析。
https://github.com/Isites/go-coder/blob/master/http2/tls/handsh/msg_test.go JA3指纹用途 根据前文的描述，JA3指纹就是一个md5字符串。请大家回想一下在平时的开发中md5的用途。
 判断内容是否一致 作为唯一标识   md5虽然不安全，但是JA3选择md5作为哈希的主要原因是为了更好的向后兼容
 很明显，JA3指纹也有其类似用途。举个简单的例子，攻击者构建了一个可执行文件，那么该文件的JA3指纹很有可能是唯一的。因此，我们能通过JA3指纹识别出一些恶意软件。
在本小节的最后，老许给大家推荐一个网站，该网站挂出了很多恶意JA3指纹列表。
https://sslbl.abuse.ch/ja3-fingerprints/ 构建专属的JA3指纹 http1.1的专属指纹 前文提到clientHelloMsg和serverHelloMsg未经过加密，这为定制自己专属的JA3指纹提供了可能，而在github上面有一个库(https://github.com/refraction-networking/utls)可以在一定程度上修改clientHelloMsg。下面我们将通过这个库构建一个自己专属的JA3指纹。
// 关键import import (  xtls &amp;#34;github.com/refraction-networking/utls&amp;#34;  &amp;#34;crypto/tls&amp;#34; )  // 克隆一个Transport tr := http." />
<meta name="keywords" content=", Go, 网络篇" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://isites.github.io/timeline/go-ja3/" />


    <title>
        
            用Go构建你专属的JA3指纹 :: Gopher指北 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css"> 




<link rel="stylesheet" href="/main.805b1025016494ee5fd67b55b8ecd5e2b7c4a9f0bdda42e300c62b85ddfef68f.css">


  

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">



<meta itemprop="name" content="用Go构建你专属的JA3指纹">
<meta itemprop="description" content="在这篇文章中将会简单回顾https的握手流程，并基于读者的提问题解释什么是JA3指纹以及如何用Go定制专属的JA3指纹。
本文大纲如下，请各位读者跟着老许的思路逐步构建自己专属的JA3指纹。
回顾HTTPS握手流程 在正式开始了解什么是JA3指纹之前，我们先回顾一下HTTPS的握手流程，这将有助于对后文的理解。
在码了2000多行代码就是为了讲清楚TLS握手流程这篇文章中主要分析了HTTPS单向认证和双向认证流程(TLS1.3)。
在单向认证中，客户端不需要证书，只需验证服务端证书合法即可。其握手流程和交换的msg如下。
在双向认证中，服务端和客户端均需验证对方证书的合法性。其握手流程和交换的msg如下。
单向认证和双向认证的对比：
  单向认证和双向认证中，总的数据收发仅三次，单次发送的数据中包含一个或者多个消息
  clientHelloMsg和serverHelloMsg未经过加密，之后发送的消息均做了加密处理
  Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后
  双向认证和单向认证相比，服务端多发送了certificateRequestMsgTLS13消息
  双向认证和单向认证相比，客户端多发送了certificateMsgTLS13和certificateVerifyMsg两个消息
  无论是单向认证还是双向认证，Server对于Client的基本信息了解完全依赖于Client主动告知Server，而其中比较关键的信息分别是客户端支持的TLS版本、客户端支持的加密套件（cipherSuites）、客户端支持的签名算法和客户端支持的密钥交换协议以及其对应的公钥。这些信息均在包含clientHelloMsg中，而这些信息也是生成JA3指纹的关键信息，并且clientHelloMsg和serverHelloMsg未经过加密。未加密意味着修改难度降低，这也就为我们定制自己专属的JA3指纹提供了可能。
 如果有兴趣了解HTTPS握手流程的更多细节，请阅读下面文章：
码了2000多行代码就是为了讲清楚TLS握手流程
码了2000多行代码就是为了讲清楚TLS握手流程（续）
 什么是JA3指纹 前面说了这么多，那么到底什么是JA3指纹呢。根据Open Sourcing JA3这篇文章，老许简单将其理解为JA3就是一种在线识别TLS客户端指纹的方法。
该方法用于收集clientHelloMsg数据包中以下字段的十进制字节值：TLS Version、Accepted Ciphers、List of Extensions、Elliptic Curves和Elliptic Curve Formats。然后，它将这些值串联起来，使用“,”来分隔各个字段，同时使用“-”来分隔各个字段中的值。最后，计算这些字符串的md5哈希值，即得到易于使用和共享的长度为32字符的指纹。
为了更近一步描述清楚这些数据的来源，老许将John Althouse文章中的抓包图结合Go源码中的clientHelloMsg结构体做了字段一一映射。
细心的同学可能已经发现了，根据前文描述JA3指纹总共有5个数据字段，而上图却只映射了4个。那是因为TLS的extension字段比较多，老许就不一一整理了。虽然没有一一列举，但老许准备了一个单元测试，有兴趣深入研究的同学可以通过这个单元测试进行调试分析。
https://github.com/Isites/go-coder/blob/master/http2/tls/handsh/msg_test.go JA3指纹用途 根据前文的描述，JA3指纹就是一个md5字符串。请大家回想一下在平时的开发中md5的用途。
 判断内容是否一致 作为唯一标识   md5虽然不安全，但是JA3选择md5作为哈希的主要原因是为了更好的向后兼容
 很明显，JA3指纹也有其类似用途。举个简单的例子，攻击者构建了一个可执行文件，那么该文件的JA3指纹很有可能是唯一的。因此，我们能通过JA3指纹识别出一些恶意软件。
在本小节的最后，老许给大家推荐一个网站，该网站挂出了很多恶意JA3指纹列表。
https://sslbl.abuse.ch/ja3-fingerprints/ 构建专属的JA3指纹 http1.1的专属指纹 前文提到clientHelloMsg和serverHelloMsg未经过加密，这为定制自己专属的JA3指纹提供了可能，而在github上面有一个库(https://github.com/refraction-networking/utls)可以在一定程度上修改clientHelloMsg。下面我们将通过这个库构建一个自己专属的JA3指纹。
// 关键import import (  xtls &#34;github.com/refraction-networking/utls&#34;  &#34;crypto/tls&#34; )  // 克隆一个Transport tr := http."><meta itemprop="datePublished" content="2022-02-28T08:00:00+08:00" />
<meta itemprop="dateModified" content="2022-02-28T08:00:00+08:00" />
<meta itemprop="wordCount" content="356">
<meta itemprop="keywords" content="Go,网络篇," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="用Go构建你专属的JA3指纹"/>
<meta name="twitter:description" content="在这篇文章中将会简单回顾https的握手流程，并基于读者的提问题解释什么是JA3指纹以及如何用Go定制专属的JA3指纹。
本文大纲如下，请各位读者跟着老许的思路逐步构建自己专属的JA3指纹。
回顾HTTPS握手流程 在正式开始了解什么是JA3指纹之前，我们先回顾一下HTTPS的握手流程，这将有助于对后文的理解。
在码了2000多行代码就是为了讲清楚TLS握手流程这篇文章中主要分析了HTTPS单向认证和双向认证流程(TLS1.3)。
在单向认证中，客户端不需要证书，只需验证服务端证书合法即可。其握手流程和交换的msg如下。
在双向认证中，服务端和客户端均需验证对方证书的合法性。其握手流程和交换的msg如下。
单向认证和双向认证的对比：
  单向认证和双向认证中，总的数据收发仅三次，单次发送的数据中包含一个或者多个消息
  clientHelloMsg和serverHelloMsg未经过加密，之后发送的消息均做了加密处理
  Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后
  双向认证和单向认证相比，服务端多发送了certificateRequestMsgTLS13消息
  双向认证和单向认证相比，客户端多发送了certificateMsgTLS13和certificateVerifyMsg两个消息
  无论是单向认证还是双向认证，Server对于Client的基本信息了解完全依赖于Client主动告知Server，而其中比较关键的信息分别是客户端支持的TLS版本、客户端支持的加密套件（cipherSuites）、客户端支持的签名算法和客户端支持的密钥交换协议以及其对应的公钥。这些信息均在包含clientHelloMsg中，而这些信息也是生成JA3指纹的关键信息，并且clientHelloMsg和serverHelloMsg未经过加密。未加密意味着修改难度降低，这也就为我们定制自己专属的JA3指纹提供了可能。
 如果有兴趣了解HTTPS握手流程的更多细节，请阅读下面文章：
码了2000多行代码就是为了讲清楚TLS握手流程
码了2000多行代码就是为了讲清楚TLS握手流程（续）
 什么是JA3指纹 前面说了这么多，那么到底什么是JA3指纹呢。根据Open Sourcing JA3这篇文章，老许简单将其理解为JA3就是一种在线识别TLS客户端指纹的方法。
该方法用于收集clientHelloMsg数据包中以下字段的十进制字节值：TLS Version、Accepted Ciphers、List of Extensions、Elliptic Curves和Elliptic Curve Formats。然后，它将这些值串联起来，使用“,”来分隔各个字段，同时使用“-”来分隔各个字段中的值。最后，计算这些字符串的md5哈希值，即得到易于使用和共享的长度为32字符的指纹。
为了更近一步描述清楚这些数据的来源，老许将John Althouse文章中的抓包图结合Go源码中的clientHelloMsg结构体做了字段一一映射。
细心的同学可能已经发现了，根据前文描述JA3指纹总共有5个数据字段，而上图却只映射了4个。那是因为TLS的extension字段比较多，老许就不一一整理了。虽然没有一一列举，但老许准备了一个单元测试，有兴趣深入研究的同学可以通过这个单元测试进行调试分析。
https://github.com/Isites/go-coder/blob/master/http2/tls/handsh/msg_test.go JA3指纹用途 根据前文的描述，JA3指纹就是一个md5字符串。请大家回想一下在平时的开发中md5的用途。
 判断内容是否一致 作为唯一标识   md5虽然不安全，但是JA3选择md5作为哈希的主要原因是为了更好的向后兼容
 很明显，JA3指纹也有其类似用途。举个简单的例子，攻击者构建了一个可执行文件，那么该文件的JA3指纹很有可能是唯一的。因此，我们能通过JA3指纹识别出一些恶意软件。
在本小节的最后，老许给大家推荐一个网站，该网站挂出了很多恶意JA3指纹列表。
https://sslbl.abuse.ch/ja3-fingerprints/ 构建专属的JA3指纹 http1.1的专属指纹 前文提到clientHelloMsg和serverHelloMsg未经过加密，这为定制自己专属的JA3指纹提供了可能，而在github上面有一个库(https://github.com/refraction-networking/utls)可以在一定程度上修改clientHelloMsg。下面我们将通过这个库构建一个自己专属的JA3指纹。
// 关键import import (  xtls &#34;github.com/refraction-networking/utls&#34;  &#34;crypto/tls&#34; )  // 克隆一个Transport tr := http."/>







    <meta property="article:published_time" content="2022-02-28 08:00:00 &#43;0800 CST" />








    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://isites.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">Gopher指北</span>
            <span class="logo__text"></span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
             
            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        2 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://isites.github.io/timeline/go-ja3/">用Go构建你专属的JA3指纹</a>
      </h1>
        <hr />
        <aside id="toc">
          <div class="toc-title">Table of Contents</div>
          <nav id="TableOfContents">
  <ul>
    <li><a href="#http11的专属指纹">http1.1的专属指纹</a></li>
    <li><a href="#http2的专属指纹">http2的专属指纹</a></li>
  </ul>
</nav>
        </aside>
        <hr />

      

      <div class="post-content">
        <p>在这篇文章中将会简单回顾https的握手流程，并基于读者的提问题解释什么是JA3指纹以及如何用Go定制专属的JA3指纹。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBdd818c0171bf7523dad3029e88986dea?method=download&amp;shareKey=e3b4387645c1dbb41c76b247c1d6bf8d" alt=""></p>
<p>本文大纲如下，请各位读者跟着老许的思路逐步构建自己专属的JA3指纹。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBcec2b01408d5c1734f1cc954bf0ad8b1?method=download&amp;shareKey=7121a424f46011dfb6b61242f2b14741" alt=""></p>
<h1 id="回顾https握手流程">回顾HTTPS握手流程</h1>
<p>在正式开始了解什么是JA3指纹之前，我们先回顾一下HTTPS的握手流程，这将有助于对后文的理解。</p>
<p>在<a href="https://mp.weixin.qq.com/s/TR3Sgkhh2rnlG0DUpyJfvw">码了2000多行代码就是为了讲清楚TLS握手流程</a>这篇文章中主要分析了HTTPS单向认证和双向认证流程(TLS1.3)。</p>
<p>在<strong>单向认证</strong>中，客户端不需要证书，只需验证服务端证书合法即可。其握手流程和交换的msg如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBabaa8d21b80ef2e9a69d1b76d1f14306?method=download&amp;shareKey=7b94c83d13c6789208b76e0cba9e974c" alt=""></p>
<p>在<strong>双向认证</strong>中，服务端和客户端均需验证对方证书的合法性。其握手流程和交换的msg如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB65957ed0aef24f93f20d1e78d9d8b1a2?method=download&amp;shareKey=7894057fa0666f7a9450d2e1ace75ce8" alt=""></p>
<p>单向认证和双向认证的对比：</p>
<ol>
<li>
<p>单向认证和双向认证中，总的数据收发仅三次，单次发送的数据中包含一个或者多个消息</p>
</li>
<li>
<p><code>clientHelloMsg</code>和<code>serverHelloMsg</code><strong>未经过加密</strong>，之后发送的消息均做了加密处理</p>
</li>
<li>
<p>Client和Server会各自计算两次密钥，计算时机分别是读取到对方的<code>HelloMsg</code>和<code>finishedMsg</code>之后</p>
</li>
<li>
<p>双向认证和单向认证相比，服务端多发送了<code>certificateRequestMsgTLS13</code>消息</p>
</li>
<li>
<p>双向认证和单向认证相比，客户端多发送了<code>certificateMsgTLS13</code>和<code>certificateVerifyMsg</code>两个消息</p>
</li>
</ol>
<p>无论是单向认证还是双向认证，Server对于Client的基本信息了解完全依赖于Client主动告知Server，而其中比较关键的信息分别是<code>客户端支持的TLS版本</code>、<code>客户端支持的加密套件（cipherSuites）</code>、<code>客户端支持的签名算法和客户端支持的密钥交换协议以及其对应的公钥</code>。这些信息均在包含<code>clientHelloMsg</code>中，而这些信息也是生成JA3指纹的关键信息，并且<code>clientHelloMsg</code>和<code>serverHelloMsg</code><strong>未经过加密</strong>。未加密意味着修改难度降低，这也就为我们定制自己专属的JA3指纹提供了可能。</p>
<blockquote>
<p>如果有兴趣了解HTTPS握手流程的更多细节，请阅读下面文章：</p>
<p><a href="https://mp.weixin.qq.com/s/TR3Sgkhh2rnlG0DUpyJfvw">码了2000多行代码就是为了讲清楚TLS握手流程</a></p>
<p><a href="https://mp.weixin.qq.com/s/ALmouugbrCHrNbyk3OTtSQ">码了2000多行代码就是为了讲清楚TLS握手流程（续）</a></p>
</blockquote>
<h1 id="什么是ja3指纹">什么是JA3指纹</h1>
<p>前面说了这么多，那么到底什么是JA3指纹呢。根据<a href="https://engineering.salesforce.com/open-sourcing-ja3-92c9e53c3c41">Open Sourcing JA3</a>这篇文章，老许简单将其理解为JA3就是一种在线识别TLS客户端指纹的方法。</p>
<p>该方法用于收集<code>clientHelloMsg</code>数据包中以下字段的十进制字节值：<code>TLS Version</code>、<code>Accepted Ciphers</code>、<code>List of Extensions</code>、<code>Elliptic Curves</code>和<code>Elliptic Curve Formats</code>。然后，它将这些值串联起来，使用“,”来分隔各个字段，同时使用“-”来分隔各个字段中的值。最后，计算这些字符串的md5哈希值，即得到易于使用和共享的长度为32字符的指纹。</p>
<p>为了更近一步描述清楚这些数据的来源，老许将<code>John Althouse</code>文章中的抓包图结合Go源码中的<code>clientHelloMsg</code>结构体做了字段一一映射。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1cd179acb8f346061d96229d62c2b533?method=download&amp;shareKey=cfa5647b4b76e8cb9a077520358b848f" alt=""></p>
<p>细心的同学可能已经发现了，根据前文描述JA3指纹总共有5个数据字段，而上图却只映射了4个。那是因为TLS的extension字段比较多，老许就不一一整理了。虽然没有一一列举，但老许准备了一个单元测试，有兴趣深入研究的同学可以通过这个单元测试进行调试分析。</p>
<pre tabindex="0"><code>https://github.com/Isites/go-coder/blob/master/http2/tls/handsh/msg_test.go
</code></pre><h1 id="ja3指纹用途">JA3指纹用途</h1>
<p>根据前文的描述，JA3指纹就是一个md5字符串。请大家回想一下在平时的开发中md5的用途。</p>
<ul>
<li>判断内容是否一致</li>
<li>作为唯一标识</li>
</ul>
<blockquote>
<p>md5虽然不安全，但是JA3选择md5作为哈希的主要原因是为了更好的向后兼容</p>
</blockquote>
<p>很明显，JA3指纹也有其类似用途。举个简单的例子，攻击者构建了一个可执行文件，那么该文件的JA3指纹很有可能是唯一的。因此，我们能通过JA3指纹识别出一些恶意软件。</p>
<p>在本小节的最后，老许给大家推荐一个网站，该网站挂出了很多恶意JA3指纹列表。</p>
<pre tabindex="0"><code>https://sslbl.abuse.ch/ja3-fingerprints/
</code></pre><h1 id="构建专属的ja3指纹">构建专属的JA3指纹</h1>
<h2 id="http11的专属指纹">http1.1的专属指纹</h2>
<p>前文提到<code>clientHelloMsg</code>和<code>serverHelloMsg</code><strong>未经过加密</strong>，这为定制自己专属的JA3指纹提供了可能，而在github上面有一个库(<a href="https://github.com/refraction-networking/utls">https://github.com/refraction-networking/utls</a>)可以在一定程度上修改<code>clientHelloMsg</code>。下面我们将通过这个库构建一个自己专属的JA3指纹。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 关键import
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xtls</span> <span style="color:#e6db74">&#34;github.com/refraction-networking/utls&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;crypto/tls&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 克隆一个Transport
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 自定义DialTLSContext函数，此函数会用于创建tcp连接和tls握手
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">DialTLSContext</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建tcp连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根据地址获取host信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">addr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 构建tlsconf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">xtlsConf</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">Config</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ServerName</span>:    <span style="color:#a6e22e">host</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Renegotiation</span>: <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">RenegotiateNever</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 构建tls.UConn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">xtlsConn</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">UClient</span>(<span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">xtlsConf</span>, <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">HelloCustom</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">clientHelloSpec</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">ClientHelloSpec</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// hellomsg中的最大最小tls版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">TLSVersMax</span>: <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">VersionTLS12</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">TLSVersMin</span>: <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">VersionTLS10</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ja3指纹需要的CipherSuites
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">CipherSuites</span>: []<span style="color:#66d9ef">uint16</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">CompressionMethods</span>: []<span style="color:#66d9ef">byte</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ja3指纹需要的Extensions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Extensions</span>: []<span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">TLSExtension</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">RenegotiationInfoExtension</span>{<span style="color:#a6e22e">Renegotiation</span>: <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">RenegotiateOnceAsClient</span>},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SNIExtension</span>{<span style="color:#a6e22e">ServerName</span>: <span style="color:#a6e22e">host</span>},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">UtlsExtendedMasterSecretExtension</span>{},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SignatureAlgorithmsExtension</span>{<span style="color:#a6e22e">SupportedSignatureAlgorithms</span>: []<span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SignatureScheme</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">ECDSAWithP256AndSHA256</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PSSWithSHA256</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PKCS1WithSHA256</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">ECDSAWithP384AndSHA384</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">ECDSAWithSHA1</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PSSWithSHA384</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PSSWithSHA384</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PKCS1WithSHA384</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PSSWithSHA512</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PKCS1WithSHA512</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">PKCS1WithSHA1</span>}},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">StatusRequestExtension</span>{},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">NPNExtension</span>{},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SCTExtension</span>{},
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">ALPNExtension</span>{<span style="color:#a6e22e">AlpnProtocols</span>: []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;h2&#34;</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>}},
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ja3指纹需要的Elliptic Curve Formats
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SupportedPointsExtension</span>{<span style="color:#a6e22e">SupportedPoints</span>: []<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">1</span>}}, <span style="color:#75715e">// uncompressed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// ja3指纹需要的Elliptic Curves
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">SupportedCurvesExtension</span>{
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Curves</span>: []<span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">CurveID</span>{
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">X25519</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">CurveP256</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">CurveP384</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">xtls</span>.<span style="color:#a6e22e">CurveP521</span>,
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义hellomsg的加密套件等信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">xtlsConn</span>.<span style="color:#a6e22e">ApplyPreset</span>(<span style="color:#a6e22e">clientHelloSpec</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TLS握手
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">xtlsConn</span>.<span style="color:#a6e22e">Handshake</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;当前请求使用协议：&#34;</span>, <span style="color:#a6e22e">xtlsConn</span>.<span style="color:#a6e22e">HandshakeState</span>.<span style="color:#a6e22e">ServerHello</span>.<span style="color:#a6e22e">AlpnProtocol</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">xtlsConn</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码总结起来分为三步。</p>
<ol>
<li>
<p>创建TCP连接</p>
</li>
<li>
<p>构建<code>clientHelloMsg</code>需要的信息</p>
</li>
<li>
<p>完成TLS握手</p>
</li>
</ol>
<p>有了上述代码后，我们通过请求<code>https://ja3er.com/json</code>来得到自己的JA3指纹。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">tr</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resp</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;https://ja3er.com/json&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ioutil</span>.<span style="color:#a6e22e">ReadAll</span>(<span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Body</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resp</span>.<span style="color:#a6e22e">Body</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
</span></span></code></pre></div><p>最后得到的JA3指纹如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa872c656e9f5dfc1779b2a8670e8215a?method=download&amp;shareKey=56af0f6c9eee594818fe27a4acb5dbc9" alt=""></p>
<p>我们已经得到了第一个JA3指纹，这个时候对代码稍加改动以期得到<code>专属</code>的JA3指纹。例如我们将<code>2333</code>这个数值加入到<code>CipherSuites</code>列表中，最后得到结果如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB296c40a22832db9ba02150cd2c86b5f6?method=download&amp;shareKey=55ee970405ef9cc315d106275ebc85e5" alt=""></p>
<p>最终，JA3指纹又发生了变化，并且可称得上是自己专属的指纹。不用我说，看标题就应该知道问题还没有结束。从前面请求得到JA3指纹的结果图也可以看出来，当前使用的协议为<code>http1.1</code>，因此老许从某度中找了一个支持http2的链接继续验证。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb63489ff37a5bbc9a97bc393f7cd17ad?method=download&amp;shareKey=ab4e6c64f06f2f44693a79222a46b179" alt=""></p>
<p>看过<a href="https://mp.weixin.qq.com/s/TGF9AR5-vaeORVxA2ZFx2A">Go发起HTTP2.0请求流程析(前篇)</a>这篇文章的同学应该知道，http2连接在建立时需要发送<code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>这么一个字符串。很明显，在自定义了<code>DialTLSContext</code>函数之后相关流程缺失。此时，我们该如何构建http2的专属指纹呢？</p>
<h2 id="http2的专属指纹">http2的专属指纹</h2>
<p>通过<code>DialTLSContext</code>拨号之后只能得到一个已经完成TLS握手的连接，此时它还不支持http2的<code>数据帧</code>、<code>多路复用</code>等特性。所以，我们需要自己构建一个支持http2各种特性的连接。</p>
<p>下面，我们通过<code>golang.org/x/net/http2</code>来完成自定义TLS握手流程后的http2请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 手动拨号，得到一个已经完成TLS握手后的连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">DialTLSContext</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;dss0.bdstatic.com:443&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;DialTLSContext&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 构建一个http2的连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">tr2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http2</span>.<span style="color:#a6e22e">Transport</span>{}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 这一步很关键，不可缺失
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">h2Con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tr2</span>.<span style="color:#a6e22e">NewClientConn</span>(<span style="color:#a6e22e">con</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;NewClientConn&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">NewRequest</span>(<span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">&#34;https://dss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/topnav/newzhidao-da1cf444b0.png&#34;</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向一个支持http2的链接发起请求并读取请求状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">resp2</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h2Con</span>.<span style="color:#a6e22e">RoundTrip</span>(<span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;RoundTrip&#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">CopyN</span>(<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Discard</span>, <span style="color:#a6e22e">resp2</span>.<span style="color:#a6e22e">Body</span>, <span style="color:#ae81ff">2</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resp2</span>.<span style="color:#a6e22e">Body</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;响应code: &#34;</span>, <span style="color:#a6e22e">resp2</span>.<span style="color:#a6e22e">StatusCode</span>)
</span></span></code></pre></div><p>结果如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB48949c17bf3090c0d16df9cd762d1b59?method=download&amp;shareKey=fe407d3ee11323952bed75edc4f5d584" alt=""></p>
<p>可以看到，最终在自定义JA3指纹后，http2的请求也能正常读取。至此，在支持http2的请求中构建专属的JA3指纹就完成了（生成JA3指纹的信息在<code>clientHelloMsg</code>中，完成本部分仅是为了确保从发起请求到读取响应都能够正常进行）。</p>
<p>额外补充几句，通过手动<code>NewClientConn</code>这种方式完成http2请求具有很大的局限性。比如，需要自己管理连接的生命周期、无法自动重连等。当然，这些都是后话，真有这方面需求的时候，可能就需要开发者从go源码将net包fork一份自己维护了。</p>
<h1 id="写在最后">写在最后</h1>
<p>老许写下本文不仅仅是带大家了解ja3，更多的是期望各位读者能够通过自身的实践加深对http底层的理解。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>注：</p>
<p>写本文时， 笔者所用go版本为: go1.17.7</p>
<p>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/http2/ja3/main.go</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>

      </div>
    </article>

    <hr />

    <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon">
            <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
            <line x1="7" y1="7" x2="7" y2="7"></line>
          </svg><span class="tag"><a href="https://isites.github.io/tags/go/">Go</a></span><span class="tag"><a href="https://isites.github.io/tags/%E7%BD%91%E7%BB%9C%E7%AF%87/">网络篇</a></span>
        </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        356 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        2022-02-28 08:00 &#43;0800
      </p>
 
    </div>

    
      <div class="pagination">
        <div class="pagination__title">
          <span class="pagination__title-h"></span>
          <hr />
        </div>

        <div class="pagination__buttons">
          
            <span class="button previous">
              <a href="https://isites.github.io/timeline/divide0/">
                <span class="button__icon">←</span>
                <span class="button__text">除以零不会panic？</span>
              </a>
            </span>
          

          
            <span class="button next">
              <a href="https://isites.github.io/timeline/version-compare/">
                <span class="button__text">一顿骚操作版本号比较性能提升300%</span>
                <span class="button__icon">→</span>
              </a>
            </span>
          
        </div>
      </div>
    


    

  </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2022</span>
            
             
        </div>
    </div> 
</footer>
<script type="text/javascript">
    $(function(){

  window.sr = ScrollReveal();

  if ($(window).width() < 768) {

    if ($('.timeline-content').hasClass('js--fadeInLeft')) {
        $('.timeline-content').removeClass('js--fadeInLeft').addClass('js--fadeInRight');
    }

    sr.reveal('.js--fadeInRight', {
        origin: 'right',
        distance: '300px',
        easing: 'ease-in-out',
        duration: 800,
      });

  } else {
    
    sr.reveal('.js--fadeInLeft', {
        origin: 'left',
        distance: '300px',
          easing: 'ease-in-out',
        duration: 800,
      });

      sr.reveal('.js--fadeInRight', {
        origin: 'right',
        distance: '300px',
        easing: 'ease-in-out',
        duration: 800,
      });

  }
  
  sr.reveal('.js--fadeInLeft', {
        origin: 'left',
        distance: '300px',
          easing: 'ease-in-out',
        duration: 800,
      });

      sr.reveal('.js--fadeInRight', {
        origin: 'right',
        distance: '300px',
        easing: 'ease-in-out',
        duration: 800,
      });


});

</script>
            
        </div>

        




<script type="text/javascript" src="/bundle.min.e2a9675ced043d06ad6d3f13fafb0203d96c89eb2484878d5eb89d6da19559cbed55fb05ca9eae7be1e975cab83e3b2a1193afc357019620a509327c5a6a9c0f.js" integrity="sha512-4qlnXO0EPQatbT8T&#43;vsCA9lsieskhIeNXridbaGVWcvtVfsFyp6ue&#43;Hpdcq4PjsqEZOvw1cBliClCTJ8WmqcDw=="></script>


    
        <script src="/js/bd-hm.js"></script>
    


    </body>
</html>
