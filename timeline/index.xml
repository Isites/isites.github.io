<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Timelines on 新世界杂货铺</title>
        <link>https://isites.github.io/timeline/</link>
        <description>Recent content in Timelines on 新世界杂货铺</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 19 Jan 2021 20:30:38 +0800</lastBuildDate>
        <atom:link href="https://isites.github.io/timeline/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Go中的SSRF攻防战</title>
            <link>https://isites.github.io/timeline/go-ssrf/</link>
            <pubDate>Tue, 19 Jan 2021 20:30:38 +0800</pubDate>
            
            <guid>https://isites.github.io/timeline/go-ssrf/</guid>
            <description>写在最前面 “年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。
关于自称，老许就不扯太远了，下面还是回到本篇的主旨。
什么是SSRF SSRF英文全拼为Server Side Request Forgery，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。
上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。
“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。
回合一：千变万化的内网地址 为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用182.61.200.7（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。
   格式 值 描述     点分十进制 182.61.200.7 常规表现方式   点分八进制 0266.075.0310.07 每个字节被单独转换为八进制   点分十六进制 0xb6.0x3d.0xc8.0x7 每个字节被单独转换为十六进制   十进制 3057502215 用十进制写出的32位整数   八进制 026617344007 用八进制写出32位整数   十六进制 0xb63dc807 用十六进制写出32位整数   点分混合制（4） 182.0x3d.0310.7等 点分格式中，每个字节都可用任意的进制表达   点分混合制（3） 182.0x3d.0144007等 将后面16位用八进制表示   点分混合制（2） 182.4048903等 将后面24为用10进制表示    注意⚠️：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。
上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址0:0:0:0:0:0:0:1为例。</description>
            <content type="html"><![CDATA[<h3 id="写在最前面">写在最前面</h3>
<p>“年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。</p>
<p>关于自称，老许就不扯太远了，下面还是回到本篇的主旨。</p>
<h3 id="什么是ssrf">什么是SSRF</h3>
<p>SSRF英文全拼为<code>Server Side Request Forgery</code>，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5e3f093a7664785b0c96e4d4a4fdd095?method=download&amp;shareKey=30bddd4078d8dbe0f8bd62c34814ad94" alt=""></p>
<p>上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。</p>
<p>“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。</p>
<h3 id="回合一千变万化的内网地址">回合一：千变万化的内网地址</h3>
<p>为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用<code>182.61.200.7</code>（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">点分十进制</td>
<td style="text-align:left">182.61.200.7</td>
<td style="text-align:left">常规表现方式</td>
</tr>
<tr>
<td style="text-align:left">点分八进制</td>
<td style="text-align:left">0266.075.0310.07</td>
<td style="text-align:left">每个字节被单独转换为八进制</td>
</tr>
<tr>
<td style="text-align:left">点分十六进制</td>
<td style="text-align:left">0xb6.0x3d.0xc8.0x7</td>
<td style="text-align:left">每个字节被单独转换为十六进制</td>
</tr>
<tr>
<td style="text-align:left">十进制</td>
<td style="text-align:left">3057502215</td>
<td style="text-align:left">用十进制写出的32位整数</td>
</tr>
<tr>
<td style="text-align:left">八进制</td>
<td style="text-align:left">026617344007</td>
<td style="text-align:left">用八进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">0xb63dc807</td>
<td style="text-align:left">用十六进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（4）</td>
<td style="text-align:left">182.0x3d.0310.7等</td>
<td style="text-align:left">点分格式中，每个字节都可用任意的进制表达</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（3）</td>
<td style="text-align:left">182.0x3d.0144007等</td>
<td style="text-align:left">将后面16位用八进制表示</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（2）</td>
<td style="text-align:left">182.4048903等</td>
<td style="text-align:left">将后面24为用10进制表示</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。</p>
<p>上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址<code>0:0:0:0:0:0:0:1</code>为例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒分十六进制表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0:1</td>
<td style="text-align:left">格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，每个X的前导0是可以省略</td>
</tr>
<tr>
<td style="text-align:left">0位压缩表示法</td>
<td style="text-align:left">::1</td>
<td style="text-align:left">连续的一段0可以压缩为“::”，但”::”只能出现一次</td>
</tr>
<tr>
<td style="text-align:left">内嵌IPv4地址表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0.0.0.1</td>
<td style="text-align:left">X:X:X:X:X:X:d.d.d.d（前96b使用冒分十六进制，最后32b地址则使用IPv4的点分十进制表示）</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：冒分十六进制表示法中每个X的前导0是可以省略的，那么我可以部分省略，部分不省略，从而将一个IPv6地址写出不同的表现形式。0位压缩表示法和内嵌IPv4地址表示法同理也可以将一个IPv6地址写出不同的表现形式。</p>
<p>讲了这么多，老许已经无法统计一个IP可以有多少种不同的写法，麻烦数学好的算一下。</p>
<p>内网IP你以为到这儿就完了嘛？当然不！不知道各位读者有没有听过<code>xip.io</code>这个域名。<code>xip</code>可以帮你做自定义的DNS解析，并且可以解析到任意IP地址（包括内网）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB85b07b5da343c8b1be8be6bdd19869f5?method=download&amp;shareKey=a3ffcab0e1c03fbfa6383c5d736f3ea4" alt=""></p>
<p>我们通过<code>xip</code>提供的域名解析，还可以将内网IP通过域名的方式进行访问。</p>
<p>关于内网IP的访问到这儿仍将继续！搞过Basic验证的应该都知道，可以通过<code>http://user:passwd@hostname/</code>进行资源访问。如果攻击者换一种写法或许可以绕过部分不够严谨的逻辑，如下所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBac6328b4d92be511501ea6d4d2a7042d?method=download&amp;shareKey=86a8308849c419d602d621b2bab1c93d" alt=""></p>
<p>关于内网地址，老许掏空了所有的知识储备总结出上述内容，因此老许说一句千变万化的内网地址不过分吧！</p>
<p>此时此刻，老许只想问一句，当恶意攻击者用这些不同表现形式的内网地址进行图片上传时，你怎么将其识别出来并拒绝访问。不会真的有大佬用正则表达式完成上述过滤吧，如果有请留言告诉我让小弟学习一下。</p>
<p>花样百出的内网地址我们已经基本了解，那么现在的问题是怎么将其转为一个我们可以进行判断的IP。总结上面的内网地址可分为三类：一、本身就是IP地址，仅表现形式不统一；二、一个指向内网IP的域名；三、一个包含Basic验证信息和内网IP的地址。根据这三类特征，在发起请求之前按照如下步骤可以识别内网地址并拒绝访问。</p>
<ol>
<li>解析出地址中的HostName。</li>
<li>发起DNS解析，获得IP。</li>
<li>判断IP是否是内网地址。</li>
</ol>
<p>上述步骤中关于内网地址的判断，请不要忽略IPv6的回环地址和IPv6的唯一本地地址。下面是老许判断IP是否为内网IP的逻辑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// IsLocalIP 判断是否是内网ip
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#75715e">// 判断是否是回环地址, ipv4时是127.0.0.1；ipv6时是::1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">IsLoopback</span>() {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#75715e">// 判断ipv4是否是内网
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To4</span>(); <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">||</span> <span style="color:#75715e">// 10.0.0.0/8
</span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">172</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">16</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">31</span>) <span style="color:#f92672">||</span> <span style="color:#75715e">// 172.16.0.0/12
</span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">192</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">168</span>) <span style="color:#75715e">// 192.168.0.0/16
</span><span style="color:#75715e"></span>	}
	<span style="color:#75715e">// 判断ipv6是否是内网
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To16</span>(); <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// 参考 https://tools.ietf.org/html/rfc4193#section-3
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 参考 https://en.wikipedia.org/wiki/Private_network#Private_IPv6_addresses
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 判断ipv6唯一本地地址
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xfd</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ip16</span>[<span style="color:#ae81ff">0</span>]
	}
	<span style="color:#75715e">// 不是ip直接返回false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}

</code></pre></div><p>下图为按照上述步骤检测请求是否是内网请求的结果。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB733788caa1f3e7307a0eb6eaf237db5e?method=download&amp;shareKey=5df8b437bde3f8a6b40eb03f66e15d57" alt=""></p>
<p><strong>小结</strong>：URL形式多样，可以使用DNS解析获取规范的IP，从而判断是否是内网资源。</p>
<h3 id="回合二url跳转">回合二：URL跳转</h3>
<p>如果恶意攻击者仅通过IP的不同写法进行攻击，那我们自然可以高枕无忧，然而这场矛与盾的较量才刚刚开局。</p>
<p>我们回顾一下回合一的防御策略，检测请求是否是内网资源是在正式发起请求之前，如果攻击者在请求过程中通过URL跳转进行内网资源访问则完全可以绕过回合一中的防御策略。具体攻击流程如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe9de4e2a016b1d1f9b0d2dfa09ba7811?method=download&amp;shareKey=65a87ed928726fc6c7fc34d362b1824d" alt=""></p>
<p>如图所示，通过URL跳转攻击者可获得内网资源。在介绍如何防御URL跳转攻击之前，老许和各位读者先一起复习一下HTTP重定向状态码——3xx。</p>
<p>根据维基百科的资料，3xx重定向码范围从300到308共9个。老许特意瞧了一眼go的源码，发现官方的<code>http.Client</code>发出的请求仅支持如下几个重定向码。</p>
<p><code>301</code>：请求的资源已永久移动到新位置；该响应可缓存；重定向请求一定是GET请求。</p>
<p><code>302</code>：要求客户端执行临时重定向；只有在Cache-Control或Expires中进行指定的情况下，这个响应才是可缓存的；重定向请求一定是GET请求。</p>
<p><code>303</code>：当POST（或PUT / DELETE）请求的响应在另一个URI能被找到时可用此code，这个code存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源；303响应禁止被缓存；重定向请求一定是GET请求。</p>
<p><code>307</code>：临时重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p><code>308</code>：永久重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p>3xx状态码复习就到这里，我们继续SSRF的攻防回合讨论。既然服务端的URL跳转可能带来风险，那我们只要禁用URL跳转就完全可以规避此类风险。然而我们并不能这么做，这个做法在规避风险的同时也极有可能误伤正常的请求。那到底该如何防范此类攻击手段呢？</p>
<p>看过老许“<a href="https://mp.weixin.qq.com/s/6WYhwaRrjv6W6NZCNw2CeA">Go中的HTTP请求之——HTTP1.1请求流程分析</a>”这篇文章的读者应该知道，对于重定向有业务需求时，可以自定义http.Client的<code>CheckRedirect</code>。下面我们先看一下<code>CheckRedirect</code>的定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">CheckRedirect</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span>
</code></pre></div><p>这里特别说明一下，<code>req</code>是即将发出的请求且请求中包含前一次请求的响应，<code>via</code>是已经发出的请求。在知晓这些条件后，防御URL跳转攻击就变得十分容易了。</p>
<ol>
<li>根据前一次请求的响应直接拒绝<code>307</code>和<code>308</code>的跳转（此类跳转可以是POST请求，风险极高）。</li>
<li>解析出请求的IP，并判断是否是内网IP。</li>
</ol>
<p>根据上述步骤，可如下定义<code>http.Client</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">CheckRedirect</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span> {
		<span style="color:#75715e">// 跳转超过10次，也拒绝继续跳转
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">via</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;redirect too much&#34;</span>)
		}
		<span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Response</span>.<span style="color:#a6e22e">StatusCode</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">307</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">308</span> {
			<span style="color:#75715e">// 拒绝跳转访问
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unsupport redirect method&#34;</span>)
		}
		<span style="color:#75715e">// 判断ip
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Host</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
		}
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;have local ip&#34;</span>)
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s -&gt; %s is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	},
}
</code></pre></div><p>如上自定义CheckRedirect可以防范URL跳转攻击，但此方式会进行多次DNS解析，效率不佳。后文会结合其他攻击方式介绍更加有效率的防御措施。</p>
<p><strong>小结</strong>：通过自定义<code>http.Client</code>的<code>CheckRedirect</code>可以防范URL跳转攻击。</p>
<h3 id="回合三dns-rebinding">回合三：DNS Rebinding</h3>
<p>众所周知，发起一次HTTP请求需要先请求DNS服务获取域名对应的IP地址。如果攻击者有可控的DNS服务，就可以通过DNS重绑定绕过前面的防御策略进行攻击。</p>
<p>具体流程如下图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa90ecbaeb18110063a5e91d1704f4c8a?method=download&amp;shareKey=fc64d48577f5e66e69ea10616cd28344" alt=""></p>
<p>验证资源是是否合法时，服务器进行了第一次DNS解析，获得了一个非内网的IP且TTL为0。对解析的IP进行判断，发现非内网IP可以后续请求。由于攻击者的DNS Server将TTL设置为0，所以正式发起请求时需要再次进行DNS解析。此时DNS Server返回内网地址，由于已经进入请求资源阶段再无防御措施，所以攻击者可获得内网资源。</p>
<blockquote>
<p>额外提一嘴，老许特意看了Go中DNS解析的部分源码，发现Go并没有对DNS的结果作缓存，所以即使TTL不为0也存在DNS重绑定的风险。</p>
</blockquote>
<p>在发起请求的过程中有DNS解析才让攻击者有机可乘。如果我们能对该过程进行控制，就可以避免DNS重绑定的风险。对HTTP请求控制可以通过自定义<code>http.Transport</code>来实现，而自定义<code>http.Transport</code>也有两个方案。</p>
<p><strong>方案一</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
<span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
<span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">addr</span>)
	<span style="color:#75715e">// 解析host和 端口
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#75715e">// dns解析域名
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">host</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#75715e">// 对所有的ip串行发起请求
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v -&gt; %v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#75715e">// 非内网IP可继续访问
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 拼接地址
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">JoinHostPort</span>(<span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">port</span>)
		<span style="color:#75715e">// 此时的addr仅包含IP和端口信息
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">con</span>, <span style="color:#66d9ef">nil</span>
		}
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
	}

	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;connect failed&#34;</span>)
}
<span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
}
</code></pre></div><p><code>transport.DialContext</code>的作用是创建未加密的TCP连接，我们通过自定义此函数可规避DNS重绑定风险。另外特别说明一下，如果传递给<code>dialer.DialContext</code>方法的地址是常规IP格式则可使用net包中的<code>parseIPZone</code>函数直接解析成功，否则会继续发起DNS解析请求。</p>
<p><strong>方案二</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
<span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">Control</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">address</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">RawConn</span>) <span style="color:#66d9ef">error</span> {
    <span style="color:#75715e">// address 已经是ip:port的格式
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">address</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseIP</span>(<span style="color:#a6e22e">host</span>)))
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
<span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
<span style="color:#75715e">// 使用官方库的实现创建TCP连接
</span><span style="color:#75715e"></span><span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>
<span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
}
</code></pre></div><p><code>dialer.Control</code>在创建网络连接之后实际拨号之前调用，且仅在go版本大于等于1.11时可用，其具体调用位置在<code>sock_posix.go</code>中的<code>(*netFD).dial</code>方法里。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB149c44c0f615142a792ed61dc8ef81d2?method=download&amp;shareKey=a215bcf6853fe43b9a3d1f6b74a8fb3a" alt=""></p>
<p>上述两个防御方案不仅仅可以防范DNS重绑定攻击，也同样可以防范其他攻击方式。事实上，老许更加推荐方案二，简直一劳永逸！</p>
<p><strong>小结</strong>：</p>
<ol>
<li>攻击者可以通过自己的DNS服务进行DNS重绑定攻击。</li>
<li>通过自定义<code>http.Transport</code>可以防范DNS重绑定攻击。</li>
</ol>
<h3 id="个人经验">个人经验</h3>
<p>1、不要下发详细的错误信息！不要下发详细的错误信息！不要下发详细的错误信息！</p>
<p>如果是为了开发调试，请将错误信息打进日志文件里。强调这一点不仅仅是为了防范SSRF攻击，更是为了避免敏感信息泄漏。例如，DB操作失败后直接将error信息下发，而这个error信息很有可能包含SQL语句。</p>
<blockquote>
<p>再额外多说一嘴，老许的公司对打进日志文件的某些信息还要求脱敏，可谓是十分严格了。</p>
</blockquote>
<p>2、限制请求端口。</p>
<p>在结束之前特别说明一下，SSRF漏洞并不只针对HTTP协议。本篇只讨论HTTP协议是因为go中通过<code>http.Client</code>发起请求时会检测协议类型，某P*P语言这方面检测就会弱很多。虽然<code>http.Client</code>会检测协议类型，但是攻击者仍然可以通过漏洞不断更换端口进行内网端口探测。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/ssrf/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>码了2000多行代码就是为了讲清楚TLS握手流程（续）</title>
            <link>https://isites.github.io/timeline/gotls1.2/</link>
            <pubDate>Sun, 13 Dec 2020 23:47:48 +0800</pubDate>
            
            <guid>https://isites.github.io/timeline/gotls1.2/</guid>
            <description>在“码了2000多行代码就是为了讲清楚TLS握手流程”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。
在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。
结论先行 为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。
单向认证 单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。
下面是笔者运行Demo打印的调试信息：
根据调试信息知，TLS1.2单向认证中总共收发数据四次，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。
笔者将调试信息转换为下述时序图，以方便各位读者理解。
双向认证 双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。
下面是笔者运行Demo打印的调试信息：
同单向认证一样，笔者将调试信息转换为下述时序图。
双向认证和单向认证相比，Server发消息给Client时会额外发送一个certificateRequestMsg消息，Client收到此消息后会将证书信息（certificateMsg）和签名信息（certificateVerifyMsg）发送给Server。
双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有四次。
总结 1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。
2、TLS1.2中除了finishedMsg其余消息均未加密。
3、在TLS1.2中，ChangeCipherSpec消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。
和TLS1.3的比较 消息格式的变化 对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是certificateMsg和certificateMsgTLS13的定义：
// TLS1.2 type certificateMsg struct { raw []byte certificates [][]byte } // TLS1.3 type certificateMsgTLS13 struct { raw []byte certificate tls.Certificate ocspStapling bool scts bool } 其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。
   TLS1.2 TLS1.3     certificateRequestMsg certificateRequestMsgTLS13   certificateMsg certificateMsgTLS13    消息类型的变化 TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：
   TLS1.</description>
            <content type="html"><![CDATA[<p>在“<a href="https://mp.weixin.qq.com/s/ALmouugbrCHrNbyk3OTtSQ">码了2000多行代码就是为了讲清楚TLS握手流程</a>”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。</p>
<p>在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。</p>
<h3 id="结论先行">结论先行</h3>
<p>为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。</p>
<h4 id="单向认证">单向认证</h4>
<p>单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7b4e407a4d300561e2889311bff03b7f?method=download&amp;shareKey=df9641649e598375a3c8bc5baaa93fe9" alt=""></p>
<p>根据调试信息知，TLS1.2单向认证中总共收发数据<strong>四次</strong>，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。</p>
<p>笔者将调试信息转换为下述时序图，以方便各位读者理解。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8229b8e38739b1e3cbe114c158d8a98?method=download&amp;shareKey=1a4a0f4fe5bd9d2b9e6406b4575fe312" alt=""></p>
<h4 id="双向认证">双向认证</h4>
<p>双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB87df88f5543af04290af0c21dca8c17a?method=download&amp;shareKey=2fec2f1d33ffb7dd40c0b47a19c6eb83" alt=""></p>
<p>同单向认证一样，笔者将调试信息转换为下述时序图。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cafa6a349cf1fff0e319767af00dfb1?method=download&amp;shareKey=df90677bde25f8ef809ddd93365759e2" alt=""></p>
<p>双向认证和单向认证相比，Server发消息给Client时会额外发送一个<code>certificateRequestMsg</code>消息，Client收到此消息后会将证书信息（<code>certificateMsg</code>）和签名信息（<code>certificateVerifyMsg</code>）发送给Server。</p>
<p>双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有<strong>四次</strong>。</p>
<h4 id="总结">总结</h4>
<p>1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。</p>
<p>2、TLS1.2中除了<code>finishedMsg</code>其余消息均未加密。</p>
<p>3、在TLS1.2中，<code>ChangeCipherSpec</code>消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。</p>
<h3 id="和tls13的比较">和TLS1.3的比较</h3>
<h4 id="消息格式的变化">消息格式的变化</h4>
<p>对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是<code>certificateMsg</code>和<code>certificateMsgTLS13</code>的定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// TLS1.2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsg</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">certificates</span> [][]<span style="color:#66d9ef">byte</span>
}
<span style="color:#75715e">// TLS1.3
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsgTLS13</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">certificate</span>  <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Certificate</span>
	<span style="color:#a6e22e">ocspStapling</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#a6e22e">scts</span>         <span style="color:#66d9ef">bool</span>
}
</code></pre></div><p>其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">certificateRequestMsg</td>
<td style="text-align:left">certificateRequestMsgTLS13</td>
</tr>
<tr>
<td style="text-align:left">certificateMsg</td>
<td style="text-align:left">certificateMsgTLS13</td>
</tr>
</tbody>
</table>
<h4 id="消息类型的变化">消息类型的变化</h4>
<p>TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">serverKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">clientKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">serverHelloDoneMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">encryptedExtensionsMsg</td>
</tr>
</tbody>
</table>
<h4 id="消息加密的变化">消息加密的变化</h4>
<p>前篇中提到，TLS1.3中除了<code>clientHelloMsg</code>和<code>serverHelloMsg</code>其他消息均做了加密处理，且握手期间和应用数据使用不同的密钥加密。</p>
<p>TLS1.2中仅有<code>finishedMsg</code>做了加密处理，且应用数据也使用该密钥加密。</p>
<p>TLS1.3会计算两次密钥，Client和Server读取对方的<code>HelloMsg</code>和<code>finishedMsg</code>之后即可计算密钥。</p>
<blockquote>
<p>“Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后”，这是前篇中的描述，计算时机描述不准确以上面为准。</p>
</blockquote>
<p>TLS1.2只计算一次密钥，Client和Server分别收到<code>serverKeyExchangeMsg</code>和<code>clientKeyExchangeMsg</code>之后即可计算密钥，和TLS1.3不同的是TLS1.2密钥计算后并不会立即对接下来发送的数据进行加密，只有当发送/接受<code>ChangeCipherSpec</code>消息后才会对接下来的数据进行加解密。</p>
<h4 id="生成密钥过程">生成密钥过程</h4>
<p>TLS1.2和TLS1.3生成密钥的过程还是比较相似的， 下图为Client读取<code>serverKeyExchangeMsg</code>之后的部分处理逻辑：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB931699839f1e500f2493ca4854c4443e?method=download&amp;shareKey=ffa6348e50fcedca417a2b9b3f3b2c36" alt=""></p>
<p>图中<code>X25519</code>是椭圆曲线迪菲-赫尔曼（Elliptic-curve Diffie–Hellman ，缩写为ECDH）密钥交换方案之一，这在前篇已经提到过故本篇不再赘述。</p>
<p>根据Debug结果，本例中<code>ka.preMasterSecret</code>和TLS1.3中的共享密钥生成逻辑完全一致。不仅如此，在后续的代码分析中，笔者发现TLS1.2也使用了<code>AEAD</code>加密算法对数据进行加解密（AEAD在前篇中已经提到过故本篇不再赘述）。</p>
<p>下图为笔者Debug结果：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46c9f6e0eebb4d6e53f69bc2715959e1?method=download&amp;shareKey=83cb14cdf13ea7c2968b6f55260741af" alt=""></p>
<p>图中<code>prefixNonceAEAD</code>即为TLS1.2中AEAD加密算法的一种实现。</p>
<p>这里需要注意的是TLS1.3也会计算<code>masterSecret</code>。为了方便理解，我们先回顾一下TLS1.3中生成<code>masterSecret</code>的部分源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 基于共享密钥派生hs.handshakeSecret
</span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">sharedKey</span>,
    <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">earlySecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
<span style="color:#75715e">// 基于hs.handshakeSecret 派生hs.masterSecret
</span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#66d9ef">nil</span>,
	<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
</code></pre></div><p>由上易知，TLS1.3先通过共享密钥派生出<code>handshakeSecret</code>，最后通过<code>handshakeSecret</code>派生出<code>masterSecret</code>。与此相比，TLS1.2生成<code>masterSecret</code>仅需一步：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">masterFromPreMasterSecret</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">preMasterSecret</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">hello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>)
</code></pre></div><p><code>masterFromPreMasterSecret</code>函数的作用是利用<code>HMAC</code>（HMAC在前篇中已经提到故本篇不再赘述）算法对Client和Server的随机数以及共享密钥进行摘要，从而计算得到<code>masterSecret</code>。</p>
<p><code>masterSecret</code>在后续的过程中并不会用于数据加密，下面笔者带各位读者分别看一下TLS1.3和TLS1.2生成数据加密密钥的过程。</p>
<p>TLS1.3生成数据加密密钥（以Client计算serverSecret为例）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">serverSecret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span>,
	<span style="color:#a6e22e">serverApplicationTrafficLabel</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">transcript</span>)
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">setTrafficSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">serverSecret</span>)
</code></pre></div><p>前篇中提到<code>hs.suite.deriveSecret</code>内部会通过<code>hs.transcript</code>计算出消息摘要从而重新得到一个<code>serverSecret</code>。<code>setTrafficSecret</code>方法内部会对<code>serverSecret</code>计算得到AEAD加密算法所需要的key和iv（初始向量：Initialization vector）。</p>
<p>因此可知TLS1.3计算密钥和Client/Server生成的随机数无直接关系，而与Client/Server当前收发的所有消息的摘要有关。</p>
<blockquote>
<p>补充：
IV通常是随机或者伪随机的。它和数据加密的密钥一起使用可以增加使用字典攻击的攻击者破解密码的难度。例如，如果加密数据中存在重复的序列，则攻击者可以假定消息中相应的序列也是相同的，而IV就是为了防止密文中出现相应的重复序列。</p>
<p>参考：</p>
<p><a href="https://whatis.techtarget.com/definition/initialization-vector-IV">https://whatis.techtarget.com/definition/initialization-vector-IV</a>
<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p>
</blockquote>
<p>TLS1.2生成数据加密密钥：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">clientMAC</span>, <span style="color:#a6e22e">serverMAC</span>, <span style="color:#a6e22e">clientKey</span>, <span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">clientIV</span>, <span style="color:#a6e22e">serverIV</span> <span style="color:#f92672">:=</span>
			<span style="color:#a6e22e">keysFromMasterSecret</span>(<span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">masterSecret</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">clientHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">macLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">keyLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">ivLen</span>)
<span style="color:#a6e22e">serverCipher</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">aead</span>(<span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">serverIV</span>)
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">prepareCipherSpec</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">serverCipher</span>, <span style="color:#a6e22e">serverHash</span>)
</code></pre></div><p>前文中提到<code>masterSecret</code>的生成与Client和Server的随机数有关，而通过<code>keysFromMasterSecret</code>计算AEAD所需的key和iv依旧与随机数有关。</p>
<p><strong>小结</strong>：</p>
<p>1、本例中TLS1.2和TLS1.3均使用<code>X25519</code>算法计算共享密钥。</p>
<p>2、本例中TLS1.2和TLS1.3均使用<code>AEAD</code>进行数据加解密。</p>
<p>3、TLS1.3通过共享密钥派生两次才得到<code>masterSecret</code>，而TLS1.2以共享密钥、Client和Server的随机数一起计算得到<code>masterSecret</code>。</p>
<p>4、TLS1.3通过消息的摘要再次计算得到一个数据加密密钥，而TLS1.2直接通过<code>masterSecret</code>计算得到AEAD所需的key和iv。</p>
<h3 id="tls11和tls10不支持http2">TLS1.1和TLS1.0不支持HTTP2</h3>
<p>在前面提到本文的例子已经支持解析TLS1.x的握手流程，这个时候笔者突然很好奇浏览器还支持那些版本的TLS协议。</p>
<p>然后笔者在谷歌浏览器上首先测试了TLS1.1的服务，为了方便测试笔者改造了之前<a href="">服务器推送的案例</a>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">server</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">Addr</span>: <span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#a6e22e">Handler</span>: <span style="color:#66d9ef">nil</span>}
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span> = new(<span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Config</span>)
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">PreferServerCipherSuites</span> = <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;h2&#34;</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
<span style="color:#75715e">// 服务端支持的最大tls版本调整为1.1
</span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">MaxVersion</span> = <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">VersionTLS11</span>
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">ListenAndServeTLS</span>(<span style="color:#e6db74">&#34;ca.crt&#34;</span>, <span style="color:#e6db74">&#34;ca.key&#34;</span>)
</code></pre></div><p>运行Demo后得到如下截图：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2c8bf091ddf6f390b4a56357eb87fd2f?method=download&amp;shareKey=86fc79ae656452976818c5931a504bf8" alt=""></p>
<p>图中红框部分<code>obsolete</code>的意思笔者也不知，正好学习一波（技术人的英语大概就是这样慢慢积累起来的吧）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBab135aec59a8a4c6f59e89b5e1537686?method=download&amp;shareKey=fd9e75e79f9b3cccacfdc54e38e6193f" alt=""></p>
<p>这下笔者明白了，TLS1.1已经不被支持所以页面才无法正常访问，然而事实真是如此嘛？</p>
<p>直到几天后笔者开始写这篇文章时，内心仍是十分疑惑，于是使用了<code>curl</code>命令再次访问。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5f9afe2142e28f4f2094daca63d5e17b?method=download&amp;shareKey=51250aff915a34a94c60da68ad7719cf" alt=""></p>
<p>图中蓝框部分正是TLS1.1的握手流程，有兴趣的读者可以使用笔者的例子和<code>curl -v</code>命令进行双向验证。</p>
<p>图中红框部分提示说“HTTP2的数据发送失败”，笔者才恍然大悟，将上述代码作如下微调后页面可正常访问。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
</code></pre></div><p>经过笔者的测试，TLS1.0同TLS1.1一样均不支持HTTP2协议，当然这两个协议也不推荐继续使用。</p>
<h3 id="写在最后">写在最后</h3>
<p>“纸上得来终觉浅，绝知此事需躬行”。笔者不敢保证把TLS握手流程的每个细节都讲的十分清楚，所以建议各位读者去github克隆代码，然后自己一步一步Debug必然能够加深印象并彻底理解。当然，顺便关注或者star一下这种随手为之的小事，笔者相信各位读者还是十分乐意的～</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/http2/tls/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
