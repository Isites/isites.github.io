<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Timelines on Gopher指北</title>
        <link>https://isites.gitlab.io/isites/timeline/</link>
        <description>Recent content in Timelines on Gopher指北</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 06 Jun 2021 10:59:48 +0800</lastBuildDate>
        <atom:link href="https://isites.gitlab.io/isites/timeline/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>天涯未远，上海再见，百度再见</title>
            <link>https://isites.gitlab.io/isites/timeline/leave-sh/</link>
            <pubDate>Sun, 06 Jun 2021 10:59:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/leave-sh/</guid>
            <description>关于离开想说的都在标题里。
离开的原因有很多，但是老许并不打算在这里详细阐述。说的越多都是在反复鞭尸自己的无能，老许对此次的离开总结为两个字——“败犬”（并无意冒犯他人，仅仅是对自己的总结。如果有兴趣交流的可以在公众号后台私我）。
以下为老许近一个多月的反思，这份反思没有什么大道理，更没有什么必须记住的知识点，老许写下来只是希望和各位读者有一个平等交流的机会。
一个无解的行业现状 &amp;ldquo;居安思危&amp;rdquo;，古人诚不欺我。我自认为在百度工作期间还是成长了很多，但是难免有松懈的时候，因此总的算下来是以一种平缓的速度进步。很长一段时间内老许都满足于现状，直到在金三银四的浪潮里开始挣扎。
“没有进步应该下十八层地狱，进步的慢更是一种原罪”，这是老许不由自主的感叹。以leetcode为例，不刷个一两百道题仿佛都不好意思出去面试。不知道这是不是内卷的一种。如果是，那一定是这个行业的人越来越多造成的。在程序猿从业人口越来越多的情况下，已经身在其中的人真是一刻也不容松懈呀。
 写下这一段我也很犹豫，总有散播焦虑的嫌疑，但事实上这就是我真实的感受。
 我简直毫无自控力 我简直毫无自控力，这个感悟来自于接受offer之后，把“某音”又重新装了回来。为什么会存在把它卸载这个事情呢？源自于开始找工作之后发现它严重影响了我的复习时间。明明知道应该把大量时间花在复习上，却总是不知不觉间刷起了短视频。虽然最近又把“某音”卸载了，但是又开始沉迷于某小破站。果然自控力对我来说就是扯淡。
和我等凡人不同，有些人明明已经成为了神，还是以极强的自控力给自己制定各种OKR和学习计划。看到这类人的时候，老许充分意识到作为一名凡夫俗子还是有点好高骛远了。他们欲带皇冠必承其重，我也不奢求自己有超强的自控力，只要在主次不颠倒的情况下，劳逸结合，按照合理的节奏前进即可，为达这个目的哪怕是以卸载这种强硬手段。
关于学习的反思 很早以前有人告诉我，“好记性不如烂笔头，但是最终你依旧要把它记在脑子里面才行”。这句话我深以为然，也是一直如此践行着。因此很多东西我做笔记也只是为了记住，而今终于自食恶果。
相信很多人都有这样一种感觉，年纪越大记忆力越来越差。我之前对某些知识点记忆不熟，也归咎于这个原因。我虽然做了笔记，但是没有对知识点做一个系统性的梳理，因此在我脑海中的知识点是杂乱无序的，自然忘的快。
幸运的是，我周边有这样的人在记忆知识点时会利用脑图做系统性的梳理。发现这一点时我幡然醒悟，我以前一直没有用一个有效的方法去记知识点。这个方法并不是什么秘密，很多人都知道但是并没有去使用。我相信这些人都和我一样只是缺少一个鹈鹕灌顶大彻大悟的契机。因此，我发自内心的感谢和我相遇的每一个人。
两个人的知识点不可能完全重合，因为你不可能看完所有的书，也不可能遇到他人遇到的所有实际问题，所以除了认真学习，获取知识点的另外一种有效途径就是交流和分享
对未来的规划和选择 这一段心里想了很多很多，有关于公司的选择，有关于未来的发展计划，但这些我自己也充满了不自信，所以就不在这里献丑了。
老许继续写下这段的原因是提醒自己现在的我还有选择的权利，如果有一天连选择的权利都没有了才是真正的穷途末路。虽然对未来依旧忐忑，但对老许来说一定会坚持的三件事是运动、挣钱和学习。相信这对所有人来说都是一样的（仿佛一句废话）。
最后，很庆幸有这样的一段时间，让自己重新思考，或许前路依旧迷雾重重，但依旧要砥砺前行。
最后的最后，感谢这一路上遇见的人和事。
【关注公众号】</description>
            <content type="html"><![CDATA[<p>关于离开想说的都在标题里。</p>
<p>离开的原因有很多，但是老许并不打算在这里详细阐述。说的越多都是在反复鞭尸自己的无能，老许对此次的离开总结为两个字——“败犬”（并无意冒犯他人，仅仅是对自己的总结。如果有兴趣交流的可以在公众号后台私我）。</p>
<p>以下为老许近一个多月的反思，这份反思没有什么大道理，更没有什么必须记住的知识点，老许写下来只是希望和各位读者有一个平等交流的机会。</p>
<h2 id="一个无解的行业现状">一个无解的行业现状</h2>
<p>&ldquo;居安思危&rdquo;，古人诚不欺我。我自认为在百度工作期间还是成长了很多，但是难免有松懈的时候，因此总的算下来是以一种平缓的速度进步。很长一段时间内老许都满足于现状，直到在金三银四的浪潮里开始挣扎。</p>
<p>“没有进步应该下十八层地狱，进步的慢更是一种原罪”，这是老许不由自主的感叹。以<code>leetcode</code>为例，不刷个一两百道题仿佛都不好意思出去面试。不知道这是不是内卷的一种。如果是，那一定是这个行业的人越来越多造成的。在程序猿从业人口越来越多的情况下，已经身在其中的人真是一刻也不容松懈呀。</p>
<blockquote>
<p>写下这一段我也很犹豫，总有散播焦虑的嫌疑，但事实上这就是我真实的感受。</p>
</blockquote>
<h2 id="我简直毫无自控力">我简直毫无自控力</h2>
<p>我简直毫无自控力，这个感悟来自于接受offer之后，把“某音”又重新装了回来。为什么会存在把它卸载这个事情呢？源自于开始找工作之后发现它严重影响了我的复习时间。明明知道应该把大量时间花在复习上，却总是不知不觉间刷起了短视频。虽然最近又把“某音”卸载了，但是又开始沉迷于某小破站。果然自控力对我来说就是扯淡。</p>
<p>和我等凡人不同，有些人明明已经成为了神，还是以极强的自控力给自己制定各种OKR和学习计划。看到这类人的时候，老许充分意识到作为一名凡夫俗子还是有点好高骛远了。他们欲带皇冠必承其重，我也不奢求自己有超强的自控力，只要在主次不颠倒的情况下，劳逸结合，按照合理的节奏前进即可，为达这个目的哪怕是以卸载这种强硬手段。</p>
<h2 id="关于学习的反思">关于学习的反思</h2>
<p>很早以前有人告诉我，“好记性不如烂笔头，但是最终你依旧要把它记在脑子里面才行”。这句话我深以为然，也是一直如此践行着。因此很多东西我做笔记也只是为了记住，而今终于自食恶果。</p>
<p>相信很多人都有这样一种感觉，年纪越大记忆力越来越差。我之前对某些知识点记忆不熟，也归咎于这个原因。我虽然做了笔记，但是没有对知识点做一个系统性的梳理，因此在我脑海中的知识点是杂乱无序的，自然忘的快。</p>
<p>幸运的是，我周边有这样的人在记忆知识点时会利用脑图做系统性的梳理。发现这一点时我幡然醒悟，我以前一直没有用一个有效的方法去记知识点。这个方法并不是什么秘密，很多人都知道但是并没有去使用。我相信这些人都和我一样只是缺少一个鹈鹕灌顶大彻大悟的契机。因此，我发自内心的感谢和我相遇的每一个人。</p>
<p>两个人的知识点不可能完全重合，因为你不可能看完所有的书，也不可能遇到他人遇到的所有实际问题，所以除了认真学习，获取知识点的另外一种有效途径就是交流和分享</p>
<h2 id="对未来的规划和选择">对未来的规划和选择</h2>
<p>这一段心里想了很多很多，有关于公司的选择，有关于未来的发展计划，但这些我自己也充满了不自信，所以就不在这里献丑了。</p>
<p>老许继续写下这段的原因是提醒自己现在的我还有选择的权利，如果有一天连选择的权利都没有了才是真正的穷途末路。虽然对未来依旧忐忑，但对老许来说一定会坚持的三件事是运动、挣钱和学习。相信这对所有人来说都是一样的（仿佛一句废话）。</p>
<p>最后，很庆幸有这样的一段时间，让自己重新思考，或许前路依旧迷雾重重，但依旧要砥砺前行。</p>
<p>最后的最后，感谢这一路上遇见的人和事。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>有趣！一行代码居然无法获取请求的完整URL</title>
            <link>https://isites.gitlab.io/isites/timeline/get-full-url/</link>
            <pubDate>Mon, 29 Mar 2021 19:36:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/get-full-url/</guid>
            <description>缘起 做Web服务的时候，可能会有这样一个业务场景，获取一个HTTP请求的完整URL。很巧，老许就碰到了这样的业务场景。面对如此简单的需求，CV大法根本没有展示才能的机会。啪啪啪，获取请求的完整URL代码就出来了。
当时离验证只差一步，老许信心满满，很快，打脸来得很快就像龙卷风。。。
从图中可以知道，req.URL中的Scheme和Host均为空，所以r.URL.String()无法得到完整的请求连接。这个结果让老许一阵激动，万万没想到有一天我也有机会发现Go源码中可能遗漏的赋值。老许强行按耐住心中的激动，准备好好研究一番，万一成为了Go的Contributor呢^ω^。最后发现官方实现没有问题，因此就有了今天这篇文章。
HTTP1.1中为什么无法获取完整的连接 HTTP1.1的Server读取请求并构建Request.URL对象的逻辑在request.go文件的readRequest方法中，下面老许对其源码做一个简单分析总结。
 读取请求的第一行，HTTP请求的第一行又称为请求行。  // First line: GET /index.html HTTP/1.0 var s string if s, err = tp.ReadLine(); err != nil { return nil, err } 将请求行的内容分别解析为req.Method、req.RequestURI和req.Proto。  var ok bool req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s) 将req.RequestURI解析为req.URL。  rawurl := req.RequestURI if req.URL, err = url.ParseRequestURI(rawurl); err != nil { return nil, err }  注：当请求方法是CONNECT时，上述流程略有变化
 通过上面的流程我们知道req.URL的数据来源为req.RequestURI，而req.RequestURI到底是什么让我们继续阅读后文。
请求资源 根据rfc7230中的定义， 请求行分为请求方法、请求资源和HTTP版本，分别对应上述的req.Method、req.RequestURI和req.Proto（request-target在本文均被译作请求资源）。
关于请求方法有哪些想必不用老许在这儿科普了吧。至于常用的HTTP版本无非就是HTTP1.1和HTTP2。 下面主要介绍请求资源的几种形式。
origin-form 这种形式是请求资源中最常见的形式，其格式定义如下。</description>
            <content type="html"><![CDATA[<h2 id="缘起">缘起</h2>
<p>做Web服务的时候，可能会有这样一个业务场景，获取一个HTTP请求的完整URL。很巧，老许就碰到了这样的业务场景。面对如此简单的需求，CV大法根本没有展示才能的机会。啪啪啪，获取请求的完整URL代码就出来了。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1b388f6771a1db510b40ef8a8d5eebae?method=download&amp;shareKey=9cb4b3dffe79b0a2eaa385a09947d7a6" alt=""></p>
<p>当时离验证只差一步，老许信心满满，很快，打脸来得很快就像龙卷风。。。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB996f7f766dd31e910911a18f8b86fa44?method=download&amp;shareKey=25f35485c3812f561c3da580916f7f4d" alt=""></p>
<p>从图中可以知道，<code>req.URL</code>中的<code>Scheme</code>和<code>Host</code>均为空，所以<code>r.URL.String()</code>无法得到完整的请求连接。这个结果让老许一阵激动，万万没想到有一天我也有机会发现Go源码中可能遗漏的赋值。老许强行按耐住心中的激动，准备好好研究一番，万一成为了Go的Contributor呢^ω^。最后发现官方实现没有问题，因此就有了今天这篇文章。</p>
<h2 id="http11中为什么无法获取完整的连接">HTTP1.1中为什么无法获取完整的连接</h2>
<p>HTTP1.1的Server读取请求并构建<code>Request.URL</code>对象的逻辑在request.go文件的<code>readRequest</code>方法中，下面老许对其源码做一个简单分析总结。</p>
<ol>
<li>读取请求的第一行，HTTP请求的第一行又称为请求行。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// First line: GET /index.html HTTP/1.0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">tp</span>.<span style="color:#a6e22e">ReadLine</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
}
</code></pre></div><ol start="2">
<li>将请求行的内容分别解析为<code>req.Method</code>、<code>req.RequestURI</code>和<code>req.Proto</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>
<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">RequestURI</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Proto</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">parseRequestLine</span>(<span style="color:#a6e22e">s</span>)
</code></pre></div><ol start="3">
<li>将<code>req.RequestURI</code>解析为<code>req.URL</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">rawurl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">RequestURI</span>
<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">ParseRequestURI</span>(<span style="color:#a6e22e">rawurl</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
}
</code></pre></div><blockquote>
<p>注：当请求方法是CONNECT时，上述流程略有变化</p>
</blockquote>
<p>通过上面的流程我们知道<code>req.URL</code>的数据来源为<code>req.RequestURI</code>，而<code>req.RequestURI</code>到底是什么让我们继续阅读后文。</p>
<h3 id="请求资源">请求资源</h3>
<p>根据rfc7230中的定义， 请求行分为请求方法、请求资源和HTTP版本，分别对应上述的<code>req.Method</code>、<code>req.RequestURI</code>和<code>req.Proto</code>（request-target在本文均被译作请求资源）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fcef32e2e58798269cc3809e45c75c4?method=download&amp;shareKey=5b2a53ff2aff6ebbed544e692d92c85d" alt=""></p>
<p>关于请求方法有哪些想必不用老许在这儿科普了吧。至于常用的HTTP版本无非就是HTTP1.1和HTTP2。 下面主要介绍请求资源的几种形式。</p>
<h4 id="origin-form">origin-form</h4>
<p>这种形式是请求资源中最常见的形式，其格式定义如下。</p>
<pre><code>origin-form    = absolute-path [ &quot;?&quot; query ]
</code></pre><p>当直接向服务器发起请求时，除开CONNECT和OPTIONS请求，只允许发送path和query作为请求资源。如果请求链接的path为空，则必须发送<code>/</code>作为请求资源。请求链接中的Host信息以Header头的形式发送。</p>
<p>以<code>http://www.example.org/where?q=now</code>为例，请求行和Host请求头信息如下</p>
<pre><code>GET /where?q=now HTTP/1.1
Host: www.example.org
</code></pre><h4 id="absolute-form">absolute-form</h4>
<p>这种形式目前仅在向代理发起请求时使用，其格式定义如下。</p>
<pre><code>absolute-form  = absolute-URI
</code></pre><p>根据rfc7230中的定义，目前client仅会向代理发送这种形式的请求资源，但为了将来某个HTTP版本可能会转换为这种形式的请求资源所以server需要支持这种形式的请求资源。这大概就是为什么<code>req.URL</code>中大部分字段值为空却仍然将URL各部分定义完整的原因。</p>
<p>一个<code>absolute-form</code>形式的请求行例子如下。</p>
<pre><code>GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</code></pre><h4 id="authority-form">authority-form</h4>
<p><code>authority-form</code>形式的请求资源仅用于<code>CONNECT</code>请求中，其格式定义如下。</p>
<pre><code>authority-form = authority
</code></pre><p>发送<code>CONNECT</code>请求时，client只能发送URI的authority部分（不包含userinfo和@定界符）作为请求资源。这样讲比较抽象， 我们先来看看<code>http-URI</code>的定义。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9a1f70183935d70850b51956403b3d96?method=download&amp;shareKey=34a7404d25c494cd9c889216ed50819e" alt=""></p>
<p>通过上面这张图大概能够猜出来<code>authority</code>应该是指Host信息。Very Good！你没有猜错！</p>
<pre><code>The origin server for an &quot;http&quot; URI is identified by the authority component, which includes a host identifier and optional TCP port.
</code></pre><p>上面是rfc7230对于authority的解释。老许根据自己的翻译，在这里单方面宣布<code>authority</code>包括主机标识符和可选的端口信息。一个<code>authority-form</code>形式的请求行例子如下。</p>
<pre><code>CONNECT www.example.com:80 HTTP/1.1
</code></pre><h4 id="asterisk-form">asterisk-form</h4>
<p><code>asterisk-form</code>形式的请求资源仅适用于<code>OPTIONS</code>请求且只能为<code>*</code>，其格式定义如下。</p>
<pre><code>asterisk-form  = &quot;*&quot;
</code></pre><p>一个<code>asterisk-form</code>形式的请求行例子如下。</p>
<pre><code>OPTIONS * HTTP/1.1
</code></pre><p>对上面几种形式的请求资源有所了解后，我们再次回到获取请求的完整URL这一问题本身。以最常用的<code>absolute-form</code>为例（其他形式的请求资源我们在开发中几乎不用考虑），请求资源中本身就缺少<code>Host</code>和<code>Scheme</code>信息，所以一行代码自然无法获取请求的完整URL。难道我们就无法获取到请求的完整URL嘛？当然不是，我们还可以通过以下两种方案得到完整的URL。</p>
<p><strong>方案一</strong>：</p>
<ol>
<li>通过<code>req.Host</code>得到Host相关信息。</li>
<li>如果<code>req.TLS == nil</code>则为HTTP请求，否则为HTTPS请求。</li>
<li>通过步骤1、步骤2并结合请求行信息即可得到完整的URL。</li>
</ol>
<p><strong>方案二</strong>：
在配置文件中配置好服务的Host信息，获取完整请求时只需要读取配置文件并拼接<code>req.RequestURI</code>即可。事实上老许采用的就是方案二，因为很多服务都在网关后面。当客户端使用HTTPS请求网关，网关以HTTP请求服务时使用<code>req.TLS == nil</code>判断就不合理了。</p>
<h2 id="http2中为什么无法获取完整的连接">HTTP2中为什么无法获取完整的连接</h2>
<p>需要注意的是在HTTP2中已经没有请求行的概念了，取而代之的是请求伪标头，这一点老许在<a href="https://mp.weixin.qq.com/s/HTGg5HYRSVY-4-H9Sf1zww">Go发起HTTP2.0请求流程分析(后篇)——标头压缩</a>这篇文章中提到过。</p>
<p>下图为一次HTTP2请求的部分Header信息。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB21b6c46dfb68ab42e0f5f00830a3cda5?method=download&amp;shareKey=444b90bc7502a0befde80ba2a08ae545" alt=""></p>
<p>从图中可以发现，HTTP1.1中的请求行已经没有了。根据rfc7540中的定义，请求的伪标头字段有<code>:method</code>、<code>:scheme</code>、<code>:authority</code>和<code>:path</code>。</p>
<p><code>:method</code>和<code>:scheme</code>不需要老许多说，看英文单词的意思就可以了。</p>
<p><code>:authority</code>: 根据前文的解释，其值为主机标识符和可选的端口信息。另外需要注意的是HTTP2中没有<code>Host</code>请求头。</p>
<p><code>:path</code>: 如果是<code>OPTIONS</code>请求，则其值为<code>*</code>。其他情况该值为请求URI的path和query，如果path为空则其值为<code>/</code>。</p>
<p>在对HTTP2请求的伪标头有了一个基本了解后，下面我们来看一下<code>Request.URL</code>的赋值过程。HTTP2的Server读取请求并构建<code>Request.URL</code>对象的逻辑在h2_bundle.go文件的<code>(*http2serverConn).newWriterAndRequestNoBody</code>方法中。</p>
<ol>
<li>如果是<code>CONNECT</code>请求通过<code>:authority</code>构建<code>url_</code>，否则通过<code>:path</code>构建<code>url_</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">method</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;CONNECT&#34;</span> {
	<span style="color:#a6e22e">url_</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">URL</span>{<span style="color:#a6e22e">Host</span>: <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span>}
	<span style="color:#a6e22e">requestURI</span> = <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span> <span style="color:#75715e">// mimic HTTP/1 server behavior
</span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
	<span style="color:#a6e22e">url_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">ParseRequestURI</span>(<span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">path</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">http2streamError</span>(<span style="color:#a6e22e">st</span>.<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">http2ErrCodeProtocol</span>)
	}
	<span style="color:#a6e22e">requestURI</span> = <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">path</span>
}
</code></pre></div><ol start="2">
<li>将<code>url_</code>赋值给<code>req.URL</code>。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">req</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Request</span>{
	<span style="color:#a6e22e">Method</span>:     <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">method</span>,
	<span style="color:#a6e22e">URL</span>:        <span style="color:#a6e22e">url_</span>,
	<span style="color:#a6e22e">RemoteAddr</span>: <span style="color:#a6e22e">sc</span>.<span style="color:#a6e22e">remoteAddrStr</span>,
	<span style="color:#a6e22e">Header</span>:     <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">header</span>,
	<span style="color:#a6e22e">RequestURI</span>: <span style="color:#a6e22e">requestURI</span>,
	<span style="color:#a6e22e">Proto</span>:      <span style="color:#e6db74">&#34;HTTP/2.0&#34;</span>,
	<span style="color:#a6e22e">ProtoMajor</span>: <span style="color:#ae81ff">2</span>,
	<span style="color:#a6e22e">ProtoMinor</span>: <span style="color:#ae81ff">0</span>,
	<span style="color:#a6e22e">TLS</span>:        <span style="color:#a6e22e">tlsState</span>,
	<span style="color:#a6e22e">Host</span>:       <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span>,
	<span style="color:#a6e22e">Body</span>:       <span style="color:#a6e22e">body</span>,
	<span style="color:#a6e22e">Trailer</span>:    <span style="color:#a6e22e">trailer</span>,
}
</code></pre></div><p>由于<code>:path</code>标头的值也不包含Host信息，所以HTTP2的server也无法通过<code>req.URL.String()</code>得到请求的完整URL。</p>
<p>在这里我们反思一个问题。通过伪标头字段已经能够得到完整的URL，为什么仍然只读取<code>:path</code>和<code>:authority</code>中的一个来赋值<code>req.URL</code>呢？</p>
<p>老许在这里猜测可能原因是希望开发者无需关心请求是HTTP1.1还是HTTP2，避免不必要的HTTP版本判断。</p>
<p>关于获取请求完整URL的思考就到这里。最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
</ol>
</blockquote>
<p>参考：</p>
<p><a href="https://tools.ietf.org/html/rfc7230">https://tools.ietf.org/html/rfc7230</a></p>
<p><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>白话Go内存模型&amp;Happen-Before</title>
            <link>https://isites.gitlab.io/isites/timeline/go-memory-model/</link>
            <pubDate>Thu, 04 Mar 2021 18:53:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/go-memory-model/</guid>
            <description>Go内存模型明确指出，一个goroutine如何才能观察到其他goroutine对同一变量的写操作。
当多个goroutine并发同时存取同一个数据时必须把并发的存取操作序列化。在Go中保证读写的序列化可以通过channel通信或者其他同步原语（例如sync包中的互斥锁、读写锁和sync/atomic中的原子操作）。
Happens Before 在单goroutine中，读取和写入的行为一定是和程序指定的执行顺序表现一致。换言之，编译器和处理器在不改变语言规范所定义的行为前提下才可以对单个goroutine中的指令进行重排序。
a := 1 b := 2 由于指令重排序，b := 2可能先于a := 1执行。单goroutine中，该执行顺序的调整并不会影响最终结果。但多个goroutine场景下可能就会出现问题。
var a, b int // goroutine A go func() { a := 5 b := 1 }() // goroutine B go func() { for b == 1 {} fmt.Println(a) }() 执行上述代码时，预期goroutine B能够正常输出5，但因为指令重排序，b := 1可能先于a := 5执行，最终goroutine B可能输出0。
 注：上述例子是个不正确的示例，仅作说明用。
 为了明确读写的操作的要求，Go中引入了happens before，它表示执行内存操作的一种偏序关系。
happens-before的作用 多个goroutine访问共享变量时，它们必须建立同步事件来确保happens-before条件，以此确保读能够观察预期的写。
什么是Happens Before 如果事件e1发生在事件e2之前，那么我们说e2发生在e1之后。 同样，如果e1不在e2之前发生也没有在e2之后发生，那么我们说e1和e2同时发生。
在单个goroutine中，happens-before的顺序就是程序执行的顺序。那happens-before到底是什么顺序呢？我们看看下面的条件。
如果对于一个变量v的读操作r和写操作w满足下述两个条件，r才允许观察到w：
 r没有发生在w之前。 没有其他写操作发生在w之后和r之前。  为了保证变量v的一个读操作r能够观察到一个特定的写操作w，需要确保w是唯一允许被r观察的写操作。那么，如果 r、w 都满足以下条件，r就能确保观察到w：</description>
            <content type="html"><![CDATA[<p>Go内存模型明确指出，一个goroutine如何才能观察到其他goroutine对同一变量的写操作。</p>
<p>当多个goroutine并发同时存取同一个数据时必须把并发的存取操作序列化。在Go中保证读写的序列化可以通过channel通信或者其他同步原语（例如sync包中的互斥锁、读写锁和sync/atomic中的原子操作）。</p>
<h1 id="happens-before">Happens Before</h1>
<p>在单goroutine中，读取和写入的行为一定是和程序指定的执行顺序表现一致。换言之，编译器和处理器在不改变语言规范所定义的行为前提下才可以对单个goroutine中的指令进行重排序。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>
</code></pre></div><p>由于指令重排序，<code>b := 2</code>可能先于<code>a := 1</code>执行。单goroutine中，该执行顺序的调整并不会影响最终结果。但多个goroutine场景下可能就会出现问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
<span style="color:#75715e">// goroutine A
</span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
}()
<span style="color:#75715e">// goroutine B
</span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {}
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
}()
</code></pre></div><p>执行上述代码时，预期goroutine B能够正常输出5，但因为指令重排序，<code>b := 1</code>可能先于<code>a := 5</code>执行，最终goroutine B可能输出0。</p>
<blockquote>
<p><strong>注</strong>：上述例子是个不正确的示例，仅作说明用。</p>
</blockquote>
<p>为了明确读写的操作的要求，Go中引入了<code>happens before</code>，它表示执行内存操作的一种偏序关系。</p>
<h2 id="happens-before的作用">happens-before的作用</h2>
<p>多个goroutine访问共享变量时，它们必须建立同步事件来确保happens-before条件，以此确保读能够观察预期的写。</p>
<h2 id="什么是happens-before">什么是Happens Before</h2>
<p>如果事件e1发生在事件e2之前，那么我们说e2发生在e1之后。 同样，如果e1不在e2之前发生也没有在e2之后发生，那么我们说e1和e2同时发生。</p>
<p>在单个goroutine中，happens-before的顺序就是程序执行的顺序。那happens-before到底是什么顺序呢？我们看看下面的条件。</p>
<p>如果对于一个变量v的读操作r和写操作w满足下述两个条件，r才<strong>允许</strong>观察到w：</p>
<ol>
<li>r没有发生在w之前。</li>
<li>没有其他写操作发生在w之后和r之前。</li>
</ol>
<p>为了保证变量v的一个读操作r能够观察到一个特定的写操作w，需要确保w是唯一允许被r观察的写操作。那么，如果 r、w 都满足以下条件，r就能<strong>确保</strong>观察到w：</p>
<ol>
<li>w发生在r之前。</li>
<li>其他写操作发生在w之前后者r之后。</li>
</ol>
<p>单goroutine中不存在并发，这两个条件是等价的。老许在此基础上扩展一下，对于单核心的运行环境这两组条件同样等价。并发情况下，后一组条件比第一组更加严格。</p>
<p>假如你很疑惑，那就对了！老许最开始也很疑惑，这两组条件就是一样的呀。为此老许特地和原文进行了反复对比确保上述的理解是没有问题的。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBebd7cd55c1ff407b05900807355c9010?method=download&amp;shareKey=91b03f6fdf992ed04c06d873219e3725" alt=""></p>
<p>我们换个思路，进行反向推理。如果这两组条件一样，那原文没必要写两次，果然此事并不简单。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ef1aa573f52434032ce40c6d525509f?method=download&amp;shareKey=464df8124d6c3a538a5f20189d68890c" alt=""></p>
<p>在继续分析之前，要先感谢一下我的语文老师，没有你我就无法发现它们的不同。</p>
<p><code>r没有发生在w之前</code>，则r可能的情况是r发生在w之后或者和w同时发生，如下图（实心表示可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9d6ef4da5ed351b7be9714404cea7a16?method=download&amp;shareKey=535d89b4786491f6b3ae27f7527b34bf" alt=""></p>
<p><code>没有其他写操作发生在w之后和r之前</code>，则其他写w&rsquo;可能发生在w之前或者和w同时发生，也可能发生在r之后或者和r同时发生，如下图（实心表示可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb31fc5b4f9b84711a39f34270bd4eca1?method=download&amp;shareKey=7cb5b00eca87f4552676665227d2ccd5" alt=""></p>
<p>第二组条件就很明确了，w发生在r之前且其他写操作只能发生在w之前或者r之后，如下图（空心表示不可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBcd7396985d35dba916d914f9139d2ca0?method=download&amp;shareKey=bcaa56ab18dd267da16c10431ddad674" alt=""></p>
<p>到这儿应该明白为什么第二组条件比第一组条件更加严格了吧。在第一组的条件下是允许观察到w，第二组是保证能观察到w。</p>
<h1 id="go中的同步">Go中的同步</h1>
<p>下面是Go中约定好的一些同步事件，它们能确保程序遵循happens-before原则，从而使并发的goroutine相对有序。</p>
<h2 id="go的初始化">Go的初始化</h2>
<p>程序初始化运行在单个goroutine中，但是该goroutine可以创建其他并发运行的goroutine。</p>
<p>如果包p导入了包q，则q包init函数执行结束先于p包init函数的执行。main函数的执行发生在所有init函数执行完成之后。</p>
<h2 id="goroutine的创建结束">goroutine的创建结束</h2>
<p>goroutine的创建先于goroutine的执行。老许觉得这基本就是废话，但事情总是没有那么简单，其隐含之意大概是goroutine的创建是阻塞的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sleep</span>() <span style="color:#66d9ef">bool</span> {
   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sleep</span>())
</code></pre></div><p>上述代码会阻塞主goroutine一秒，然后才创建子goroutine。</p>
<p>goroutine的退出是无法预测的。如果用一个goroutine观察另一个goroutine，请使用锁或者Channel来保证相对有序。</p>
<h2 id="channel的发送和接收">Channel的发送和接收</h2>
<p>Channel通信是goroutine之间同步的主要方式。</p>
<ul>
<li>
<p>Channel的发送动作先于相应的接受动作完成之前。</p>
</li>
<li>
<p>无缓冲Channel的接受先于该Channel上的发送完成之前。</p>
</li>
</ul>
<p>这两点总结起来分别是<code>开始发送</code>、<code>开始接受</code>、<code>发送完成</code>和<code>接受完成</code>四个动作，其时序关系如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">开始发送 &gt; 接受完成
开始接受 &gt; 发送完成
</code></pre></div><blockquote>
<p>注意：开始发送和开始接受并无明确的先后关系</p>
</blockquote>
<ul>
<li>
<p>Channel的关闭发生在由于通道关闭而返回零值接受之前。</p>
</li>
<li>
<p>容量为C的Channel第k个接受先于该Channel上的第k+C个发送完成之前。</p>
</li>
</ul>
<p>这里使用极限法应该更加易于理解，如果C为0，k为1则其含义和无缓冲Channel的一致。</p>
<h2 id="lock">Lock</h2>
<p>对于任何sync.Mutex或sync.RWMutex变量l以及n &lt; m，第n次l.Unlock()的调用先于第m次l.Lock()的调用返回。</p>
<p>假设n为1，m为2，则第二次调用l.Lock()返回前一定要先调用l.UnLock()。</p>
<p>对于sync.RWMutex的变量l存在这样一个n，使得l.RLock()的调用返回在第n次l.Unlock()之后发生，而与之匹配的l.RUnlock()发生在第n + 1次l.Lock()之前。</p>
<p>不得不说，上面这句话简直不是人能理解的。老许将其翻译成人话：</p>
<p>有写锁时：l.RLock()的调用返回发生在l.Unlock()之后。</p>
<p>有读锁时：l.RUnlock()的调用发生在l.Lock()之前。</p>
<blockquote>
<p>注意：调用l.RUnlock()前不调用l.RLock()和调用l.Unlock()前不调用l.Lock()会引起panic。</p>
</blockquote>
<h2 id="once">Once</h2>
<p>once.Do(f)中f的返回先于任意其他once.Do的返回。</p>
<h1 id="不正确的同步">不正确的同步</h1>
<p><strong>错误示范一</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
	<span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">1</span>
	<span style="color:#a6e22e">b</span> = <span style="color:#ae81ff">2</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
	print(<span style="color:#a6e22e">b</span>)
	print(<span style="color:#a6e22e">a</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
	<span style="color:#a6e22e">g</span>()
}
</code></pre></div><p>这个例子看起来挺简单，但是老许相信大部分人应该会忽略指令重排序引起的异常输出。假如goroutine f指令重排序后，<code>b=2</code>先于<code>a=1</code>发生，此时主goroutine观察到b发生变化而未观察到a变化，因此有可能输出<code>20</code>。</p>
<blockquote>
<p>老许在本地实验了多次结果都是输出<code>00</code>，<code>20</code>这个输出估计只活在理论之中了。</p>
</blockquote>
<p><strong>错误示范二</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#66d9ef">bool</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
	<span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
	<span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doprint</span>() {
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">done</span> {
		<span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">setup</span>)
	}
	print(<span style="color:#a6e22e">a</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoprint</span>() {
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
}
</code></pre></div><p>这种双重检测本意是为了避免同步的开销，但是依旧有可能打印出空字符串而不是“hello, world”。说实话老许自己都不敢保证以前没有写过这样的代码。现在唯一能想到的场景就是其中一个goroutine doprint执行到<code>done = true</code>（指令重排序导致<code>done=true</code>先于<code>a=&quot;hello, world&quot;</code>执行）时，另一个goroutine doprint刚开始执行并观察到done的值为true从而打印空字符串。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。当然，发现错误也还请及时联系老许改正。</p>
<p><strong>参考</strong></p>
<p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>1分钟内的Linux性能分析法</title>
            <link>https://isites.gitlab.io/isites/timeline/60-linux/</link>
            <pubDate>Mon, 01 Feb 2021 20:30:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/60-linux/</guid>
            <description>本着“拿来主义”的精神，吸收他人长处为己用。老许翻译一篇Linux性能分析相关的文章分享给各位读者，同时也加深自己的印象。
 你登录到具有性能问题的Linux服务器时，第一分钟要检查什么？
在Netflix，我们拥有庞大的Linux EC2云实例，以及大量的性能分析工具来监视和调查它们的性能。这些工具包括Atlas和Vector。Atlas用于全云监控，Vector用于按需实例分析。这些工具能帮助我们解决大部分问题，但有时候我们仍需登录实例并运行一些标准的Linux性能工具。
 Atlas：根据github上面的文档老许简单说一下自己的认知。一个可以管理基于时间维度数据的后端，同时具有内存存储功能可以非常快速地收集和报告大量指标。
Vector：Vector是一个主机上的性能监视框架，它可以将各种指标展示在工程师的浏览器上面。
 总结 在这篇文章中，Netflix性能工程团队将向您展示通过命令行进行性能分析是，前60秒应该使用那些Linux标准工具。在60秒内，你可以通过以下10个命令来全面了解系统资源使用情况和正在运行的进程。首先寻找错误和饱和指标，因为他们很容易理解，然后是资源利用率。饱和是指资源负载超出其处理能力，其可以表现为一个请求队列的长度或者等待时间。
uptime dmesg | tail vmstat 1 mpstat -P ALL 1 pidstat 1 iostat -xz 1 free -m sar -n DEV 1 sar -n TCP,ETCP 1 top 其中一些命令需要安装sysstat软件包。这些命令暴露的指标是一种帮助你完成USE Method（Utilization Saturation and Errors Method）——一种查找性能瓶颈的方法。这涉及检查所有资源（CPU、内存、磁盘等）利用率，饱和度和错误等指标。同时还需注意通过排除法可以逐步缩小资源检查范围。
以下各节通过生产系统中的示例总结了这些命令。这些命令的更多信息，请参考使用手册。
uptime $ uptime 23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02 这是一种快速查看平均负载的方法，它指示了等待运行的进程数量。在Linux系统上，这些数字包括要在CPU上运行的进程以及处于I/O（通常是磁盘I/O）阻塞的进程。这提供了资源负载的大概状态，没有其他工具就无法理解更多。仅值得一看。
这三个数字分别代表着1分钟、5分钟和15分钟内的平均负载。这三个指标让我们了解负载是如何随时间变化的。例如，你被要求检查有问题的服务器，而1分钟的值远低于15分钟的值，则意味着你可能登录的太晚而错过了问题现场。
在上面的例子中，最近的平均负载增加，一分钟值达到30，而15分钟值达到19。数字如此之大意味着很多：可能是CPU需求（可以通过后文中介绍的vmstat或mpstat命令来确认）。
dmesg | tail $ dmesg | tail [1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0 [.</description>
            <content type="html"><![CDATA[<blockquote>
<p>本着“拿来主义”的精神，吸收他人长处为己用。老许翻译一篇Linux性能分析相关的文章分享给各位读者，同时也加深自己的印象。</p>
</blockquote>
<p>你登录到具有性能问题的Linux服务器时，第一分钟要检查什么？</p>
<p>在Netflix，我们拥有庞大的Linux EC2云实例，以及大量的性能分析工具来监视和调查它们的性能。这些工具包括<code>Atlas</code>和<code>Vector</code>。<code>Atlas</code>用于全云监控，<code>Vector</code>用于按需实例分析。这些工具能帮助我们解决大部分问题，但有时候我们仍需登录实例并运行一些标准的Linux性能工具。</p>
<blockquote>
<p>Atlas：根据github上面的文档老许简单说一下自己的认知。一个可以管理基于时间维度数据的后端，同时具有内存存储功能可以非常快速地收集和报告大量指标。</p>
<p>Vector：Vector是一个主机上的性能监视框架，它可以将各种指标展示在工程师的浏览器上面。</p>
</blockquote>
<h3 id="总结">总结</h3>
<p>在这篇文章中，Netflix性能工程团队将向您展示通过命令行进行性能分析是，前60秒应该使用那些Linux标准工具。在60秒内，你可以通过以下10个命令来全面了解系统资源使用情况和正在运行的进程。首先寻找错误和饱和指标，因为他们很容易理解，然后是资源利用率。饱和是指资源负载超出其处理能力，其可以表现为一个请求队列的长度或者等待时间。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">uptime
dmesg | tail
vmstat <span style="color:#ae81ff">1</span>
mpstat -P ALL <span style="color:#ae81ff">1</span>
pidstat <span style="color:#ae81ff">1</span>
iostat -xz <span style="color:#ae81ff">1</span>
free -m
sar -n DEV <span style="color:#ae81ff">1</span>
sar -n TCP,ETCP <span style="color:#ae81ff">1</span>
top
</code></pre></div><p>其中一些命令需要安装sysstat软件包。这些命令暴露的指标是一种帮助你完成<code>USE Method（Utilization Saturation and Errors Method）</code>——一种查找性能瓶颈的方法。这涉及检查所有资源（CPU、内存、磁盘等）利用率，饱和度和错误等指标。同时还需注意通过排除法可以逐步缩小资源检查范围。</p>
<p>以下各节通过生产系统中的示例总结了这些命令。这些命令的更多信息，请参考使用手册。</p>
<h3 id="uptime">uptime</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ uptime 
23:51:26 up 21:31, <span style="color:#ae81ff">1</span> user, load average: 30.02, 26.43, 19.02
</code></pre></div><p>这是一种快速查看平均负载的方法，它指示了等待运行的进程数量。在Linux系统上，这些数字包括要在CPU上运行的进程以及处于I/O（通常是磁盘I/O）阻塞的进程。这提供了资源负载的大概状态，没有其他工具就无法理解更多。仅值得一看。</p>
<p>这三个数字分别代表着1分钟、5分钟和15分钟内的平均负载。这三个指标让我们了解负载是如何随时间变化的。例如，你被要求检查有问题的服务器，而1分钟的值远低于15分钟的值，则意味着你可能登录的太晚而错过了问题现场。</p>
<p>在上面的例子中，最近的平均负载增加，一分钟值达到30，而15分钟值达到19。数字如此之大意味着很多：可能是CPU需求（可以通过后文中介绍的vmstat或mpstat命令来确认）。</p>
<h3 id="dmesg--tail">dmesg | tail</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ dmesg | tail
<span style="color:#f92672">[</span>1880957.563150<span style="color:#f92672">]</span> perl invoked oom-killer: gfp_mask<span style="color:#f92672">=</span>0x280da, order<span style="color:#f92672">=</span>0, oom_score_adj<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
<span style="color:#f92672">[</span>1880957.563400<span style="color:#f92672">]</span> Out of memory: Kill process <span style="color:#ae81ff">18694</span> <span style="color:#f92672">(</span>perl<span style="color:#f92672">)</span> score <span style="color:#ae81ff">246</span> or sacrifice child
<span style="color:#f92672">[</span>1880957.563408<span style="color:#f92672">]</span> Killed process <span style="color:#ae81ff">18694</span> <span style="color:#f92672">(</span>perl<span style="color:#f92672">)</span> total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
<span style="color:#f92672">[</span>2320864.954447<span style="color:#f92672">]</span> TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.
</code></pre></div><p>如果有消息，它将查看最近的10条系统消息。通过此命令查找可能导致性能问题的错误。上面的示例包括<code>oom-killer</code>和TCP丢弃请求。</p>
<p>不要错过这一步！<code>dmesg</code>始终值得被检查。</p>
<h3 id="vmstat-1">vmstat 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ vmstat <span style="color:#ae81ff">1</span>
procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
<span style="color:#ae81ff">34</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889792</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591828</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">5</span>    <span style="color:#ae81ff">6</span>   <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">96</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">3</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889920</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">592</span> <span style="color:#ae81ff">13284</span> <span style="color:#ae81ff">4282</span> <span style="color:#ae81ff">98</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200890112</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">9501</span> <span style="color:#ae81ff">2154</span> <span style="color:#ae81ff">99</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889568</span>  <span style="color:#ae81ff">73712</span> <span style="color:#ae81ff">591856</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">11900</span> <span style="color:#ae81ff">2459</span> <span style="color:#ae81ff">99</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
<span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200890208</span>  <span style="color:#ae81ff">73712</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">15898</span> <span style="color:#ae81ff">4840</span> <span style="color:#ae81ff">98</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
^C
</code></pre></div><p>vmstat是虚拟内存状态的缩写。它在每一行上打印关键服务的统计信息。</p>
<p>vmstat在参数1下运行，以显示一秒钟的摘要。在某些版本中，第一行的某些列展示的是自启动以来的平均值，而不是前一秒的平均值。现在请跳过第一行，除非你想学习并记住那一列是那一列。</p>
<p>要检查的列：</p>
<ul>
<li><strong>r</strong>：在CPU上运行并等待切换的进程数。这为确定CPU饱和比平均负载提供了更好的信号，因为它不包括I/O。简单来说就是：r的值大于CPU数量即为饱和状态。</li>
<li><strong>free</strong>：可用内存以字节为单位，如果数字很大，则说明你有足够的可用内存。<code>free -m</code>命令能够更好的描述此状态。</li>
<li><strong>si, so</strong>：swap-ins和swap-outs. 如果这两个值不为0，则说明内存不足。</li>
<li><strong>us, sy, id, wa, st</strong>：这是总CPU时间的百分比。他们分别是用户时间、系统时间（内核）、空闲时间（包括I/O等待）、I/O等待和被盗时间（虚拟机所消耗的时间）。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB01cdb925877dcd06f2f969101decea65?method=download&amp;shareKey=5388ed636ef3cecb60d096cff7ad6615" alt=""></p>
<blockquote>
<p>最后关于us, sy, id, wa, st的解释和原文不太一样，所以老许贴一下vmstat手册中的解释。</p>
</blockquote>
<p>通过用户时间+系统时间来确认CPU是否繁忙。如果有持续的等待I/O，意味着磁盘瓶颈。这是CPU空闲的时候，因为任务等待I/O被阻塞。你可以将I/O等待视为CPU空闲的另一种形式，同时它也提供了CPU为什么空闲的线索。</p>
<p>I/O处理需要消耗系统时间。一个系统时间占比较高（比如超过20%）值得进一步研究，可能是内核处理I/O的效率低下。</p>
<p>在上面的例子中，CPU时间几乎完全处于用户级别，即CPU时间几乎被应用程序占用。CPU平均利用率也超过90%，这不一定是问题，还需要通过r列的值检查饱和度。</p>
<h3 id="mpstat--p-all-1">mpstat -P ALL 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ mpstat -P ALL <span style="color:#ae81ff">1</span>
Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015  _x86_64_ <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>

07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle
07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78
07:38:50 PM    <span style="color:#ae81ff">0</span>  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99
07:38:50 PM    <span style="color:#ae81ff">1</span>  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00
07:38:50 PM    <span style="color:#ae81ff">2</span>  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00
07:38:50 PM    <span style="color:#ae81ff">3</span>  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</code></pre></div><p>此命令用于显示每个CPU的CPU时间明细，可用于检查不平衡的情况。单个热CPU可能是因为存在一个单线程应用。</p>
<h3 id="pidstat-1">pidstat 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ pidstat <span style="color:#ae81ff">1</span>
Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015    _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>

07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:03 PM     <span style="color:#ae81ff">0</span>         <span style="color:#ae81ff">9</span>    0.00    0.94    0.00    0.94     <span style="color:#ae81ff">1</span>  rcuos/0
07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4214</span>    5.66    5.66    0.00   11.32    <span style="color:#ae81ff">15</span>  mesos-slave
07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4354</span>    0.94    0.94    0.00    1.89     <span style="color:#ae81ff">8</span>  java
07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6521</span> 1596.23    1.89    0.00 1598.11    <span style="color:#ae81ff">27</span>  java
07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6564</span> 1571.70    7.55    0.00 1579.25    <span style="color:#ae81ff">28</span>  java
07:41:03 PM <span style="color:#ae81ff">60004</span>     <span style="color:#ae81ff">60154</span>    0.94    4.72    0.00    5.66     <span style="color:#ae81ff">9</span>  pidstat

07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4214</span>    6.00    2.00    0.00    8.00    <span style="color:#ae81ff">15</span>  mesos-slave
07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6521</span> 1590.00    1.00    0.00 1591.00    <span style="color:#ae81ff">27</span>  java
07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6564</span> 1573.00   10.00    0.00 1583.00    <span style="color:#ae81ff">28</span>  java
07:41:04 PM   <span style="color:#ae81ff">108</span>      <span style="color:#ae81ff">6718</span>    1.00    0.00    0.00    1.00     <span style="color:#ae81ff">0</span>  snmp-pass
07:41:04 PM <span style="color:#ae81ff">60004</span>     <span style="color:#ae81ff">60154</span>    1.00    4.00    0.00    5.00     <span style="color:#ae81ff">9</span>  pidstat
^C
</code></pre></div><p><code>pidstat</code>有点像top的每个进程摘要，但是会打印滚动摘要，而不是清除屏幕。这对于观察随时间变化的模式很有用，还可以将看到的内容记录下来。</p>
<p>上面的示例中，两个java进程消耗了大部分CPU时间。%CPU这一列是所有CPU的总和。<code>1591%</code>意味着java进程几乎耗尽了16个CPU。</p>
<h3 id="iostat--xz-1">iostat -xz 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ iostat -xz <span style="color:#ae81ff">1</span>
Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015  _x86_64_ <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          73.96    0.00    3.73    0.03    0.06   22.21

Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09
xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25
xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26
dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04
dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00
dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03
<span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
^C
</code></pre></div><p>这是一个非常好的工具，不仅可以了解块设备（磁盘）的工作负载还可以了解其性能。</p>
<ul>
<li><strong>r/s, w/s, rkB/s, wkB/s</strong>：分别表示每秒交付给设备的读写请求数和每秒读写的KB数。这些可以描述设备的工作负载。性能问题可能仅仅是由于施加了过多的负载。</li>
<li><strong>await</strong>：I/O处理时间（毫秒为单位），这包括队列中请求所花费的时间以及为请求服务所花费的时间。如果值大于预期的平均时间，可能是因为设备已经饱和或设备出现问题。</li>
<li><strong>avgqu-sz</strong>：发送给设备请求的平均队列长度。该值大于1表明设备已达饱和状态（尽管设备通常可以并行处理请求，尤其是有多个后端磁盘的虚拟设备）。</li>
<li><strong>%util</strong>：设备利用率。这是一个显示设备是否忙碌的百分比，其含义为设备每秒的工作时间占比。该值大于60%时通常会导致性能不佳（可以在await中看出来），不过它也和具体的设备有关。值接近100%时，意味着设备已饱和。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd50303583de5aa29ab979335165035d3?method=download&amp;shareKey=12535f772898d9ce28dd23ebcc104686" alt=""></p>
<blockquote>
<p>关于avgqu-sz的解释和原文不太一样，所以老许贴一下iostat手册中的解释。</p>
</blockquote>
<p>如果存储设备是位于很多磁盘前面的逻辑磁盘设备，则100%利用率可能仅仅意味着所有时间都在处理I/O，但是后端磁盘可能远远还没有饱和，而且还能处理更多的工作。</p>
<p>请记住，磁盘I/O性能不佳不一定是应用程序的问题。通常使用许多技术来异步执行I/O，以保证应用程序不被阻塞或直接遭受延迟（例如，预读用于读取，缓冲用于写入）。</p>
<h3 id="free--m">free -m</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ free -m
             total       used       free     shared    buffers     cached
Mem:        <span style="color:#ae81ff">245998</span>      <span style="color:#ae81ff">24545</span>     <span style="color:#ae81ff">221453</span>         <span style="color:#ae81ff">83</span>         <span style="color:#ae81ff">59</span>        <span style="color:#ae81ff">541</span>
-/+ buffers/cache:      <span style="color:#ae81ff">23944</span>     <span style="color:#ae81ff">222053</span>
Swap:            <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>
</code></pre></div><p>看最右边两列：</p>
<ul>
<li><strong>buffers</strong>：缓冲区缓存，用于块设备I/O。</li>
<li><strong>cached</strong>：页缓存，用于文件系统。</li>
</ul>
<p>我们检查他们的值是否接近0，接近0会导致更高的磁盘I/O（可以通过iostat来确认）以及更糟糕的磁盘性能。上面的示例看起来不错，每个值都有许多兆字节。</p>
<p><code>-/+ buffers/cache</code>为已用内存和可用内存提供更加清晰的描述。Linux将部分空闲内存用作缓存，但是在应用程序需要时可以快速回收。因此，用作缓存的内存应该应该以某种方式包含在free这一列，<code>-/+ buffers/cache</code>这一行就是做这个事情的。</p>
<blockquote>
<p>上面这一段翻译，可能比较抽象，感觉说的不像人话，老许来转述成人能理解的话：</p>
<p>total = used + free</p>
<p>used = (-/+ buffers/cache这一行used对应列) + buffers + cached</p>
<p>=&gt; 24545 = 23944 + 59 + 541</p>
<p>free = (-/+ buffers/cache这一行free对应列) - buffers - cached</p>
<p>=&gt; 221453 = 222053 - 59 - 541</p>
</blockquote>
<p>如果在Linux使用了ZFS会令人更加疑惑（就像我们对某些服务所做的一样），因为ZFS有自己的文件系统缓存。而<code>free -m</code>并不能正确反应该文件系统缓存。它可能表现为，系统可用内存不足，而实际上该内存可根据需要从ZFS缓存中使用。</p>
<blockquote>
<p>ZFS: Zettabyte File System,也叫动态文件系统，更多信息见百度百科</p>
</blockquote>
<h3 id="sar--n-dev-1">sar -n DEV 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sar -n DEV <span style="color:#ae81ff">1</span>
Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015     _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>

12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
^C
</code></pre></div><p>可以用这个工具检查网络接口的吞吐量： rxkB/s和txkB/s。作为工作负载的度量，还可以检查吞吐量是否达到上限。在上面的列子中，eth0的接受速度达到22Mbyte/s（176Mbit/s），该值远低于1Gbit/s的限制。</p>
<blockquote>
<p>原文中无rxkB/s和txkB/s的解释，老许特意找了使用手册中的说明。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc64cc99088cee47bede3119305116a7c?method=download&amp;shareKey=238ac957dd1380595eb90706cfb9c157" alt=""></p>
<p>这个版本还有%ifutil作设备利用率，这也是我们使用Brendan的nicstat工具来测量的。和nicstat工具一样，这很难正确，而且本例中看起来该值并不起作用。</p>
<blockquote>
<p>老许试了一下自己的云服务发现%ifutil指标并不一定都有。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46426284a4f97e9d965dc6c74b3045c0?method=download&amp;shareKey=341078089ef7ed5608f35d1bef2f516a" alt=""></p>
<h3 id="sar--n-tcpetcp-1">sar -n TCP,ETCP 1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ sar -n TCP,ETCP <span style="color:#ae81ff">1</span>
Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015    _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>

12:17:19 AM  active/s passive/s    iseg/s    oseg/s
12:17:20 AM      1.00      0.00  10233.00  18846.00

12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:20 AM      0.00      0.00      0.00      0.00      0.00

12:17:20 AM  active/s passive/s    iseg/s    oseg/s
12:17:21 AM      1.00      0.00   8359.00   6039.00

12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
12:17:21 AM      0.00      0.00      0.00      0.00      0.00
^C
</code></pre></div><p>这是一些关键TCP指标的总结。其中包括：</p>
<ul>
<li><strong>active/s</strong>：本地每秒启动的TCP连接数（例如，通过connect()）。</li>
<li><strong>passive/s</strong>：远程每秒启动的TCP连接数（例如，通过accept()）</li>
<li><strong>retrans/s</strong>：TCP每秒重传次数。</li>
</ul>
<p>active和passive连接数通常用于服务器负载的粗略度量。将active视为向外的连接，passive视为向内的连接可能会有帮助，但这样区分并不严格（例如，localhost连接到localhost）。</p>
<p>重传是网络或服务器出问题的迹象。它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例显示每秒仅一个新的TCP连接。</p>
<h3 id="top">top</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ top
top - 00:15:40 up 21:56,  <span style="color:#ae81ff">1</span> user,  load average: 31.09, 29.87, 29.92
Tasks: <span style="color:#ae81ff">871</span> total,   <span style="color:#ae81ff">1</span> running, <span style="color:#ae81ff">868</span> sleeping,   <span style="color:#ae81ff">0</span> stopped,   <span style="color:#ae81ff">2</span> zombie
%Cpu<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>: 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:  25190241+total, <span style="color:#ae81ff">24921688</span> used, 22698073+free,    <span style="color:#ae81ff">60448</span> buffers
KiB Swap:        <span style="color:#ae81ff">0</span> total,        <span style="color:#ae81ff">0</span> used,        <span style="color:#ae81ff">0</span> free.   <span style="color:#ae81ff">554208</span> cached Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 <span style="color:#ae81ff">20248</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>  0.227t 0.012t  <span style="color:#ae81ff">18748</span> S  <span style="color:#ae81ff">3090</span>  5.2  29812:58 java
  <span style="color:#ae81ff">4213</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2722544</span>  <span style="color:#ae81ff">64640</span>  <span style="color:#ae81ff">44232</span> S  23.5  0.0 233:35.37 mesos-slave
 <span style="color:#ae81ff">66128</span> titancl+  <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">24344</span>   <span style="color:#ae81ff">2332</span>   <span style="color:#ae81ff">1172</span> R   1.0  0.0   0:00.07 top
  <span style="color:#ae81ff">5235</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> 38.227g <span style="color:#ae81ff">547004</span>  <span style="color:#ae81ff">49996</span> S   0.7  0.2   2:02.74 java
  <span style="color:#ae81ff">4299</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> 20.015g 2.682g  <span style="color:#ae81ff">16836</span> S   0.3  1.1  33:14.42 java
     <span style="color:#ae81ff">1</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">33620</span>   <span style="color:#ae81ff">2920</span>   <span style="color:#ae81ff">1496</span> S   0.0  0.0   0:03.82 init
     <span style="color:#ae81ff">2</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:00.02 kthreadd
     <span style="color:#ae81ff">3</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:05.35 ksoftirqd/0
     <span style="color:#ae81ff">5</span> root       <span style="color:#ae81ff">0</span> -20       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:00.00 kworker/0:0H
     <span style="color:#ae81ff">6</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:06.94 kworker/u256:0
     <span style="color:#ae81ff">8</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   2:38.05 rcu_sched
</code></pre></div><p>top命令包含我们之前检查的许多指标。运行它可以很方便地查看是否有任何东西和之前的命令结果差别很大。</p>
<p>top的缺点是随着时间推移不能看到相关变化，像vmstat和pidstat之类提供滚动输出的工具则能体现的更加清楚。如果你没有足够快地暂停输出（Ctrl-S暂停, Ctrl-Q继续），随着屏幕的清除间歇性问题的证据很有可能丢失。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<p>翻译原文</p>
<p><a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55">https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>Go中的SSRF攻防战</title>
            <link>https://isites.gitlab.io/isites/timeline/go-ssrf/</link>
            <pubDate>Tue, 19 Jan 2021 20:30:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/go-ssrf/</guid>
            <description>写在最前面 “年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。
关于自称，老许就不扯太远了，下面还是回到本篇的主旨。
什么是SSRF SSRF英文全拼为Server Side Request Forgery，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。
上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。
“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。
回合一：千变万化的内网地址 为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用182.61.200.7（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。
   格式 值 描述     点分十进制 182.61.200.7 常规表现方式   点分八进制 0266.075.0310.07 每个字节被单独转换为八进制   点分十六进制 0xb6.0x3d.0xc8.0x7 每个字节被单独转换为十六进制   十进制 3057502215 用十进制写出的32位整数   八进制 026617344007 用八进制写出32位整数   十六进制 0xb63dc807 用十六进制写出32位整数   点分混合制（4） 182.0x3d.0310.7等 点分格式中，每个字节都可用任意的进制表达   点分混合制（3） 182.0x3d.0144007等 将后面16位用八进制表示   点分混合制（2） 182.4048903等 将后面24为用10进制表示    注意⚠️：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。
上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址0:0:0:0:0:0:0:1为例。</description>
            <content type="html"><![CDATA[<h3 id="写在最前面">写在最前面</h3>
<p>“年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。</p>
<p>关于自称，老许就不扯太远了，下面还是回到本篇的主旨。</p>
<h3 id="什么是ssrf">什么是SSRF</h3>
<p>SSRF英文全拼为<code>Server Side Request Forgery</code>，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5e3f093a7664785b0c96e4d4a4fdd095?method=download&amp;shareKey=30bddd4078d8dbe0f8bd62c34814ad94" alt=""></p>
<p>上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。</p>
<p>“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。</p>
<h3 id="回合一千变万化的内网地址">回合一：千变万化的内网地址</h3>
<p>为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用<code>182.61.200.7</code>（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">点分十进制</td>
<td style="text-align:left">182.61.200.7</td>
<td style="text-align:left">常规表现方式</td>
</tr>
<tr>
<td style="text-align:left">点分八进制</td>
<td style="text-align:left">0266.075.0310.07</td>
<td style="text-align:left">每个字节被单独转换为八进制</td>
</tr>
<tr>
<td style="text-align:left">点分十六进制</td>
<td style="text-align:left">0xb6.0x3d.0xc8.0x7</td>
<td style="text-align:left">每个字节被单独转换为十六进制</td>
</tr>
<tr>
<td style="text-align:left">十进制</td>
<td style="text-align:left">3057502215</td>
<td style="text-align:left">用十进制写出的32位整数</td>
</tr>
<tr>
<td style="text-align:left">八进制</td>
<td style="text-align:left">026617344007</td>
<td style="text-align:left">用八进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">0xb63dc807</td>
<td style="text-align:left">用十六进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（4）</td>
<td style="text-align:left">182.0x3d.0310.7等</td>
<td style="text-align:left">点分格式中，每个字节都可用任意的进制表达</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（3）</td>
<td style="text-align:left">182.0x3d.0144007等</td>
<td style="text-align:left">将后面16位用八进制表示</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（2）</td>
<td style="text-align:left">182.4048903等</td>
<td style="text-align:left">将后面24为用10进制表示</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。</p>
<p>上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址<code>0:0:0:0:0:0:0:1</code>为例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒分十六进制表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0:1</td>
<td style="text-align:left">格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，每个X的前导0是可以省略</td>
</tr>
<tr>
<td style="text-align:left">0位压缩表示法</td>
<td style="text-align:left">::1</td>
<td style="text-align:left">连续的一段0可以压缩为“::”，但”::”只能出现一次</td>
</tr>
<tr>
<td style="text-align:left">内嵌IPv4地址表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0.0.0.1</td>
<td style="text-align:left">X:X:X:X:X:X:d.d.d.d（前96b使用冒分十六进制，最后32b地址则使用IPv4的点分十进制表示）</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：冒分十六进制表示法中每个X的前导0是可以省略的，那么我可以部分省略，部分不省略，从而将一个IPv6地址写出不同的表现形式。0位压缩表示法和内嵌IPv4地址表示法同理也可以将一个IPv6地址写出不同的表现形式。</p>
<p>讲了这么多，老许已经无法统计一个IP可以有多少种不同的写法，麻烦数学好的算一下。</p>
<p>内网IP你以为到这儿就完了嘛？当然不！不知道各位读者有没有听过<code>xip.io</code>这个域名。<code>xip</code>可以帮你做自定义的DNS解析，并且可以解析到任意IP地址（包括内网）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB85b07b5da343c8b1be8be6bdd19869f5?method=download&amp;shareKey=a3ffcab0e1c03fbfa6383c5d736f3ea4" alt=""></p>
<p>我们通过<code>xip</code>提供的域名解析，还可以将内网IP通过域名的方式进行访问。</p>
<p>关于内网IP的访问到这儿仍将继续！搞过Basic验证的应该都知道，可以通过<code>http://user:passwd@hostname/</code>进行资源访问。如果攻击者换一种写法或许可以绕过部分不够严谨的逻辑，如下所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBac6328b4d92be511501ea6d4d2a7042d?method=download&amp;shareKey=86a8308849c419d602d621b2bab1c93d" alt=""></p>
<p>关于内网地址，老许掏空了所有的知识储备总结出上述内容，因此老许说一句千变万化的内网地址不过分吧！</p>
<p>此时此刻，老许只想问一句，当恶意攻击者用这些不同表现形式的内网地址进行图片上传时，你怎么将其识别出来并拒绝访问。不会真的有大佬用正则表达式完成上述过滤吧，如果有请留言告诉我让小弟学习一下。</p>
<p>花样百出的内网地址我们已经基本了解，那么现在的问题是怎么将其转为一个我们可以进行判断的IP。总结上面的内网地址可分为三类：一、本身就是IP地址，仅表现形式不统一；二、一个指向内网IP的域名；三、一个包含Basic验证信息和内网IP的地址。根据这三类特征，在发起请求之前按照如下步骤可以识别内网地址并拒绝访问。</p>
<ol>
<li>解析出地址中的HostName。</li>
<li>发起DNS解析，获得IP。</li>
<li>判断IP是否是内网地址。</li>
</ol>
<p>上述步骤中关于内网地址的判断，请不要忽略IPv6的回环地址和IPv6的唯一本地地址。下面是老许判断IP是否为内网IP的逻辑。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// IsLocalIP 判断是否是内网ip
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>) <span style="color:#66d9ef">bool</span> {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
	}
	<span style="color:#75715e">// 判断是否是回环地址, ipv4时是127.0.0.1；ipv6时是::1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">IsLoopback</span>() {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
	}
	<span style="color:#75715e">// 判断ipv4是否是内网
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To4</span>(); <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">||</span> <span style="color:#75715e">// 10.0.0.0/8
</span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">172</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">16</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">31</span>) <span style="color:#f92672">||</span> <span style="color:#75715e">// 172.16.0.0/12
</span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">192</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">168</span>) <span style="color:#75715e">// 192.168.0.0/16
</span><span style="color:#75715e"></span>	}
	<span style="color:#75715e">// 判断ipv6是否是内网
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To16</span>(); <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// 参考 https://tools.ietf.org/html/rfc4193#section-3
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 参考 https://en.wikipedia.org/wiki/Private_network#Private_IPv6_addresses
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 判断ipv6唯一本地地址
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xfd</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ip16</span>[<span style="color:#ae81ff">0</span>]
	}
	<span style="color:#75715e">// 不是ip直接返回false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
}

</code></pre></div><p>下图为按照上述步骤检测请求是否是内网请求的结果。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB733788caa1f3e7307a0eb6eaf237db5e?method=download&amp;shareKey=5df8b437bde3f8a6b40eb03f66e15d57" alt=""></p>
<p><strong>小结</strong>：URL形式多样，可以使用DNS解析获取规范的IP，从而判断是否是内网资源。</p>
<h3 id="回合二url跳转">回合二：URL跳转</h3>
<p>如果恶意攻击者仅通过IP的不同写法进行攻击，那我们自然可以高枕无忧，然而这场矛与盾的较量才刚刚开局。</p>
<p>我们回顾一下回合一的防御策略，检测请求是否是内网资源是在正式发起请求之前，如果攻击者在请求过程中通过URL跳转进行内网资源访问则完全可以绕过回合一中的防御策略。具体攻击流程如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe9de4e2a016b1d1f9b0d2dfa09ba7811?method=download&amp;shareKey=65a87ed928726fc6c7fc34d362b1824d" alt=""></p>
<p>如图所示，通过URL跳转攻击者可获得内网资源。在介绍如何防御URL跳转攻击之前，老许和各位读者先一起复习一下HTTP重定向状态码——3xx。</p>
<p>根据维基百科的资料，3xx重定向码范围从300到308共9个。老许特意瞧了一眼go的源码，发现官方的<code>http.Client</code>发出的请求仅支持如下几个重定向码。</p>
<p><code>301</code>：请求的资源已永久移动到新位置；该响应可缓存；重定向请求一定是GET请求。</p>
<p><code>302</code>：要求客户端执行临时重定向；只有在Cache-Control或Expires中进行指定的情况下，这个响应才是可缓存的；重定向请求一定是GET请求。</p>
<p><code>303</code>：当POST（或PUT / DELETE）请求的响应在另一个URI能被找到时可用此code，这个code存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源；303响应禁止被缓存；重定向请求一定是GET请求。</p>
<p><code>307</code>：临时重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p><code>308</code>：永久重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p>3xx状态码复习就到这里，我们继续SSRF的攻防回合讨论。既然服务端的URL跳转可能带来风险，那我们只要禁用URL跳转就完全可以规避此类风险。然而我们并不能这么做，这个做法在规避风险的同时也极有可能误伤正常的请求。那到底该如何防范此类攻击手段呢？</p>
<p>看过老许“<a href="https://mp.weixin.qq.com/s/6WYhwaRrjv6W6NZCNw2CeA">Go中的HTTP请求之——HTTP1.1请求流程分析</a>”这篇文章的读者应该知道，对于重定向有业务需求时，可以自定义http.Client的<code>CheckRedirect</code>。下面我们先看一下<code>CheckRedirect</code>的定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">CheckRedirect</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span>
</code></pre></div><p>这里特别说明一下，<code>req</code>是即将发出的请求且请求中包含前一次请求的响应，<code>via</code>是已经发出的请求。在知晓这些条件后，防御URL跳转攻击就变得十分容易了。</p>
<ol>
<li>根据前一次请求的响应直接拒绝<code>307</code>和<code>308</code>的跳转（此类跳转可以是POST请求，风险极高）。</li>
<li>解析出请求的IP，并判断是否是内网IP。</li>
</ol>
<p>根据上述步骤，可如下定义<code>http.Client</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">CheckRedirect</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span> {
		<span style="color:#75715e">// 跳转超过10次，也拒绝继续跳转
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">via</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;redirect too much&#34;</span>)
		}
		<span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Response</span>.<span style="color:#a6e22e">StatusCode</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">307</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">308</span> {
			<span style="color:#75715e">// 拒绝跳转访问
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unsupport redirect method&#34;</span>)
		}
		<span style="color:#75715e">// 判断ip
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Host</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
		}
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;have local ip&#34;</span>)
			}
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s -&gt; %s is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
		}
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
	},
}
</code></pre></div><p>如上自定义CheckRedirect可以防范URL跳转攻击，但此方式会进行多次DNS解析，效率不佳。后文会结合其他攻击方式介绍更加有效率的防御措施。</p>
<p><strong>小结</strong>：通过自定义<code>http.Client</code>的<code>CheckRedirect</code>可以防范URL跳转攻击。</p>
<h3 id="回合三dns-rebinding">回合三：DNS Rebinding</h3>
<p>众所周知，发起一次HTTP请求需要先请求DNS服务获取域名对应的IP地址。如果攻击者有可控的DNS服务，就可以通过DNS重绑定绕过前面的防御策略进行攻击。</p>
<p>具体流程如下图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa90ecbaeb18110063a5e91d1704f4c8a?method=download&amp;shareKey=fc64d48577f5e66e69ea10616cd28344" alt=""></p>
<p>验证资源是是否合法时，服务器进行了第一次DNS解析，获得了一个非内网的IP且TTL为0。对解析的IP进行判断，发现非内网IP可以后续请求。由于攻击者的DNS Server将TTL设置为0，所以正式发起请求时需要再次进行DNS解析。此时DNS Server返回内网地址，由于已经进入请求资源阶段再无防御措施，所以攻击者可获得内网资源。</p>
<blockquote>
<p>额外提一嘴，老许特意看了Go中DNS解析的部分源码，发现Go并没有对DNS的结果作缓存，所以即使TTL不为0也存在DNS重绑定的风险。</p>
</blockquote>
<p>在发起请求的过程中有DNS解析才让攻击者有机可乘。如果我们能对该过程进行控制，就可以避免DNS重绑定的风险。对HTTP请求控制可以通过自定义<code>http.Transport</code>来实现，而自定义<code>http.Transport</code>也有两个方案。</p>
<p><strong>方案一</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
<span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
<span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">addr</span>)
	<span style="color:#75715e">// 解析host和 端口
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#75715e">// dns解析域名
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">host</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#75715e">// 对所有的ip串行发起请求
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v -&gt; %v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#75715e">// 非内网IP可继续访问
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 拼接地址
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">JoinHostPort</span>(<span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">port</span>)
		<span style="color:#75715e">// 此时的addr仅包含IP和端口信息
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">con</span>, <span style="color:#66d9ef">nil</span>
		}
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
	}

	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;connect failed&#34;</span>)
}
<span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
}
</code></pre></div><p><code>transport.DialContext</code>的作用是创建未加密的TCP连接，我们通过自定义此函数可规避DNS重绑定风险。另外特别说明一下，如果传递给<code>dialer.DialContext</code>方法的地址是常规IP格式则可使用net包中的<code>parseIPZone</code>函数直接解析成功，否则会继续发起DNS解析请求。</p>
<p><strong>方案二</strong>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
<span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">Control</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">address</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">RawConn</span>) <span style="color:#66d9ef">error</span> {
    <span style="color:#75715e">// address 已经是ip:port的格式
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">address</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseIP</span>(<span style="color:#a6e22e">host</span>)))
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
<span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
<span style="color:#75715e">// 使用官方库的实现创建TCP连接
</span><span style="color:#75715e"></span><span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>
<span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
}
</code></pre></div><p><code>dialer.Control</code>在创建网络连接之后实际拨号之前调用，且仅在go版本大于等于1.11时可用，其具体调用位置在<code>sock_posix.go</code>中的<code>(*netFD).dial</code>方法里。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB149c44c0f615142a792ed61dc8ef81d2?method=download&amp;shareKey=a215bcf6853fe43b9a3d1f6b74a8fb3a" alt=""></p>
<p>上述两个防御方案不仅仅可以防范DNS重绑定攻击，也同样可以防范其他攻击方式。事实上，老许更加推荐方案二，简直一劳永逸！</p>
<p><strong>小结</strong>：</p>
<ol>
<li>攻击者可以通过自己的DNS服务进行DNS重绑定攻击。</li>
<li>通过自定义<code>http.Transport</code>可以防范DNS重绑定攻击。</li>
</ol>
<h3 id="个人经验">个人经验</h3>
<p>1、不要下发详细的错误信息！不要下发详细的错误信息！不要下发详细的错误信息！</p>
<p>如果是为了开发调试，请将错误信息打进日志文件里。强调这一点不仅仅是为了防范SSRF攻击，更是为了避免敏感信息泄漏。例如，DB操作失败后直接将error信息下发，而这个error信息很有可能包含SQL语句。</p>
<blockquote>
<p>再额外多说一嘴，老许的公司对打进日志文件的某些信息还要求脱敏，可谓是十分严格了。</p>
</blockquote>
<p>2、限制请求端口。</p>
<p>在结束之前特别说明一下，SSRF漏洞并不只针对HTTP协议。本篇只讨论HTTP协议是因为go中通过<code>http.Client</code>发起请求时会检测协议类型，某P*P语言这方面检测就会弱很多。虽然<code>http.Client</code>会检测协议类型，但是攻击者仍然可以通过漏洞不断更换端口进行内网端口探测。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/ssrf/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>2020总结：稍微努力了一下，依旧是咸鱼一条</title>
            <link>https://isites.gitlab.io/isites/timeline/2020summary/</link>
            <pubDate>Thu, 31 Dec 2020 00:12:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/2020summary/</guid>
            <description>2020最深刻的印记是新冠疫情，于笔者最深刻的印记是在这一年下定决心做了一些新的尝试。既然有了新的尝试，笔者也就随大流来一发年终总结。
关于“新世界杂货铺”这个名字 2020的年终总结，最想谈的就是新世界杂货铺这个名字。为什么想先谈名字呢？因为笔者最近正在思考要不要换个名字，毕竟这个名字和公众号的内容实在没什么直接联系。笔者一度怀疑就是因为这个名字才导致笔者的粉丝增长缓慢。
先说一说为什么叫这个名字吧。专注于技术分享但是又不止于技术分享故谓之“杂货铺”，比如笔者曾经深夜偷偷发了一篇“7年，爷青结，感谢春物的陪伴！”这样的文章，以后只会更多！对笔者而言，做公众号是一次崭新的尝试所以最终才取名为“新世界杂货铺”。名字的由来差不多就是这样，至于明年要不要换个名字，笔者还在犹豫，姑且走一步看一步吧。
关于分享 毫无疑问，2020年的上半年算是废了，到下半年笔者才下定决心做出改变。而改变的第一步，笔者选择了百家号。
2020年7月5日，正式在百家号发布笔者的第一篇原创文章。在百家号发表几篇文章后，笔者差点丧失继续创作的动力（因为某些原因，笔者就不描述过多细节了）。直到2020年8月，笔者将主要创作平台移至公众号、简书和掘金等平台，才有了继续下去的动力。
说实话，持续原创输出十分不易，特别是冬天到了笔者就更加懒了，笔者坚持码下的每一个字对笔者而言都是自我挑战成功的硕果。截止目前，笔者已在公众号发布21篇原创，创作不易，但是笔者仍然想坚持下去，只为心中不迷茫！
关于粉丝 自己写的文章有几斤几两笔者还是比较清楚，所以对于粉丝数量十分佛系。
毕竟粉丝少，只能这样安慰自己，要不然为什么想换名字呢？果然，男人的嘴骗人的鬼！
粉丝数量能拿出手的就只有简书，截止目前已有5k+的粉丝量。
据笔者观察，这5k的粉丝几乎都是僵尸粉，估摸着是为了增加我在简书创作的动力才将我推送给新注册的用户。不管怎么样，这个粉丝量还是令笔者很舒心。这暗示已经非常明显了！
健康和体重 就健康而言笔者还是有些感触。去年年末，因为肾结石去了趟医院。每每回忆起当时的情形都令笔者十分后悔，后悔自己为什么不多喝水，为什么一直坐着，为什么不多运动！在此，特意提醒各位读者一定要多运动多喝水，少坐！
鉴于笔者曾经遭受了非人的折磨，所以从2020年初开始就坚持做俯卧撑，并买了站立办公椅。比较遗憾的是笔者从11月才开始记录俯卧撑的数量，截止到12月底两个月共完成2085个俯卧撑。
健康是一方面，另一方面笔者也希望自己能够跨入瘦子的行列。笔者还特意为自己设定了一个奖励，只要体重减到130就奖励自己一副贵一点的眼镜。然而都已经到年底了，这个目标还遥遥无期，果然每一个胖子都非一日之功。
看过的书 又到了晒书的时间，以下是笔者今年已经读完的书。
万万没想到笔者这种不常看书的人一年时间也能读完4本，由此可见不积跬步，无以至千里，古人诚不欺我。
这四本书中，笔者最喜欢第二本。该书全名为《好好吃饭：无须自控力，三观最正的瘦身指南》，只看书名相信各位读者就应该明白笔者为什么喜欢这本书了。对了，笔者一般都使用微信读书，欢迎各位道友加好友一起交流。
春暖花开，面朝2021 每一篇年终总结的最后都会立一些Flag，本篇亦不例外。
Flag1：一定要保持一个健康的身体，最好是能瘦下来，毕竟笔者的眼镜确实该换了。
Flag2：持续学习输出，粉丝也能持续增长就更好了。
鉴于笔者对自己有一个较为全面的认知，所以Flag就不立多了，多了也只是自己骗自己。
最后一口毒鸡汤 细细想来，2020于我来说和大部分人一样，稍微努力了一下，然而依旧是条咸鱼。工作没有什么变化，生活没有什么变化，经济状况还是没有什么变化。这是最好的结果，也是最坏的结果，或许有些时候真的要豁出去才能打破常规。
不矫情了，笔者最后祝愿所有人在新的一年里平淡且美好！
【关注公众号】</description>
            <content type="html"><![CDATA[<p>2020最深刻的印记是新冠疫情，于笔者最深刻的印记是在这一年下定决心做了一些新的尝试。既然有了新的尝试，笔者也就随大流来一发年终总结。</p>
<h3 id="关于新世界杂货铺这个名字">关于“新世界杂货铺”这个名字</h3>
<p>2020的年终总结，最想谈的就是<code>新世界杂货铺</code>这个名字。为什么想先谈名字呢？因为笔者最近正在思考要不要换个名字，毕竟这个名字和公众号的内容实在没什么直接联系。笔者一度怀疑就是因为这个名字才导致笔者的粉丝增长缓慢。</p>
<p>先说一说为什么叫这个名字吧。专注于技术分享但是又不止于技术分享故谓之“杂货铺”，比如笔者曾经深夜偷偷发了一篇“<a href="https://mp.weixin.qq.com/s/nHN4zaLjNUCIq7XqMkrb3Q">7年，爷青结，感谢春物的陪伴！</a>”这样的文章，以后只会更多！对笔者而言，做公众号是一次崭新的尝试所以最终才取名为“新世界杂货铺”。名字的由来差不多就是这样，至于明年要不要换个名字，笔者还在犹豫，姑且走一步看一步吧。</p>
<h3 id="关于分享">关于分享</h3>
<p>毫无疑问，2020年的上半年算是废了，到下半年笔者才下定决心做出改变。而改变的第一步，笔者选择了百家号。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7dea7d9d63718d8d1f23eb738d35821e?method=download&amp;shareKey=bd1e7324298f2050b3764c9c7b18e1c4" alt=""></p>
<p>2020年7月5日，正式在百家号发布笔者的第一篇原创文章。在百家号发表几篇文章后，笔者差点丧失继续创作的动力（因为某些原因，笔者就不描述过多细节了）。直到2020年8月，笔者将主要创作平台移至公众号、简书和掘金等平台，才有了继续下去的动力。</p>
<p>说实话，持续原创输出十分不易，特别是冬天到了笔者就更加懒了，笔者坚持码下的每一个字对笔者而言都是自我挑战成功的硕果。截止目前，笔者已在公众号发布21篇原创，创作不易，但是笔者仍然想坚持下去，只为心中不迷茫！</p>
<h3 id="关于粉丝">关于粉丝</h3>
<p>自己写的文章有几斤几两笔者还是比较清楚，所以对于粉丝数量十分佛系。</p>
<p>毕竟粉丝少，只能这样安慰自己，要不然为什么想换名字呢？果然，男人的嘴骗人的鬼！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6bef7dddedd0bca2761c87fa92865aa?method=download&amp;shareKey=76fedee423af1eb973500c00b4837220" alt=""></p>
<p>粉丝数量能拿出手的就只有简书，截止目前已有5k+的粉丝量。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb9d7faf93d4e2ac2fa7dac8b37bda850?method=download&amp;shareKey=cfbfa3096956d2d18278df93f1390533" alt=""></p>
<p>据笔者观察，这5k的粉丝几乎都是僵尸粉，估摸着是为了增加我在简书创作的动力才将我推送给新注册的用户。不管怎么样，这个粉丝量还是令笔者很舒心。这暗示已经非常明显了！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB542290a0e3155af40b2f43c0818ba03b?method=download&amp;shareKey=2d7880e21d51a5318fb284e8ac3a35ed" alt=""></p>
<h3 id="健康和体重">健康和体重</h3>
<p>就健康而言笔者还是有些感触。去年年末，因为肾结石去了趟医院。每每回忆起当时的情形都令笔者十分后悔，后悔自己为什么不多喝水，为什么一直坐着，为什么不多运动！在此，特意提醒各位读者一定要多运动多喝水，少坐！</p>
<p>鉴于笔者曾经遭受了非人的折磨，所以从2020年初开始就坚持做俯卧撑，并买了站立办公椅。比较遗憾的是笔者从11月才开始记录俯卧撑的数量，截止到12月底两个月共完成<strong>2085</strong>个俯卧撑。</p>
<p>健康是一方面，另一方面笔者也希望自己能够跨入瘦子的行列。笔者还特意为自己设定了一个奖励，只要体重减到130就奖励自己一副贵一点的眼镜。然而都已经到年底了，这个目标还遥遥无期，果然每一个胖子都非一日之功。</p>
<h3 id="看过的书">看过的书</h3>
<p>又到了晒书的时间，以下是笔者今年已经读完的书。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB39c851807ac2fc74a926e123dbefa078?method=download&amp;shareKey=cc248d8560deeedb67243a55efcf7a35" alt=""></p>
<p>万万没想到笔者这种不常看书的人一年时间也能读完4本，由此可见不积跬步，无以至千里，古人诚不欺我。</p>
<p>这四本书中，笔者最喜欢第二本。该书全名为《好好吃饭：无须自控力，三观最正的瘦身指南》，只看书名相信各位读者就应该明白笔者为什么喜欢这本书了。对了，笔者一般都使用微信读书，欢迎各位道友加好友一起交流。</p>
<h3 id="春暖花开面朝2021">春暖花开，面朝2021</h3>
<p>每一篇年终总结的最后都会立一些Flag，本篇亦不例外。</p>
<p>Flag1：一定要保持一个健康的身体，最好是能瘦下来，毕竟笔者的眼镜确实该换了。</p>
<p>Flag2：持续学习输出，粉丝也能持续增长就更好了。</p>
<p>鉴于笔者对自己有一个较为全面的认知，所以Flag就不立多了，多了也只是自己骗自己。</p>
<h3 id="最后一口毒鸡汤">最后一口毒鸡汤</h3>
<p>细细想来，2020于我来说和大部分人一样，稍微努力了一下，然而依旧是条咸鱼。工作没有什么变化，生活没有什么变化，经济状况还是没有什么变化。这是最好的结果，也是最坏的结果，或许有些时候真的要豁出去才能打破常规。</p>
<p>不矫情了，笔者最后祝愿所有人在新的一年里平淡且美好！</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>码了2000多行代码就是为了讲清楚TLS握手流程（续）</title>
            <link>https://isites.gitlab.io/isites/timeline/gotls1.2/</link>
            <pubDate>Sun, 13 Dec 2020 23:47:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/gotls1.2/</guid>
            <description>在“码了2000多行代码就是为了讲清楚TLS握手流程”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。
在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。
结论先行 为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。
单向认证 单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。
下面是笔者运行Demo打印的调试信息：
根据调试信息知，TLS1.2单向认证中总共收发数据四次，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。
笔者将调试信息转换为下述时序图，以方便各位读者理解。
双向认证 双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。
下面是笔者运行Demo打印的调试信息：
同单向认证一样，笔者将调试信息转换为下述时序图。
双向认证和单向认证相比，Server发消息给Client时会额外发送一个certificateRequestMsg消息，Client收到此消息后会将证书信息（certificateMsg）和签名信息（certificateVerifyMsg）发送给Server。
双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有四次。
总结 1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。
2、TLS1.2中除了finishedMsg其余消息均未加密。
3、在TLS1.2中，ChangeCipherSpec消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。
和TLS1.3的比较 消息格式的变化 对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是certificateMsg和certificateMsgTLS13的定义：
// TLS1.2 type certificateMsg struct { raw []byte certificates [][]byte } // TLS1.3 type certificateMsgTLS13 struct { raw []byte certificate tls.Certificate ocspStapling bool scts bool } 其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。
   TLS1.2 TLS1.3     certificateRequestMsg certificateRequestMsgTLS13   certificateMsg certificateMsgTLS13    消息类型的变化 TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：
   TLS1.</description>
            <content type="html"><![CDATA[<p>在“<a href="https://mp.weixin.qq.com/s/ALmouugbrCHrNbyk3OTtSQ">码了2000多行代码就是为了讲清楚TLS握手流程</a>”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。</p>
<p>在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。</p>
<h3 id="结论先行">结论先行</h3>
<p>为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。</p>
<h4 id="单向认证">单向认证</h4>
<p>单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7b4e407a4d300561e2889311bff03b7f?method=download&amp;shareKey=df9641649e598375a3c8bc5baaa93fe9" alt=""></p>
<p>根据调试信息知，TLS1.2单向认证中总共收发数据<strong>四次</strong>，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。</p>
<p>笔者将调试信息转换为下述时序图，以方便各位读者理解。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8229b8e38739b1e3cbe114c158d8a98?method=download&amp;shareKey=1a4a0f4fe5bd9d2b9e6406b4575fe312" alt=""></p>
<h4 id="双向认证">双向认证</h4>
<p>双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB87df88f5543af04290af0c21dca8c17a?method=download&amp;shareKey=2fec2f1d33ffb7dd40c0b47a19c6eb83" alt=""></p>
<p>同单向认证一样，笔者将调试信息转换为下述时序图。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cafa6a349cf1fff0e319767af00dfb1?method=download&amp;shareKey=df90677bde25f8ef809ddd93365759e2" alt=""></p>
<p>双向认证和单向认证相比，Server发消息给Client时会额外发送一个<code>certificateRequestMsg</code>消息，Client收到此消息后会将证书信息（<code>certificateMsg</code>）和签名信息（<code>certificateVerifyMsg</code>）发送给Server。</p>
<p>双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有<strong>四次</strong>。</p>
<h4 id="总结">总结</h4>
<p>1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。</p>
<p>2、TLS1.2中除了<code>finishedMsg</code>其余消息均未加密。</p>
<p>3、在TLS1.2中，<code>ChangeCipherSpec</code>消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。</p>
<h3 id="和tls13的比较">和TLS1.3的比较</h3>
<h4 id="消息格式的变化">消息格式的变化</h4>
<p>对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是<code>certificateMsg</code>和<code>certificateMsgTLS13</code>的定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// TLS1.2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsg</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">certificates</span> [][]<span style="color:#66d9ef">byte</span>
}
<span style="color:#75715e">// TLS1.3
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsgTLS13</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">certificate</span>  <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Certificate</span>
	<span style="color:#a6e22e">ocspStapling</span> <span style="color:#66d9ef">bool</span>
	<span style="color:#a6e22e">scts</span>         <span style="color:#66d9ef">bool</span>
}
</code></pre></div><p>其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">certificateRequestMsg</td>
<td style="text-align:left">certificateRequestMsgTLS13</td>
</tr>
<tr>
<td style="text-align:left">certificateMsg</td>
<td style="text-align:left">certificateMsgTLS13</td>
</tr>
</tbody>
</table>
<h4 id="消息类型的变化">消息类型的变化</h4>
<p>TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">serverKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">clientKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">serverHelloDoneMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">encryptedExtensionsMsg</td>
</tr>
</tbody>
</table>
<h4 id="消息加密的变化">消息加密的变化</h4>
<p>前篇中提到，TLS1.3中除了<code>clientHelloMsg</code>和<code>serverHelloMsg</code>其他消息均做了加密处理，且握手期间和应用数据使用不同的密钥加密。</p>
<p>TLS1.2中仅有<code>finishedMsg</code>做了加密处理，且应用数据也使用该密钥加密。</p>
<p>TLS1.3会计算两次密钥，Client和Server读取对方的<code>HelloMsg</code>和<code>finishedMsg</code>之后即可计算密钥。</p>
<blockquote>
<p>“Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后”，这是前篇中的描述，计算时机描述不准确以上面为准。</p>
</blockquote>
<p>TLS1.2只计算一次密钥，Client和Server分别收到<code>serverKeyExchangeMsg</code>和<code>clientKeyExchangeMsg</code>之后即可计算密钥，和TLS1.3不同的是TLS1.2密钥计算后并不会立即对接下来发送的数据进行加密，只有当发送/接受<code>ChangeCipherSpec</code>消息后才会对接下来的数据进行加解密。</p>
<h4 id="生成密钥过程">生成密钥过程</h4>
<p>TLS1.2和TLS1.3生成密钥的过程还是比较相似的， 下图为Client读取<code>serverKeyExchangeMsg</code>之后的部分处理逻辑：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB931699839f1e500f2493ca4854c4443e?method=download&amp;shareKey=ffa6348e50fcedca417a2b9b3f3b2c36" alt=""></p>
<p>图中<code>X25519</code>是椭圆曲线迪菲-赫尔曼（Elliptic-curve Diffie–Hellman ，缩写为ECDH）密钥交换方案之一，这在前篇已经提到过故本篇不再赘述。</p>
<p>根据Debug结果，本例中<code>ka.preMasterSecret</code>和TLS1.3中的共享密钥生成逻辑完全一致。不仅如此，在后续的代码分析中，笔者发现TLS1.2也使用了<code>AEAD</code>加密算法对数据进行加解密（AEAD在前篇中已经提到过故本篇不再赘述）。</p>
<p>下图为笔者Debug结果：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46c9f6e0eebb4d6e53f69bc2715959e1?method=download&amp;shareKey=83cb14cdf13ea7c2968b6f55260741af" alt=""></p>
<p>图中<code>prefixNonceAEAD</code>即为TLS1.2中AEAD加密算法的一种实现。</p>
<p>这里需要注意的是TLS1.3也会计算<code>masterSecret</code>。为了方便理解，我们先回顾一下TLS1.3中生成<code>masterSecret</code>的部分源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 基于共享密钥派生hs.handshakeSecret
</span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">sharedKey</span>,
    <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">earlySecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
<span style="color:#75715e">// 基于hs.handshakeSecret 派生hs.masterSecret
</span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#66d9ef">nil</span>,
	<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
</code></pre></div><p>由上易知，TLS1.3先通过共享密钥派生出<code>handshakeSecret</code>，最后通过<code>handshakeSecret</code>派生出<code>masterSecret</code>。与此相比，TLS1.2生成<code>masterSecret</code>仅需一步：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">masterFromPreMasterSecret</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">preMasterSecret</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">hello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>)
</code></pre></div><p><code>masterFromPreMasterSecret</code>函数的作用是利用<code>HMAC</code>（HMAC在前篇中已经提到故本篇不再赘述）算法对Client和Server的随机数以及共享密钥进行摘要，从而计算得到<code>masterSecret</code>。</p>
<p><code>masterSecret</code>在后续的过程中并不会用于数据加密，下面笔者带各位读者分别看一下TLS1.3和TLS1.2生成数据加密密钥的过程。</p>
<p>TLS1.3生成数据加密密钥（以Client计算serverSecret为例）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">serverSecret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span>,
	<span style="color:#a6e22e">serverApplicationTrafficLabel</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">transcript</span>)
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">setTrafficSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">serverSecret</span>)
</code></pre></div><p>前篇中提到<code>hs.suite.deriveSecret</code>内部会通过<code>hs.transcript</code>计算出消息摘要从而重新得到一个<code>serverSecret</code>。<code>setTrafficSecret</code>方法内部会对<code>serverSecret</code>计算得到AEAD加密算法所需要的key和iv（初始向量：Initialization vector）。</p>
<p>因此可知TLS1.3计算密钥和Client/Server生成的随机数无直接关系，而与Client/Server当前收发的所有消息的摘要有关。</p>
<blockquote>
<p>补充：
IV通常是随机或者伪随机的。它和数据加密的密钥一起使用可以增加使用字典攻击的攻击者破解密码的难度。例如，如果加密数据中存在重复的序列，则攻击者可以假定消息中相应的序列也是相同的，而IV就是为了防止密文中出现相应的重复序列。</p>
<p>参考：</p>
<p><a href="https://whatis.techtarget.com/definition/initialization-vector-IV">https://whatis.techtarget.com/definition/initialization-vector-IV</a>
<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p>
</blockquote>
<p>TLS1.2生成数据加密密钥：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">clientMAC</span>, <span style="color:#a6e22e">serverMAC</span>, <span style="color:#a6e22e">clientKey</span>, <span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">clientIV</span>, <span style="color:#a6e22e">serverIV</span> <span style="color:#f92672">:=</span>
			<span style="color:#a6e22e">keysFromMasterSecret</span>(<span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">masterSecret</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">clientHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">macLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">keyLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">ivLen</span>)
<span style="color:#a6e22e">serverCipher</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">aead</span>(<span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">serverIV</span>)
<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">prepareCipherSpec</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">serverCipher</span>, <span style="color:#a6e22e">serverHash</span>)
</code></pre></div><p>前文中提到<code>masterSecret</code>的生成与Client和Server的随机数有关，而通过<code>keysFromMasterSecret</code>计算AEAD所需的key和iv依旧与随机数有关。</p>
<p><strong>小结</strong>：</p>
<p>1、本例中TLS1.2和TLS1.3均使用<code>X25519</code>算法计算共享密钥。</p>
<p>2、本例中TLS1.2和TLS1.3均使用<code>AEAD</code>进行数据加解密。</p>
<p>3、TLS1.3通过共享密钥派生两次才得到<code>masterSecret</code>，而TLS1.2以共享密钥、Client和Server的随机数一起计算得到<code>masterSecret</code>。</p>
<p>4、TLS1.3通过消息的摘要再次计算得到一个数据加密密钥，而TLS1.2直接通过<code>masterSecret</code>计算得到AEAD所需的key和iv。</p>
<h3 id="tls11和tls10不支持http2">TLS1.1和TLS1.0不支持HTTP2</h3>
<p>在前面提到本文的例子已经支持解析TLS1.x的握手流程，这个时候笔者突然很好奇浏览器还支持那些版本的TLS协议。</p>
<p>然后笔者在谷歌浏览器上首先测试了TLS1.1的服务，为了方便测试笔者改造了之前<a href="">服务器推送的案例</a>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">server</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">Addr</span>: <span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#a6e22e">Handler</span>: <span style="color:#66d9ef">nil</span>}
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span> = new(<span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Config</span>)
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">PreferServerCipherSuites</span> = <span style="color:#66d9ef">true</span>
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;h2&#34;</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
<span style="color:#75715e">// 服务端支持的最大tls版本调整为1.1
</span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">MaxVersion</span> = <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">VersionTLS11</span>
<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">ListenAndServeTLS</span>(<span style="color:#e6db74">&#34;ca.crt&#34;</span>, <span style="color:#e6db74">&#34;ca.key&#34;</span>)
</code></pre></div><p>运行Demo后得到如下截图：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2c8bf091ddf6f390b4a56357eb87fd2f?method=download&amp;shareKey=86fc79ae656452976818c5931a504bf8" alt=""></p>
<p>图中红框部分<code>obsolete</code>的意思笔者也不知，正好学习一波（技术人的英语大概就是这样慢慢积累起来的吧）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBab135aec59a8a4c6f59e89b5e1537686?method=download&amp;shareKey=fd9e75e79f9b3cccacfdc54e38e6193f" alt=""></p>
<p>这下笔者明白了，TLS1.1已经不被支持所以页面才无法正常访问，然而事实真是如此嘛？</p>
<p>直到几天后笔者开始写这篇文章时，内心仍是十分疑惑，于是使用了<code>curl</code>命令再次访问。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5f9afe2142e28f4f2094daca63d5e17b?method=download&amp;shareKey=51250aff915a34a94c60da68ad7719cf" alt=""></p>
<p>图中蓝框部分正是TLS1.1的握手流程，有兴趣的读者可以使用笔者的例子和<code>curl -v</code>命令进行双向验证。</p>
<p>图中红框部分提示说“HTTP2的数据发送失败”，笔者才恍然大悟，将上述代码作如下微调后页面可正常访问。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
</code></pre></div><p>经过笔者的测试，TLS1.0同TLS1.1一样均不支持HTTP2协议，当然这两个协议也不推荐继续使用。</p>
<h3 id="写在最后">写在最后</h3>
<p>“纸上得来终觉浅，绝知此事需躬行”。笔者不敢保证把TLS握手流程的每个细节都讲的十分清楚，所以建议各位读者去github克隆代码，然后自己一步一步Debug必然能够加深印象并彻底理解。当然，顺便关注或者star一下这种随手为之的小事，笔者相信各位读者还是十分乐意的～</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/http2/tls/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>区分Protobuf 3中缺失值和默认值</title>
            <link>https://isites.gitlab.io/isites/timeline/gopb3/</link>
            <pubDate>Tue, 01 Dec 2020 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/gopb3/</guid>
            <description>这两天翻了翻以前的项目，发现不同项目中关于Protobuf 3缺失值和默认值的区分居然有好几种实现。今天笔者冷饭新炒，结合项目中的实现以及切身经验共总结出如下六种方案。
增加标识字段 众所周知，在Go中数字类型的默认值为0（这里仅以数字类型举例），这在某些场景下往往会引起一定的歧义。
 以is_show字段为例，如果没有该字段表示不更新DB中的数据，如果有该字段且值为0则表示更新DB中的数据为不可见，如果有该字段且值为1则表示更新DB中的数据为可见。
 上述场景中，实际要解决的问题是如何区分默认值和缺失字段。增加标识字段是通过额外增加一个字段来达到区分的目的。
例如：增加一个has_show_field字段标识is_show是否为有效值。如果has_show_field为true则is_show为有效值，否则认为is_show未设置值。
此方案虽然直白，但每次设置is_show的值时还需设置has_show_field的值，甚是麻烦故笔者十分不推荐。
字段含义和默认值区分 字段含义和默认值区分即不使用对应类型的默认值作为该字段的有效值。接着前面的例子继续描述，is_show为1时表示展示，is_show为2时表示不展示，其他情况则认为is_show未设置值。
此方案笔者还是比较认可的，唯一问题就是和开发者的默认习惯略微不符。
使用oneof oneof 的用意是达到 C 语言 union 数据类型的效果，但是诸多大佬还是发现它可以标识缺失字段。
message Status { oneof show { int32 is_show = 1; } } message Test { int32 bar = 1; Status st = 2; } 上述proto文件生成对应go文件后，Test.St为Status的指针类型，故通过此方案可以区分默认值和缺失字段。但是笔者认为此方案做json序列化时十分不友好，下面是笔者的例子：
// oneof to json ot1 := oneof.Test{ Bar: 1, St: &amp;amp;oneof.Status{ Show: &amp;amp;oneof.Status_IsShow{ IsShow: 1, }, }, } bts, err := json.Marshal(ot1) fmt.Println(string(bts), err) // json to oneof failed jsonStr := `{&amp;#34;bar&amp;#34;:1,&amp;#34;st&amp;#34;:{&amp;#34;Show&amp;#34;:{&amp;#34;is_show&amp;#34;:1}}}` var ot2 oneof.</description>
            <content type="html"><![CDATA[<p>这两天翻了翻以前的项目，发现不同项目中关于Protobuf 3缺失值和默认值的区分居然有好几种实现。今天笔者冷饭新炒，结合项目中的实现以及切身经验共总结出如下六种方案。</p>
<h3 id="增加标识字段">增加标识字段</h3>
<p>众所周知，在Go中数字类型的默认值为<code>0</code>（这里仅以数字类型举例），这在某些场景下往往会引起一定的歧义。</p>
<blockquote>
<p>以<code>is_show</code>字段为例，如果没有该字段表示不更新DB中的数据，如果有该字段且值为<code>0</code>则表示更新DB中的数据为不可见，如果有该字段且值为<code>1</code>则表示更新DB中的数据为可见。</p>
</blockquote>
<p>上述场景中，实际要解决的问题是如何区分默认值和缺失字段。增加标识字段是通过额外增加一个字段来达到区分的目的。</p>
<p>例如：增加一个<code>has_show_field</code>字段标识<code>is_show</code>是否为有效值。如果<code>has_show_field</code>为<code>true</code>则<code>is_show</code>为有效值，否则认为<code>is_show</code>未设置值。</p>
<p>此方案虽然直白，但每次设置<code>is_show</code>的值时还需设置<code>has_show_field</code>的值，甚是麻烦故笔者十分不推荐。</p>
<h3 id="字段含义和默认值区分">字段含义和默认值区分</h3>
<p>字段含义和默认值区分即不使用对应类型的默认值作为该字段的有效值。接着前面的例子继续描述，<code>is_show</code>为1时表示展示，<code>is_show</code>为2时表示不展示，其他情况则认为<code>is_show</code>未设置值。</p>
<p>此方案笔者还是比较认可的，唯一问题就是和开发者的默认习惯略微不符。</p>
<h3 id="使用oneof">使用oneof</h3>
<p>oneof 的用意是达到 C 语言 union 数据类型的效果，但是诸多大佬还是发现它可以标识缺失字段。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
  <span style="color:#a6e22e">oneof</span> <span style="color:#a6e22e">show</span> {
    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
  }
}
<span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>上述proto文件生成对应go文件后，<code>Test.St</code>为<code>Status</code>的指针类型，故通过此方案可以区分默认值和缺失字段。但是笔者认为此方案做json序列化时十分不友好，下面是笔者的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// oneof to json
</span><span style="color:#75715e"></span><span style="color:#a6e22e">ot1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Test</span>{
  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">St</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Status</span>{
    <span style="color:#a6e22e">Show</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Status_IsShow</span>{
      <span style="color:#a6e22e">IsShow</span>: <span style="color:#ae81ff">1</span>,
    },
  },
}
<span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">ot1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
<span style="color:#75715e">// json to oneof failed
</span><span style="color:#75715e"></span><span style="color:#a6e22e">jsonStr</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;Show&#34;:{&#34;is_show&#34;:1}}}`</span>
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ot2</span> <span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Test</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ot2</span>))
</code></pre></div><p>上述输出结果如下：</p>
<pre><code>{&quot;bar&quot;:1,&quot;st&quot;:{&quot;Show&quot;:{&quot;is_show&quot;:1}}} &lt;nil&gt;
json: cannot unmarshal object into Go struct field Status.st.Show of type oneof.isStatus_Show
</code></pre><p>通过上述输出知，oneof的<code>json.Marshal</code>输出结果会额外多一层，而<code>json.Unmarshal</code>还会失败，因此使用oneof时需谨慎。</p>
<h3 id="使用wrapper类型">使用wrapper类型</h3>
<p>这应该是google官方提出的解决方案，我们看看下面的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;google/protobuf/wrappers.proto&#34;</span>;
<span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
    <span style="color:#a6e22e">google</span>.<span style="color:#a6e22e">protobuf</span>.<span style="color:#a6e22e">Int32Value</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
}
<span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>使用此方案需要引入<code>google/protobuf/wrappers.proto</code>。此方案生成对应go文件后，<code>Test.St</code>也是<code>Status</code>的指针类型。同样，我们也看一下它的json序列化效果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">wra1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Test</span>{
  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">St</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Status</span>{
    <span style="color:#a6e22e">IsShow</span>: <span style="color:#a6e22e">wrapperspb</span>.<span style="color:#a6e22e">Int32</span>(<span style="color:#ae81ff">1</span>),
  },
}
<span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">wra1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
<span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:{&#34;value&#34;:1}}}`</span>
<span style="color:#75715e">// 可正常转json
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wra2</span> <span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Test</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wra2</span>))
</code></pre></div><p>上述输出结果如下：</p>
<pre><code>{&quot;bar&quot;:1,&quot;st&quot;:{&quot;is_show&quot;:{&quot;value&quot;:1}}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>和oneof方案相比wrapper方案的json反序列化是没问题的，但是<code>json.Marshal</code>的输出结果也会额外多一层。另外，经笔者在本地试验，此方案无法和<code>gogoproto</code>一起使用。</p>
<h3 id="允许proto3使用optional标签">允许proto3使用<code>optional</code>标签</h3>
<p>前面几个方案估计在实践中还是不够尽善尽美。于是2020年5月16日<code>protoc v3.12.0</code>发布，该编译器允许proto3的字段也可使用 <code>optional</code>修饰。</p>
<p>下面看看例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
  <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
}
<span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>此方案需要使用新版本的<code>protoc</code>且必须使用<code>--experimental_allow_proto3_optional</code>开启此特性。protoc升级教程见https://github.com/protocolbuffers/protobuf#protocol-compiler-installation。下面继续看看该方案的json序列化效果</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">isShow</span> <span style="color:#66d9ef">int32</span> = <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">p3o1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Test</span>{
  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">St</span>:  <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Status</span>{<span style="color:#a6e22e">IsShow</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">isShow</span>},
}
<span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p3o1</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p3o2</span> <span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Test</span>
<span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}}`</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3o2</span>))
</code></pre></div><p>上述输出结果如下：</p>
<pre><code>{&quot;bar&quot;:1,&quot;st&quot;:{&quot;is_show&quot;:1}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>据上述结果知，此方案与oneof以及wrapper方案的json序列化相比更加符合预期，同样，经笔者在本地试验，此方案无法和<code>gogoproto</code>一起使用。</p>
<h3 id="proto2和proto3结合使用">proto2和proto3结合使用</h3>
<p>作为一个<code>gogoproto</code>的忠实用户，笔者希望在能区分默认值和缺失值的同时还可以继续使用<code>gogoproto</code>的特性。于是便产生了proto2和proto3结合使用的野路子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// proto2
</span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
    <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">2</span>;
}
<span style="color:#75715e">// proto3
</span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span> [(<span style="color:#a6e22e">gogoproto</span>.<span style="color:#a6e22e">moretags</span>) = <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">form</span>:<span style="color:#e6db74">&#34;more_bar&#34;</span><span style="color:#960050;background-color:#1e0010">&#39;</span>, (<span style="color:#a6e22e">gogoproto</span>.<span style="color:#a6e22e">jsontag</span>) = <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">custom_tag</span><span style="color:#960050;background-color:#1e0010">&#39;</span>];
    <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
}
</code></pre></div><p>需要区分缺失字段和默认值的message定义在语法为proto2的文件中，proto3通过<code>import</code>导入proto2的message以达区分目的。</p>
<p><code>optional</code>修饰的字段在Go中会生成指针类型，因此区分缺失值和默认值就变的十分容易了。下面看看此方案的json序列化效果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// p3p2 to json
</span><span style="color:#75715e"></span><span style="color:#a6e22e">p3p21</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Test</span>{
  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">St</span>:  <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Status</span>{<span style="color:#a6e22e">IsShow</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">isShow</span>},
}
<span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p3p21</span>)
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p3p22</span> <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Test</span>
<span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;custom_tag&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}}`</span>
<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3p22</span>))
</code></pre></div><p>上述输出结果如下：</p>
<pre><code>{&quot;custom_tag&quot;:1,&quot;st&quot;:{&quot;is_show&quot;:1}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>根据上述结果知，此方案不仅能够活用<code>gogoproto</code>的各种tag，其结果也和<strong>在proto3中直接使用optional</strong>效果一致。虽然笔者已经在自己的项目中使用了此方案，但是仍然要提醒一句：“写本篇文章时，笔者特意去github看了gogoproto的发布日志，gogoproto最新一个版本发布时间为<code>2019年10月14日</code>，笔者大胆预言gogoproto以后不会再更新了，所以此方案还请大家酌情使用”。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>注：</p>
<ol>
<li>文中笔者所用go版本为：go1.15.2</li>
<li>文中笔者所用protoc版本为：3.14.0</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/pbjson/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>为什么go中的receiver name不推荐使用this或者self</title>
            <link>https://isites.gitlab.io/isites/timeline/go-reciver/</link>
            <pubDate>Sat, 29 Aug 2020 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/go-reciver/</guid>
            <description>前言 在日常的开发中我们除了定义函数以外， 我们还会定义一些方法。这本来没有什么， 但是一些从PHP或者其他面向对象语言转GO的同学往往会把receiver name命名为this, self, me等。
笔者在实际项目开发中也遇到类似的同学， 屡次提醒却没有效果，于是决心写下这篇文章以便好好说服这些同学。
CR标准做法 首先我们来看一下GO推荐的标准命名Receiver Names，以下内容摘抄自https://github.com/golang/go/wiki/CodeReviewComments#receiver-names：
The name of a method&#39;s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as &amp;quot;c&amp;quot; or &amp;quot;cl&amp;quot; for &amp;quot;Client&amp;quot;). Don&#39;t use generic names such as &amp;quot;me&amp;quot;, &amp;quot;this&amp;quot; or &amp;quot;self&amp;quot;, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly.</description>
            <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在日常的开发中我们除了定义函数以外， 我们还会定义一些方法。这本来没有什么， 但是一些从PHP或者其他面向对象语言转GO的同学往往会把receiver name命名为<code>this</code>, <code>self</code>, <code>me</code>等。</p>
<p>笔者在实际项目开发中也遇到类似的同学， 屡次提醒却没有效果，于是决心写下这篇文章以便好好说服这些同学。</p>
<h2 id="cr标准做法">CR标准做法</h2>
<p>首先我们来看一下GO推荐的标准命名<code>Receiver Names</code>，以下内容摘抄自https://github.com/golang/go/wiki/CodeReviewComments#receiver-names：</p>
<pre><code>The name of a method's receiver should be a reflection of its identity;
often a one or two letter abbreviation of its type suffices (such as &quot;c&quot; or &quot;cl&quot; for &quot;Client&quot;). 
Don't use generic names such as &quot;me&quot;, &quot;this&quot; or &quot;self&quot;, identifiers typical of object-oriented languages that gives the method a special meaning. 
In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. 
...
</code></pre><p>简单翻译总结有如下2点：</p>
<ol>
<li>方法接受者名称应反映其身份， 并且不要使用<code>me</code>, <code>this</code>, <code>self</code>这些面向对象语言的典型标志符。</li>
<li>在go中方法接受者其实就是方法的另一个参数。</li>
</ol>
<h2 id="receiver是方法的第一个参数">Receiver是方法的第一个参数！</h2>
<p>上面的第二点， 可能不是很好理解，所以我们直接看下面的demo：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// T ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">int</span>

<span style="color:#75715e">// Println ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">Println</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;value: %v&#34;</span>, <span style="color:#a6e22e">t</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">T</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#a6e22e">T</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>) <span style="color:#75715e">// receiver作为函数的第一个参数，这个时候发生值拷贝，所以方法内部的t变量只是真实t变量的一个拷贝，这和this的含义是不相符的
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">// output:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">value</span>: <span style="color:#ae81ff">1</span>
<span style="color:#a6e22e">value</span>: <span style="color:#ae81ff">1</span>
</code></pre></div><p>通过上面的demo， 我们知道接受者可以直接作为第一个参数传递给方法的。而<code>t.Println()</code>应该就是Go中的一种语法糖了。</p>
<p>到这里可能有同学又要问了， 既然Go提供了这种语糖，那我们这样命名有什么问题呢？笔者先不着急解释， 我们继续看下面的demo：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Test ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Test</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#75715e">// SetA ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">Test</span>) <span style="color:#a6e22e">SetA</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span> = <span style="color:#a6e22e">a</span>
}

<span style="color:#75715e">// SetA1 ...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Test</span>) <span style="color:#a6e22e">SetA1</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span> = <span style="color:#a6e22e">a</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Test</span>{
		<span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">3</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;demo1:&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">SetA</span>(<span style="color:#ae81ff">5</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span>)
	<span style="color:#a6e22e">t1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Test</span>{
		<span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">4</span>,
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;demo2:&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t1</span>.<span style="color:#a6e22e">A</span>)
	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t1</span>).<span style="color:#a6e22e">SetA1</span>(<span style="color:#ae81ff">6</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t1</span>.<span style="color:#a6e22e">A</span>)
}
<span style="color:#75715e">// output:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">demo1</span>:
<span style="color:#ae81ff">3</span>
<span style="color:#ae81ff">3</span>
<span style="color:#a6e22e">demo2</span>:
<span style="color:#ae81ff">4</span>
<span style="color:#ae81ff">6</span>
</code></pre></div><p>看上面的demo我们知道， 当receiver不是指针时调用<code>SetA</code>其值根本没有改变。</p>
<p>因为Go中都是值传递，所以你如果对SetA的receiver的名称命名为<code>this</code>, <code>self</code>等，它就已经失去了本身的意义——“调用一个对象的方法就是向该对象传递一条消息”。而且对象本身的属性也并不一定会发生改变。</p>
<p><strong>综上</strong>: 请各位读者在对receiver命名时不要再用<code>this</code>, <code>self</code>等具有特殊含义的名称啦。</p>
<h2 id="receiver是可以为nil的">Receiver是可以为nil的！！！</h2>
<p>最近在研读<code>h2_bundle.go</code>的时候，发现了一段特殊的代码，顿时惊出一身冷汗，姑在本文补充一下，以防止自己和各位读者踩坑。</p>
<p>源代码截图如下：
<img src="https://note.youdao.com/yws/api/personal/file/WEBf28c8ce7424f4cc7a7620f735a83b9f1?method=download&amp;shareKey=829323e04d513a68e5cfe3c9d61d2a45" alt=""></p>
<p>惊出我一身冷汗的正是图中标红的部分，<strong>receiver居然还要判断为nil</strong>！在我的潜意识里一直是这样认为的，receiver默认都是有值的，直接使用就行了。这简直颠覆我的认知，吓得我赶紧写了个demo验证一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">test</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">testV</span>() {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">v</span>)
}


<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">test</span>()
	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">testV</span>()
}

</code></pre></div><p>上述输出如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf867c728b16230b0a82d6f9cd9d134ab?method=download&amp;shareKey=bc9e10dedff781d0406ed40e850a8b22" alt=""></p>
<p><code>a.test()</code>能够正常输出，只有在处理变量结构体内部变量<code>v</code>才报出panic！！！还好本文前面已经介绍了<code>Receiver是方法的第一个参数</code>。正因为是第一个参数所以仅仅作为参数传递时即使是<code>nil</code>也能够正常调用函数，而在真正使用的地方报出panic。</p>
<p>鉴于receiver如此特殊，所以特意在本文完成之后补充后续内容以时刻提醒自己和各位读者。</p>
<blockquote>
<p>本部分于20200827日晚补充。</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>深入剖析go中字符串的编码问题——特殊字符的string怎么转byte？</title>
            <link>https://isites.gitlab.io/isites/timeline/go-string-encode/</link>
            <pubDate>Mon, 24 Aug 2020 23:47:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/isites/timeline/go-string-encode/</guid>
            <description>前言 前段时间发表了Go中的HTTP请求之——HTTP1.1请求流程分析，所以这两天本来打算研究HTTP2.0的请求源码，结果发现太复杂就跑去逛知乎了，然后就发现了一个非常有意思的提问“golang 特殊字符的string怎么转成[]byte?”。为了转换一下心情， 便有了此篇文章。
问题 原问题我就不码字了，直接上图： 看到问题，我的第一反应是ASCII码值范围应该是0~127呀，怎么会超过127呢？直到实际运行的时候才发现上图的特殊字符是‘’（如果无法展示，记住该特殊字符的unicode是\u0081），并不是英文中的句号。
unicode和utf-8的恩怨纠葛 百度百科已经把unicode和utf-8介绍的很详细了，所以这里就不做过多的阐述，仅摘抄部分和本文相关的定义：
 Unicode为每个字符设定了统一并且唯一的二进制编码，通常用两个字节表示一个字符。 UTF-8是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。  go中的字符 众所周知，go中能表示字符的有两种类型，分别是byte和rune，byte和rune的定义分别是：type byte = uint8和type rune = int32。
uint8范围是0-255，只能够表示有限个unicode字符，超过255的范围就会编译报错。根据上述关于unicode的定义，4字节的rune完全兼容两字节的unicode。
我们用下面的代码来验证：
var ( c1 byte = &amp;#39;a&amp;#39; c2 byte = &amp;#39;新&amp;#39; c3 rune = &amp;#39;新&amp;#39; ) fmt.Println(c1, c2, c3) 上述的程序根本无法运行，因为第二行编译会报错，vscode给到了十分详细的提示：&#39;新&#39; (untyped rune constant 26032) overflows byte。
接下来，我们通过下面的代码来验证字符和unicode和整型的等价关系：
fmt.Printf(&amp;#34;0x%x, %d\n&amp;#34;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;) //输出：0x81, 129 	fmt.Println(0x81 == &amp;#39;&amp;#39;, &amp;#39;\u0081&amp;#39; == &amp;#39;&amp;#39;, 129 == &amp;#39;&amp;#39;) // 输出：true true true 	//\u0081输出到屏幕上后不展示， 所以换了大写字母A来输出 	fmt.</description>
            <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>前段时间发表了<a href="https://mp.weixin.qq.com/s/6WYhwaRrjv6W6NZCNw2CeA">Go中的HTTP请求之——HTTP1.1请求流程分析</a>，所以这两天本来打算研究HTTP2.0的请求源码，结果发现太复杂就跑去逛知乎了，然后就发现了一个非常有意思的提问“golang 特殊字符的string怎么转成[]byte?”。为了转换一下心情， 便有了此篇文章。</p>
<h3 id="问题">问题</h3>
<p>原问题我就不码字了，直接上图：
<img src="https://note.youdao.com/yws/api/personal/file/WEB33623d72a9ae4985e77f6c9247854c20?method=download&amp;shareKey=575343bfecd80b0d40ef4f53ed002e8b" alt=""></p>
<p>看到问题，我的第一反应是ASCII码值范围应该是<code>0~127</code>呀，怎么会超过127呢？直到实际运行的时候才发现上图的特殊字符是‘’（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>），并不是英文中的句号。</p>
<h3 id="unicode和utf-8的恩怨纠葛">unicode和utf-8的恩怨纠葛</h3>
<p>百度百科已经把unicode和utf-8介绍的很详细了，所以这里就不做过多的阐述，仅摘抄部分和本文相关的定义：</p>
<ul>
<li>Unicode为每个字符设定了统一并且唯一的二进制编码，<strong>通常用两个字节表示一个字符</strong>。</li>
<li>UTF-8是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。UTF-8的特点是对不同范围的字符使用不同长度的编码。<strong>对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同</strong>。</li>
</ul>
<h3 id="go中的字符">go中的字符</h3>
<p>众所周知，go中能表示字符的有两种类型，分别是<code>byte</code>和<code>rune</code>，byte和rune的定义分别是：<code>type byte = uint8</code>和<code>type rune = int32</code>。</p>
<p>uint8范围是0-255，只能够表示有限个unicode字符，超过255的范围就会编译报错。根据上述关于unicode的定义，4字节的rune完全兼容两字节的unicode。</p>
<p>我们用下面的代码来验证：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> (
		<span style="color:#a6e22e">c1</span> <span style="color:#66d9ef">byte</span> = <span style="color:#e6db74">&#39;a&#39;</span>
		<span style="color:#a6e22e">c2</span> <span style="color:#66d9ef">byte</span> = <span style="color:#e6db74">&#39;新&#39;</span>
		<span style="color:#a6e22e">c3</span> <span style="color:#66d9ef">rune</span> = <span style="color:#e6db74">&#39;新&#39;</span>
	)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c1</span>, <span style="color:#a6e22e">c2</span>, <span style="color:#a6e22e">c3</span>)
</code></pre></div><p>上述的程序根本无法运行，因为第二行编译会报错，vscode给到了十分详细的提示：<code>'新' (untyped rune constant 26032) overflows byte</code>。</p>
<p>接下来，我们通过下面的代码来验证<code>字符</code>和<code>unicode</code>和整型的等价关系：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;0x%x, %d\n&#34;</span>, <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#75715e">//输出：0x81, 129
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">0x81</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#e6db74">&#39;\u0081&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#ae81ff">129</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#75715e">// 输出：true true true
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//\u0081输出到屏幕上后不展示， 所以换了大写字母A来输出
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%c\n&#34;</span>, <span style="color:#ae81ff">65</span>) <span style="color:#75715e">// 输出：A
</span></code></pre></div><p>根据上面的代码输出的3个<code>true</code>可以知道，<strong>字符和unicode和整形是等价</strong>，并且整型也能转回字符的表现形式。</p>
<h3 id="go中的字符串是utf8编码的">go中的字符串是utf8编码的</h3>
<p>根据golang官方博客<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>的原文：</p>
<pre><code>
Go source code is always UTF-8.
A string holds arbitrary bytes.
A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.

</code></pre><p>翻译整理过来其实也就是两点：</p>
<ol>
<li>go中的代码总是用utf8编码，并且字符串能够存储任何字节。</li>
<li>没有经过字节级别的转义，那么字符串是一个标准的utf8序列。</li>
</ol>
<p>有了前面的基础知识和字符串是一个标准的utf8序列这一结论后我们接下来对字符串“”（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>）手动编码。</p>
<p>Unicode到UTF-8的编码方对照表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Unicode编码(十六进制)</th>
<th style="text-align:left">UTF-8 字节流(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">000000-00007F</td>
<td style="text-align:left">0xxxxxxx</td>
</tr>
<tr>
<td style="text-align:left">000080-0007FF</td>
<td style="text-align:left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">000800-00FFFF</td>
<td style="text-align:left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">010000-10FFFF</td>
<td style="text-align:left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>字符‘’（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>）的二进制表示为<code>10000001</code>，16进制表示为<code>0x81</code>。</p>
<p>根据unicode转utf8的对照表，0x7f &lt; 0x81 &lt; 0x7ff，所以此特殊字符需占两个字节，并且要套用的utf8模版是<code>110xxxxx 10xxxxxx</code>。</p>
<p>我们按照下面的步骤对<code>10000001</code>转为utf8的二进制序列：</p>
<p>第一步：根据x数量对特殊字符的高位补0。x的数量是11，所以需要对特殊字符的高位补3个0，此时特殊字符的二进制表示为：<code>00010000001</code>。</p>
<p>第二步：x有两个部分，且长度分别是5和6，所以对<code>00010000001</code>由底位向高位分别截取6位和5位，得到<code>000001</code>和<code>00010</code>。</p>
<p>第三步：将<code>000001</code>和<code>00010</code>由低位向高位填充至模版<code>110xxxxx 10xxxxxx</code>，可得到utf8的二进制序列为：<code>11000010 10000001</code>。</p>
<p>我们通过go对二进制转为整型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d, %d\n&#34;</span>, <span style="color:#ae81ff">0</span><span style="color:#a6e22e">b11000010</span>, <span style="color:#ae81ff">0</span><span style="color:#a6e22e">b10000001</span>)
<span style="color:#75715e">// 输出：194, 129
</span></code></pre></div><p><strong>综上</strong>：当用字符转字节时输出的是字符本身的整型值，当用字符串转字节切片时，实际上是输出的是utf8的字节切片序列(go中的字符串存储的就是utf8字节切片)。此时，我们回顾一下最开始的问题，就会发现输出是完全符合预期的。</p>
<h3 id="go中的rune">go中的rune</h3>
<p>笔者在这里猜测提问者期望的结果是“字符串转字节切片和字符转字节的结果保持一致”，这时<code>rune</code>就派上用场了，我们看看使用rune的效果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]rune(<span style="color:#e6db74">&#34;&#34;</span>))
<span style="color:#75715e">// 输出：[129]
</span></code></pre></div><p>由上可知用rune切片去转字符串时，它是直接将每个字符转为对应的unicode。</p>
<p>我们通过下面的代码模拟字符串转为[]rune切片和[]rune切片转为字符串的过程：</p>
<p>字符串转为rune切片:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// 字符串直接转为[]rune切片
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> []rune(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>) {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%x &#34;</span>, <span style="color:#a6e22e">v</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">bs</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">DecodeRune</span>(<span style="color:#a6e22e">bs</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%x &#34;</span>, <span style="color:#a6e22e">r</span>)
		<span style="color:#a6e22e">bs</span> = <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">w</span>:]
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#75715e">// 输出:
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 65b0 4e16 754c 6742 8d27 94fa
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 65b0 4e16 754c 6742 8d27 94fa
</span></code></pre></div><p>上述代码中<code>utf8.DecodeRune</code>的作用是通过传入的utf8字节序列转为一个rune即unicode。</p>
<p>rune切片转为字符串:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="color:#75715e">// rune切片转为字符串
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rs</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">rune</span>{<span style="color:#ae81ff">0x65b0</span>, <span style="color:#ae81ff">0x4e16</span>, <span style="color:#ae81ff">0x754c</span>, <span style="color:#ae81ff">0x6742</span>, <span style="color:#ae81ff">0x8d27</span>, <span style="color:#ae81ff">0x94fa</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">rs</span>))
	<span style="color:#a6e22e">utf8bs</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rs</span> {
		<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
		<span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">EncodeRune</span>(<span style="color:#a6e22e">bs</span>, <span style="color:#a6e22e">r</span>)
		<span style="color:#a6e22e">utf8bs</span> = append(<span style="color:#a6e22e">utf8bs</span>, <span style="color:#a6e22e">bs</span>[:<span style="color:#a6e22e">w</span>]<span style="color:#f92672">...</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">utf8bs</span>))
	<span style="color:#75715e">// 输出:
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 新世界杂货铺
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 新世界杂货铺
</span></code></pre></div><p>上述代码中<code>utf8.EncodeRune</code>的作用是将一个rune转为utf8字节序列。</p>
<p><strong>综上</strong>：对于无法确定字符串中仅有单字节的字符的情况， 请使用<code>rune</code>，每一个rune类型代表一个unicode字符，并且它可以和字符串做无缝切换。</p>
<h3 id="理解go中的字符串其实是字节切片">理解go中的字符串其实是字节切片</h3>
<p>前面已经提到了字符串能够存储任意字节数据，而且是一个标准的utf8格式的字节切片。那么本节将会通过代码来加深印象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>))
	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>], <span style="color:#e6db74">&#34; &#34;</span>)
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#75715e">// 输出：
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// [230 150 176 228 184 150 231 149 140 230 157 130 232 180 167 233 147 186]
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 230 150 176 228 184 150 231 149 140 230 157 130 232 180 167 233 147 186
</span></code></pre></div><p>由上述的代码可知，我们通过游标按字节访问字符串得到的结果和字符串转为字节切片是一样的，因此可以再次确认字符串和字节切片是等价的。</p>
<p>通常情况下我们的字符串都是标准utf8格式的字节切片，但这并不是说明字符串只能存储utf8格式的字节切片，<strong>go中的字符串可以存储任意的字节数据</strong>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">65</span>, <span style="color:#ae81ff">73</span>, <span style="color:#ae81ff">230</span>, <span style="color:#ae81ff">150</span>, <span style="color:#ae81ff">176</span>, <span style="color:#ae81ff">255</span>}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bs</span>))         <span style="color:#75715e">// 将随机的字节切片转为字符串
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(string(<span style="color:#a6e22e">bs</span>))) <span style="color:#75715e">// 将字符串再次转回字节切片
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">rs</span> <span style="color:#f92672">:=</span> []rune(string(<span style="color:#a6e22e">bs</span>)) <span style="color:#75715e">// 将字符串转为字节rune切片
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">rs</span>)          <span style="color:#75715e">// 输出rune切片
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">rs</span>))  <span style="color:#75715e">// 将rune切片转为字符串
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">bs</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">DecodeRune</span>(<span style="color:#a6e22e">bs</span>)
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d: 0x%x &#34;</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">r</span>) <span style="color:#75715e">// 输出rune的值和其对应的16进制
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">bs</span> = <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">w</span>:]
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(string(<span style="color:#a6e22e">rs</span>))) <span style="color:#75715e">// 将rune切片转为字符串后再次转为字节切片
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 输出：
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// AI新�
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 230 150 176 255]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 26032 65533]
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// AI新�
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 65: 0x41 73: 0x49 26032: 0x65b0 65533: 0xfffd 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 230 150 176 239 191 189]
</span><span style="color:#75715e"></span>
</code></pre></div><p>仔细阅读上面的代码和输出，前5行的输出应该是没有疑问的。但是第6行输出却和预期有出入。</p>
<p>前面提到了字符串可以存储任意的字节数据，那如果存储的字节数据不是标准的utf8字节切片就会出现上面的问题。</p>
<p>我们已经知道通过<code>utf8.DecodeRune</code>可以将字节切片转为rune。那如果碰到不符合utf8编码规范的字节切片时，utf8.DecodeRune会返回一个容错的unicode<code>\uFFFD</code>，这个unicode对应上面输出的16进制<code>0xfffd</code>。</p>
<p>问题也就出现在这个容错的unicode<code>\uFFFD</code>上，因为字节切片不符合utf8编码规范无法得到正确的unicode，既<code>\uFFFD</code>占据了本应该是正确的unicode所在的位置。这个时候再将已经含有容错字符的rune切片转为字符串时，字符串存储的就是合法的utf8字节切片了，因此第六行输出的是含有<code>\uFFFD</code>的合法utf8字节切片，也就产生了和最初始的字节切片不一致的情况了。</p>
<p>⚠️：<strong>在平时的开发中要注意rune切片和byte切片的相互转换一定要基于没有乱码的字符串(内部是符合utf8编码规则的字节切片)，否则容易出现上述类似的错误</strong>。</p>
<h3 id="字符串的多种表示方式">字符串的多种表示方式</h3>
<p>本节算是扩展了，在开发中还是尽量别用这种特殊的表示方式，虽然看起来很高级但是可读性太差。</p>
<p>下面直接看代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []byte([]byte(<span style="color:#e6db74">&#34;新&#34;</span>))
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">bs</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;0x%x &#34;</span>, <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">i</span>])
	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\xe6\x96\xb0&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\xe6\x96\xb0世界杂货铺&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#39;\u65b0&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;新&#39;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\u65b0世界杂货铺&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
	<span style="color:#75715e">// 输出:
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 0xe6 0x96 0xb0 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 新
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span></code></pre></div><p>目前笔者仅发现unicode和单字节的16进制可以直接用在字符串中， 欢迎读者提供更多的表示方式以供交流。</p>
<p>最后，祝大家读完此篇文章后能够有所收获。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
