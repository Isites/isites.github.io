<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Timelines on Gopher指北</title>
        <link>https://isites.gitlab.io/gopher/timeline/</link>
        <description>Recent content in Timelines on Gopher指北</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 24 Jan 2022 20:30:38 +0800</lastBuildDate>
        <atom:link href="https://isites.gitlab.io/gopher/timeline/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>一顿骚操作版本号比较性能提升300%</title>
            <link>https://isites.gitlab.io/gopher/timeline/version-compare/</link>
            <pubDate>Mon, 24 Jan 2022 20:30:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/version-compare/</guid>
            <description>在一次性能分析中，发现线上服务CompareVersion占用了较长的CPU时间。如下图所示。
其中占用时间最长的为strings.Split函数，这个函数对Gopher来说应该是非常熟悉的。而CompareVersion就是基于strings.Split函数来实现版本比较的，下面看一下CompareVersion的实现。
// 判断是否全为0 func zeroRune(s []rune) bool {  for _, r := range s {  if r != &amp;#39;0&amp;#39; &amp;amp;&amp;amp; r != &amp;#39;.&amp;#39; {  return false  }  }  return true } // CompareVersion 比较两个appversion的大小 // return 0 means ver1 == ver2 // return 1 means ver1 &amp;gt; ver2 // return -1 means ver1 &amp;lt; ver2 func CompareVersion(ver1, ver2 string) int {  // fast path  if ver1 == ver2 {  return 0  }  // slow path  vers1 := strings.</description>
            <content type="html"><![CDATA[<p>在一次性能分析中，发现线上服务<code>CompareVersion</code>占用了较长的CPU时间。如下图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9da6b92a54f075dda60c5dd9b3e6fb14?method=download&amp;shareKey=bcb8a12eb6ab81902045f5d429f0ead9" alt=""></p>
<p>其中占用时间最长的为<code>strings.Split</code>函数，这个函数对Gopher来说应该是非常熟悉的。而<code>CompareVersion</code>就是基于<code>strings.Split</code>函数来实现版本比较的，下面看一下<code>CompareVersion</code>的实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 判断是否全为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">zeroRune</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CompareVersion 比较两个appversion的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// return 0 means ver1 == ver2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// return 1 means ver1 &gt; ver2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// return -1 means ver1 &lt; ver2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CompareVersion</span>(<span style="color:#a6e22e">ver1</span>, <span style="color:#a6e22e">ver2</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fast path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ver1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ver2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// slow path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">vers1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">ver1</span>, <span style="color:#e6db74">&#34;.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vers2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">ver2</span>, <span style="color:#e6db74">&#34;.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1l</span>, <span style="color:#a6e22e">v2l</span> = len(<span style="color:#a6e22e">vers1</span>), len(<span style="color:#a6e22e">vers2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">i</span>        = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v2l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">e1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">vers1</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">e2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">vers2</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果不能转换为数字，使用go默认的字符串比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">e2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">vers1</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">vers2</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 根据比较结果进行返回， 如果res=0，则此部分相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最后谁仍有剩余且不为0，则谁大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">zeroRune</span>([]rune(<span style="color:#a6e22e">vers1</span>[<span style="color:#a6e22e">i</span>])) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v2l</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v2l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">zeroRune</span>([]rune(<span style="color:#a6e22e">vers2</span>[<span style="color:#a6e22e">i</span>])) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="尝试优化stringssplit函数">尝试优化strings.Split函数</h2>
<p><code>CompareVersion</code>的逻辑清晰且简单，而根据火焰图知性能主要消耗在<code>strings.Split</code>函数上，所以老许的第一目标是尝试优化<code>strings.Split</code>函数。</p>
<p>每当此时老许首先想到的方法就是百度大法和谷歌大法，最后在某篇文章中发现<code>strings.FieldsFunc</code>函数，根据该文章描述，<code>strings.FieldsFunc</code>函数分割字符串的速度远快于<code>strings.Split</code>函数。那么我们到底能不能使用<code>strings.FieldsFunc</code>函数替换<code>strings.Split</code>函数请看下面测试结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkSplit</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#e6db74">&#34;7.0.09.000&#34;</span>, <span style="color:#e6db74">&#34;.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#e6db74">&#34;7.0.09&#34;</span>, <span style="color:#e6db74">&#34;.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#e6db74">&#34;9.01&#34;</span>, <span style="color:#e6db74">&#34;.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkFieldsFunc</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">ResetTimer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">FieldsFunc</span>(<span style="color:#e6db74">&#34;7.0.09.000&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span> })
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">FieldsFunc</span>(<span style="color:#e6db74">&#34;7.0.09&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span> })
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">FieldsFunc</span>(<span style="color:#e6db74">&#34;9.01&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#66d9ef">rune</span>) <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span> })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述benchmark测试在老许的机器上某次运行结果如下：</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkSplit-4                 3718506               303.2 ns/op           144 B/op          3 allocs/op
BenchmarkSplit-4                 4144340               287.6 ns/op           144 B/op          3 allocs/op
BenchmarkSplit-4                 3859644               304.5 ns/op           144 B/op          3 allocs/op
BenchmarkSplit-4                 3729241               287.9 ns/op           144 B/op          3 allocs/op
BenchmarkFieldsFunc-4            3459463               336.5 ns/op           144 B/op          3 allocs/op
BenchmarkFieldsFunc-4            3604345               335.5 ns/op           144 B/op          3 allocs/op
BenchmarkFieldsFunc-4            3411564               313.9 ns/op           144 B/op          3 allocs/op
BenchmarkFieldsFunc-4            3661268               309.6 ns/op           144 B/op          3 allocs/op
</code></pre><p>根据输出知，<code>strings.FieldsFunc</code>函数没有想象中那么快，甚至还比不过<code>strings.Split</code>函数。既然此路不通，老许只好再另寻他法。</p>
<h2 id="尝试引入缓存">尝试引入缓存</h2>
<p>按照最卷的公司来，假如我们每周一个版本，且全年无休则一个公司要发布1000个版本需<code>19年</code>（1000/(365 / 7)）。基于这个内卷的数据，我们如果能够把这些版本都缓存起来，然后再比较大小，其执行速度绝对有一个质的提升。</p>
<h2 id="自实现过期缓存">自实现过期缓存</h2>
<p>要引入缓存的话，老许第一个想到的就是过期缓存。同时为了尽可能的轻量所以自己实现一个过期缓存无疑是一个不错的方案。</p>
<p>1、定义一个包含过期时间和数据的结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cacheItem</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">data</span>      <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">expiredAt</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// IsExpired 判断缓存内容是否到期
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cacheItem</span>) <span style="color:#a6e22e">IsExpired</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">expiredAt</span> &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Unix</span>() <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">expiredAt</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>2、使用<code>sync.Map</code>作为并发安全的缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cacheMap</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Set 增加缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">val</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">expiredAt</span> <span style="color:#66d9ef">int64</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cv</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cacheItem</span>{<span style="color:#a6e22e">val</span>, <span style="color:#a6e22e">expiredAt</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cacheMap</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">cv</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Get 得到缓存中的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不存在缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cv</span>, <span style="color:#a6e22e">isExists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cacheMap</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">isExists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 缓存不正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">citem</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cv</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">cacheItem</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读数据时删除缓存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">citem</span>.<span style="color:#a6e22e">IsExpired</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cacheMap</span>.<span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最后返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">citem</span>.<span style="color:#a6e22e">Data</span>(), <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>3、定义一个通过<code>.</code>分割可存储每部分数据的结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 缓存一个完整的版本使用切片即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cmVal</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">iv</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sv</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 能否转换为整形
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">canInt</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>4、将app版本转为切片以方便缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">strs2cmVs</span>(<span style="color:#a6e22e">strs</span> []<span style="color:#66d9ef">string</span>) []<span style="color:#f92672">*</span><span style="color:#a6e22e">cmVal</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmvs</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">cmVal</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">strs</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strs</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">it</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 全部数据都保存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">cmvs</span> = append(<span style="color:#a6e22e">cmvs</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cmVal</span>{<span style="color:#a6e22e">it</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>})
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cmvs</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>5、使用带缓存的方式进行版本大小比较</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CompareVersionWithCache1</span>(<span style="color:#a6e22e">ver1</span>, <span style="color:#a6e22e">ver2</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fast path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ver1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ver2</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// slow path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmv1</span>, <span style="color:#a6e22e">cmv2</span>             []<span style="color:#f92672">*</span><span style="color:#a6e22e">cmVal</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmv1Exists</span>, <span style="color:#a6e22e">cmv2Exists</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">expire</span>                 <span style="color:#66d9ef">int64</span> = <span style="color:#ae81ff">200</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">60</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// read cache 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cmv</span>, <span style="color:#a6e22e">cmvExists</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ver1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmvExists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmv1</span>, <span style="color:#a6e22e">cmv1Exists</span> = <span style="color:#a6e22e">cmv</span>.([]<span style="color:#f92672">*</span><span style="color:#a6e22e">cmVal</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">cmv1Exists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// set val and cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">cmv1</span> = <span style="color:#a6e22e">strs2cmVs</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">ver1</span>, <span style="color:#e6db74">&#34;.&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">ver1</span>, <span style="color:#a6e22e">cmv1</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Unix</span>()<span style="color:#f92672">+</span><span style="color:#a6e22e">expire</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// read cache 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cmv</span>, <span style="color:#a6e22e">cmvExists</span> = <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">ver2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmvExists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cmv2</span>, <span style="color:#a6e22e">cmv2Exists</span> = <span style="color:#a6e22e">cmv</span>.([]<span style="color:#f92672">*</span><span style="color:#a6e22e">cmVal</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">cmv2Exists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// set val and cache
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">cmv2</span> = <span style="color:#a6e22e">strs2cmVs</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">ver2</span>, <span style="color:#e6db74">&#34;.&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">ver2</span>, <span style="color:#a6e22e">cmv2</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Unix</span>()<span style="color:#f92672">+</span><span style="color:#a6e22e">expire</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// compare ver str
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1l</span>, <span style="color:#a6e22e">v2l</span> = len(<span style="color:#a6e22e">cmv1</span>), len(<span style="color:#a6e22e">cmv2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">i</span>        = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">cmv1</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">cmv2</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// can use int compare
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">canInt</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">canInt</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">iv</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">iv</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">sv</span>, <span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">sv</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">res</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">canInt</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">iv</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">zeroRune</span>([]rune(<span style="color:#a6e22e">cmv1</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">sv</span>)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v2l</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v2l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">v1l</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">canInt</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">iv</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">zeroRune</span>([]rune(<span style="color:#a6e22e">cmv2</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">sv</span>)) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>CompareVersionWithCache1</code>函数比较步骤为：</p>
<ul>
<li>如果版本字符串相等直接返回</li>
<li>分别读取两个版本对应的缓存数据，如果没有缓存数据数据则生成缓存数据并缓存</li>
<li>分别对比两个版本对应的<code>[]*cmVal</code>数据，返回大小</li>
</ul>
<p>最后进行性能验证，以下为<code>CompareVersionWithCache1</code>函数和<code>CompareVersion</code>函数的benchmark对比。</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkCompareVersion-4                  1642657           767.6 ns/op         304 B/op           6 allocs/op
BenchmarkCompareVersionWithCache1-4        1296520           844.9 ns/op           0 B/op           0 allocs/op
</code></pre><p>通过上述结果分析知，使用缓存后唯一的优化只是减少了微乎其微的内存分配。这个结果实在令老许充满了疑惑，在使用pprof分析后终于发现性能没有提升的原因。以下为benchmark期间<code>BenchmarkCompareVersionWithCache1</code>函数的火焰图。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB763dd3e7cd65369adac37e61368d482e?method=download&amp;shareKey=b2bcdbc121af2c92f7799d18faf4c57d" alt=""></p>
<p>因为考虑到app版本数量较小，所以使用了惰性淘汰的方式淘汰过期缓存，在每次读取数据时判断缓存是否过期。根据火焰图知性能损耗最大的就是判断缓存是否过期，每次判断缓存是否过期都需要调用<code> time.Now().Unix()</code>得到当前时间戳。也就是因为<code>time.Now()</code>的这个调用导致这次优化功亏一篑。</p>
<h2 id="引入lru缓存">引入LRU缓存</h2>
<p>考虑到版本数量本身不多，且对于常用的版本可以尽可能永久缓存，因此引入LRU缓存做进一步性能优化尝试。</p>
<p>1、引入开源的LRU缓存，对应开源库为: github.com/hashicorp/golang-lru</p>
<p>2、在<code>CompareVersionWithCache1</code>函数的基础上将读写缓存替换为引入的LRU缓存</p>
<p>最后进行性能验证，以下为<code>CompareVersionWithCache2</code>函数和<code>CompareVersion</code>函数的benchmark对比。</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkCompareVersion-4                  1583202           841.7 ns/op         304 B/op           6 allocs/op
BenchmarkCompareVersionWithCache2-4        1671758           633.9 ns/op          96 B/op           6 allocs/op
</code></pre><p>哎，这个结果终于有点样子了，但优化效果并不明显，还有进一步提升的空间。</p>
<h2 id="自实现lru缓存">自实现LRU缓存</h2>
<p>选择LRU缓存是有效果的，在这个基础上老许决定自己实现一个极简的LRU缓存。</p>
<p>1、定义一个缓存节点结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lruCacheItem</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 双向链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruCacheItem</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 缓存数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">data</span>       <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 缓存数据对应的key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">key</span>        <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>2、 定义一个操作LRU缓存的结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lruc</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 链表头指针和尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">tail</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruCacheItem</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 一个map存储各个链表的指针，以方便o(1)的复杂度读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lruMap</span>     <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">lruCacheItem</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">rw</span>         <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">size</span>       <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewLRU</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int64</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">lruc</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">size</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">lruc</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">head</span>:   new(<span style="color:#a6e22e">lruCacheItem</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">tail</span>:   new(<span style="color:#a6e22e">lruCacheItem</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lruMap</span>: make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">lruCacheItem</span>),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">size</span>:   <span style="color:#a6e22e">size</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">tail</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lru</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>3、LRU缓存的Set方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">lru</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruc</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fast path
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">exist</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">exist</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">lruCacheItem</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">data</span>: <span style="color:#a6e22e">v</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prev</span>: <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">next</span>: <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">key</span>:  <span style="color:#a6e22e">key</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// add first
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// double check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">exist</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>]; !<span style="color:#a6e22e">exist</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>) &gt; int(<span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">size</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// delete tail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">tail</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>        delete(<span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>, <span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>4、LRU缓存的Get方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">lru</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruc</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// move to head.next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">data</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>5、在<code>CompareVersionWithCache1</code>函数的基础上将读写缓存替换为自实现的LRU缓存</p>
<p>最后进行性能验证，以下为<code>CompareVersionWithCache3</code>函数和<code>CompareVersion</code>函数的benchmark对比：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">cpu</span>: <span style="color:#a6e22e">Intel</span>(<span style="color:#a6e22e">R</span>) <span style="color:#a6e22e">Core</span>(<span style="color:#a6e22e">TM</span>) <span style="color:#a6e22e">i7</span><span style="color:#f92672">-</span><span style="color:#ae81ff">7567</span><span style="color:#a6e22e">U</span> <span style="color:#a6e22e">CPU</span> <span style="color:#960050;background-color:#1e0010">@</span> <span style="color:#ae81ff">3.50</span><span style="color:#a6e22e">GHz</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">BenchmarkCompareVersion</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>                  <span style="color:#ae81ff">1575007</span>           <span style="color:#ae81ff">763.1</span> <span style="color:#a6e22e">ns</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>         <span style="color:#ae81ff">304</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>           <span style="color:#ae81ff">6</span> <span style="color:#a6e22e">allocs</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">BenchmarkCompareVersionWithCache3</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>        <span style="color:#ae81ff">3285632</span>           <span style="color:#ae81ff">317.6</span> <span style="color:#a6e22e">ns</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>           <span style="color:#ae81ff">0</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>           <span style="color:#ae81ff">0</span> <span style="color:#a6e22e">allocs</span><span style="color:#f92672">/</span><span style="color:#a6e22e">op</span>
</span></span></code></pre></div><p>引入自实现的LRU缓存后，性能足足提升了一倍，到这里老许几乎准备去公司装逼了，但是心里总有个声音在问我有没有无锁的方式读取缓存。</p>
<h3 id="减少lru缓存锁竞争">减少LRU缓存锁竞争</h3>
<p>无锁的方式确实没有想到，只想到了两种减少锁竞争的方式。</p>
<ul>
<li>不需要每次读数据时都将节点移动到链表头，只有当LRU缓存数量接近Size上限的时候才将最新读取的数据移动到链表头</li>
<li>既然是LRU缓存，那么访问频率越高，缓存节点越靠近链表头，基于这个特性可以考虑在每次访问的时候加入随机数以减小锁的竞争(即访问频率越高越有机会通过随机数控制将缓存节点移动到链表头)。</li>
</ul>
<p>加入随机数后的实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">lru</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruc</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 这里随机写100
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>()<span style="color:#f92672">%</span><span style="color:#ae81ff">100</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">data</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>加入随机数后的<code>CompareVersionWithCache3</code>函数和<code>CompareVersion</code>函数的benchmark对比如下：</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkCompareVersion-4                  1617837           761.5 ns/op         304 B/op           6 allocs/op
BenchmarkCompareVersionWithCache3-4        4817722           251.3 ns/op           0 B/op           0 allocs/op
</code></pre><p>加入随机数后，<code>CompareVersionWithCache3</code>函数性能再次提升<code>20%</code>左右。优化还没结束，当缓存数量远不足设置的缓存上限时不需要移动到链表头。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">lru</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lruc</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">string</span>) (<span style="color:#66d9ef">interface</span>{}, <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>[<span style="color:#a6e22e">key</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// move to head.next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">lruMap</span>) &gt; int(<span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">size</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>()<span style="color:#f92672">%</span><span style="color:#ae81ff">100</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">lru</span>.<span style="color:#a6e22e">rw</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>.<span style="color:#a6e22e">data</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>引入上述优化后，benchmark对比如下：</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkCompareVersion-4                1633576               793.2 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1619822               882.7 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1639792               737.2 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1630004               758.3 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersionWithCache3-4      7538025               155.9 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      7514742               150.1 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      8357704               162.9 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      7748578               148.0 ns/op             0 B/op          0 allocs/op
</code></pre><p>至此，最终版的版本比较实现在理想情况下（缓存空间较足）性能达到原先的<code>4</code>倍。</p>
<h2 id="有的人就是老天爷赏饭吃">有的人就是老天爷赏饭吃</h2>
<p>本来老许都准备去公司装逼了，万万没想到同事已经搞了一个更加合理且稳定的版本比较算法，让老许自愧不如。</p>
<p>该算法思路如下：</p>
<ul>
<li>不使用<code>strings.Split</code>函数将版本以<code>.</code>分割，而是从左到右依次对比每一个字符直至遇到不同的字符，并分别记录索引<code>i,j</code></li>
<li>遍历两个版本剩余部分字符串，以<code>i、j</code>为始直至遇到第一个<code>.</code>，将这两部分字符串转为整形进行比较</li>
<li>如果前两步完成后仍相等，则谁还有剩余字符则谁大</li>
</ul>
<p>三种算法benchmark如下：</p>
<pre tabindex="0"><code>cpu: Intel(R) Core(TM) i7-7567U CPU @ 3.50GHz
BenchmarkCompareVersion-4                1803190               674.8 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1890308               630.9 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1855741               631.8 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersion-4                1850410               629.4 ns/op           304 B/op          6 allocs/op
BenchmarkCompareVersionWithCache3-4      8877466               132.2 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      8489661               132.6 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      8358210               132.6 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionWithCache3-4      8456853               131.9 ns/op             0 B/op          0 allocs/op
BenchmarkCompareVersionNoSplit-4         6309705               178.9 ns/op             8 B/op          2 allocs/op
BenchmarkCompareVersionNoSplit-4         6228823               181.2 ns/op             8 B/op          2 allocs/op
BenchmarkCompareVersionNoSplit-4         6370544               177.8 ns/op             8 B/op          2 allocs/op
BenchmarkCompareVersionNoSplit-4         6351043               180.0 ns/op             8 B/op          2 allocs/op
</code></pre><p><code>BenchmarkCompareVersionNoSplit</code>函数不需要引入缓存，也不会像<code>BenchmarkCompareVersionWithCache3</code>中的缓存数量接近上限后会有一定的性能损失，几乎是我目前发现的最为理想的版本比较方案。</p>
<p>老许也不说什么当局者迷，旁观者清这种酸葡萄一般的话，只得承认有的人就是老天爷赏饭吃。有一说一碰上这种人是我的幸运，我相信他只要有口饭吃，我就能在他屁股后面蹭口汤喝。关于文中最后提到的版本号比较算法完整实现请至下面的github仓库查看：</p>
<p><a href="https://github.com/Isites/ares/tree/main/strs">https://github.com/Isites/ares/tree/main/strs</a></p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>注：</p>
<p>写本文时， 笔者所用go版本为: go1.16.6</p>
<p>文章中所用完整例子：https://github.com/Isites/go-coder/tree/master/strs</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>探讨系统中💰钱的精度问题</title>
            <link>https://isites.gitlab.io/gopher/timeline/money/</link>
            <pubDate>Mon, 20 Dec 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/money/</guid>
            <description>钱,乃亘古之玄物,有则气粗神壮,缺则心卑力浅
 在一个系统中，特别是一个和钱相关的系统，钱乃重中之重，计算时的精度将是本篇讨论的主题。
精度为何如此重要 “积羽沉舟”用在此处最为合适。假如某电商平台每年订单成交数量为10亿，每笔订单少结算1分钱，则累计损失1000万！有一说一，这损失的钱就是王某人的十分之一个小目标。如果因为精度问题在给客户结算时，少算会损失客户，多算会损失钱。由此可见，精确的计算钱十分重要！
为什么会有精度的问题 经典案例，我们来看一下0.1 + 0.2在计算机中是否等于0.3。
上述case学过计算机的应该都知道，计算机是二进制的，用二进制表示浮点数时(IEEE754标准)，只有少量的数可以用这种方法精确的表示出来。下面以0.3为例看一下十进制转二进制小数的过程。
计算机的位数有限制，因此计算机用浮点数计算时肯定无法得到精确的结果。这种硬限制无法突破，所以需要引入精度以保证对钱的计算在允许的误差范围内尽可能准确。
 关于浮点数在计算机中的实际表示本文不做进一步讨论，可以参考下述连接学习：
单精度浮点数表示：
https://en.wikipedia.org/wiki/Single-precision_floating-point_format
双精度浮点数表示：
https://en.wikipedia.org/wiki/Double-precision_floating-point_format
浮点数转换器：
https://www.h-schmidt.net/FloatConverter/IEEE754.html
 用浮点数计算 还是以上述0.1 + 0.2为例，0.00000000000000004的误差完全可以忽略，我们尝试小数部分保留5位精度，看下面结果。
此时的结果符合预期。这也是为什么很多时候判断两个浮点数是否相等往往采用a - b &amp;lt;= 0.00001的形式，说白了这就是小数部分保留5位精度的另一种表现形式。
用整型计算 前面提到只有少量的浮点数可以用IEEE754标准表示，而整型可精确表示所有有效范围内的数。因此很容易想到，使用整型表示浮点数。
例如，事先定好小数保留8位精度，则0.1和0.2分别表示成整数为10000000和20000000, 浮点数的运算也就转换为整型的运算。还是以0.1 + 0.2为例。
// 表示小数位保留8位精度 const prec = 100000000  func float2Int(f float64) int64 { 	return int64(f * prec) }  func int2float(i int64) float64 { 	return float64(i) / prec } func main() { 	var a, b float64 = 0.</description>
            <content type="html"><![CDATA[<blockquote>
<p><code>钱,乃亘古之玄物,有则气粗神壮,缺则心卑力浅</code></p>
</blockquote>
<p>在一个系统中，特别是一个和钱相关的系统，钱乃重中之重，计算时的精度将是本篇讨论的主题。</p>
<h2 id="精度为何如此重要">精度为何如此重要</h2>
<p>“积羽沉舟”用在此处最为合适。假如某电商平台每年订单成交数量为10亿，每笔订单少结算1分钱，则累计损失<code>1000万</code>！有一说一，这损失的钱就是王某人的十分之一个小目标。如果因为精度问题在给客户结算时，少算会损失客户，多算会损失钱。由此可见，精确的计算钱十分重要！</p>
<h2 id="为什么会有精度的问题">为什么会有精度的问题</h2>
<p>经典案例，我们来看一下<code>0.1 + 0.2</code>在计算机中是否等于<code>0.3</code>。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf804d312461f4ec67ccd01132997ffff?method=download&amp;shareKey=d0bf734abc1fe9de099227c381b3bb17" alt=""></p>
<p>上述case学过计算机的应该都知道，计算机是二进制的，用二进制表示浮点数时(IEEE754标准)，只有少量的数可以用这种方法精确的表示出来。下面以0.3为例看一下十进制转二进制小数的过程。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5b5f3c3225eb1ed793afcf58b832bb90?method=download&amp;shareKey=8a5ae11fcdb830ec79006aea6b09a560" alt=""></p>
<p>计算机的位数有限制，因此计算机用浮点数计算时肯定无法得到精确的结果。这种硬限制无法突破，所以需要引入精度以保证对钱的计算在允许的误差范围内尽可能准确。</p>
<blockquote>
<p>关于浮点数在计算机中的实际表示本文不做进一步讨论，可以参考下述连接学习：</p>
<p>单精度浮点数表示：</p>
<p><a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">https://en.wikipedia.org/wiki/Single-precision_floating-point_format</a></p>
<p>双精度浮点数表示：</p>
<p><a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">https://en.wikipedia.org/wiki/Double-precision_floating-point_format</a></p>
<p>浮点数转换器：</p>
<p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a></p>
</blockquote>
<h2 id="用浮点数计算">用浮点数计算</h2>
<p>还是以上述<code>0.1 + 0.2</code>为例，<code>0.00000000000000004</code>的误差完全可以忽略，我们尝试小数部分保留5位精度，看下面结果。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa904cba0f98c32314621cf074596c667?method=download&amp;shareKey=4a3cfa75c5e38ec58ec3ebc408d6c583" alt=""></p>
<p>此时的结果符合预期。这也是为什么很多时候判断两个浮点数是否相等往往采用<code>a - b &lt;= 0.00001</code>的形式，说白了这就是小数部分保留5位精度的另一种表现形式。</p>
<h2 id="用整型计算">用整型计算</h2>
<p>前面提到只有少量的浮点数可以用IEEE754标准表示，而整型可精确表示所有有效范围内的数。因此很容易想到，使用整型表示浮点数。</p>
<p>例如，事先定好小数保留8位精度，则<code>0.1</code>和<code>0.2</code>分别表示成整数为<code>10000000</code>和<code>20000000</code>,  浮点数的运算也就转换为整型的运算。还是以<code>0.1 + 0.2</code>为例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 表示小数位保留8位精度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">prec</span> = <span style="color:#ae81ff">100000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">int64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> int64(<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">prec</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">int2float</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int64</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> float64(<span style="color:#a6e22e">i</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">prec</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">float64</span> = <span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">0.2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span><span style="color:#f92672">+</span><span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">int2float</span>(<span style="color:#a6e22e">f</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码输出结果如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB90f4a3faef6fab8ce5230655a4e4b695?method=download&amp;shareKey=7516cb7b6cbd33c1953bcff518cb93d8" alt=""></p>
<p>上述输出结果完全符合预期，所以用整型来表示浮点数看起来是一个可行的方案。但，我们不能局限于个例，还需要更多的测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">float2Int</span>(<span style="color:#ae81ff">2.3</span>))
</span></span></code></pre></div><p>上述代码输出结果如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBefdbec902ab6904b50790c6dd7c930f4?method=download&amp;shareKey=453064325c56910cf93cb28c166de7cd" alt=""></p>
<p>这个结果是如此的出乎意料，却又是情理之中。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe786aa264db530711fa0ab6330c2d52e?method=download&amp;shareKey=80360e18093eac4da4fa7da3629e7aaf" alt=""></p>
<p>上图表示<code>2.3</code>在计算机中实际的存储值，因此使用<code>float2Int</code>函数进行转换时的结果是<code>229999999</code>而不是<code>230000000</code>。</p>
<p>这个结果很明显不符合预期，在确定的精度范围内仍有精度损失，如果把这个代码发到线上，很大概率第二天就会光速离职。要解决这个问题也很简单，只需引入<code>github.com/shopspring/decimal</code>即可，看下面修正后的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 表示小数位保留8位精度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">prec</span> = <span style="color:#ae81ff">100000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">decimalPrec</span> = <span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromFloat</span>(<span style="color:#a6e22e">prec</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">int64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromFloat</span>(<span style="color:#a6e22e">f</span>).<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">decimalPrec</span>).<span style="color:#a6e22e">IntPart</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">float2Int</span>(<span style="color:#ae81ff">2.3</span>)) <span style="color:#75715e">// 输出：230000000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>此时结果符合预期，系统内部的浮点运算(加法、减法、乘法)均可转换为整型运算，而运算结果只需要一次浮点转换即可。</p>
<p>到这里，用整型计算基本能满足大部分场景，但仍有两个问题尚需注意。</p>
<p>1、整型表示浮点数的范围是否满足系统需求。</p>
<p>2、整型表示浮点数时除法依旧需要转换为浮点数运算。</p>
<p><strong>整型表示浮点数的范围</strong></p>
<p>以<code>int64</code>为例，数值范围为<code>-9223372036854775808～9223372036854775807</code>，如果我们对小数部分精度保留8位，则剩余表示整数部分依旧有11位，即只表示钱的话仍旧可以存储上<code>百亿</code>的金额，这个数值对很多系统和中小型公司而言已经绰绰有余，但是使用此方式存储金额时范围依旧是需要慎重考虑的问题。</p>
<p><strong>整型表示浮点数的除法</strong></p>
<p>在Go中没有隐式的整型转浮点的说法，即整型和整型相除得到的结果依旧是整型。我们以整型表示浮点数时，就尤其需要注意整型的除法运算会丢失所有的小数部分，所以一定要先转换为浮点数再进行相除。</p>
<h2 id="浮点和整型的最大精度">浮点和整型的最大精度</h2>
<p><code>int64</code>的范围为<code>-9223372036854775808～9223372036854775807</code>，则用整型表示浮点型时，整数部分和小数部分的有效十进制位最多为<code>19</code>位。</p>
<p><code>uint64</code>的范围为<code>0~18446744073709551615</code>，则用整型表示浮点型时，整数部分和小数部分的有效十进制位最多为<code>20</code>位，因为系统中表示金额时一般不会存储负数，所以和<code>int64</code>相比，更加推荐使用<code>uint64</code>。</p>
<p><code>float64</code>根据IEEE754标准，并参考维基百科知其整数部分和小数部分的有效十进制位为<code>15-17</code>位。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb978e1253b122cb3d36f2db17ede350d?method=download&amp;shareKey=c34eac96cb76f0e7f4b1acc3da4aabac" alt=""></p>
<p>我们看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">float64</span> = <span style="color:#ae81ff">123456789012345.678</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">float64</span> = <span style="color:#ae81ff">1.23456789012345678</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromFloat</span>(<span style="color:#a6e22e">a</span>), <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">123456789012345.67</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span>
</span></span></code></pre></div><p>上述代码输出结果如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c85da3c9f69f02b709dc1f3b3efda68?method=download&amp;shareKey=e4d4c9207af46a31a3dfab77119ce4ae" alt=""></p>
<p>根据输出结果知，<code>float64</code>无法表示有效位数超过17位的十进制数。从有效十进制位来讲，老许更加推荐使用整型表示浮点数。</p>
<h2 id="计算中尽量保留更多的精度">计算中尽量保留更多的精度</h2>
<p>前面提到了精度的重要性，以及整型和浮点型可表示的最大精度，下面我们以一个实际例子来探讨计算过程中是否要保留指定的精度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 广告平台总共收入7.11美元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fee</span> <span style="color:#66d9ef">float64</span> = <span style="color:#ae81ff">7.1100</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以下是不同渠道带来的点击数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">clkDetails</span> = []<span style="color:#66d9ef">int64</span>{<span style="color:#ae81ff">220</span>, <span style="color:#ae81ff">127</span>, <span style="color:#ae81ff">172</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">1039</span>, <span style="color:#ae81ff">1596</span>, <span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">236</span>, <span style="color:#ae81ff">151</span>, <span style="color:#ae81ff">91</span>, <span style="color:#ae81ff">87</span>, <span style="color:#ae81ff">378</span>, <span style="color:#ae81ff">289</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">439</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2373</span>, <span style="color:#ae81ff">90</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">totalClk</span>   <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 计算所有渠道带来的总点击数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">clkDetails</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">totalClk</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">floatTotal</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以浮点数计算每次点击的收益
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">floatCPC</span> <span style="color:#66d9ef">float64</span> = <span style="color:#a6e22e">fee</span> <span style="color:#f92672">/</span> float64(<span style="color:#a6e22e">totalClk</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">intTotal</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以8位精度的整形计算每次点击的收益(每次点击收益转为整形)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">intCPC</span>        <span style="color:#66d9ef">int64</span> = <span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">fee</span> <span style="color:#f92672">/</span> float64(<span style="color:#a6e22e">totalClk</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">intFloatTotal</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以8位进度的整形计算每次点击的收益(每次点击收益保留为浮点型)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">intFloatCPC</span>  <span style="color:#66d9ef">float64</span> = float64(<span style="color:#a6e22e">float2Int</span>(<span style="color:#a6e22e">fee</span>)) <span style="color:#f92672">/</span> float64(<span style="color:#a6e22e">totalClk</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">decimalTotal</span>         = <span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">Zero</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 以decimal计算每次点击收益
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">decimalCPC</span> = <span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromFloat</span>(<span style="color:#a6e22e">fee</span>).<span style="color:#a6e22e">Div</span>(<span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromInt</span>(<span style="color:#a6e22e">totalClk</span>))
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 计算各渠道点击收益，并累加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">clkDetails</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">floatTotal</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">floatCPC</span> <span style="color:#f92672">*</span> float64(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">intTotal</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">intCPC</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">intFloatTotal</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">intFloatCPC</span> <span style="color:#f92672">*</span> float64(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">decimalTotal</span> = <span style="color:#a6e22e">decimalTotal</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">decimalCPC</span>.<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromInt</span>(<span style="color:#a6e22e">c</span>)))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 累加结果对比
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">floatTotal</span>) <span style="color:#75715e">// 7.11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">intTotal</span>) <span style="color:#75715e">// 710992893
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">decimal</span>.<span style="color:#a6e22e">NewFromFloat</span>(<span style="color:#a6e22e">intFloatTotal</span>).<span style="color:#a6e22e">IntPart</span>()) <span style="color:#75715e">// 711000000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">decimalTotal</span>.<span style="color:#a6e22e">InexactFloat64</span>()) <span style="color:#75715e">// 7.1100000000002375
</span></span></span></code></pre></div><p>对比上面的计算结果，只有第二种精度最低，而造成该精度丢失的主要原因是<code>float2Int(fee / float64(totalClk))</code>将中间计算结果的精度也只保留了<code>8</code>位，因此在结果上面产生了误差。其他计算方式在中间计算过程中尽可能的保留了精度因此结果符合预期。</p>
<h2 id="除法和减法的结合">除法和减法的结合</h2>
<p>根据前面的描述，在计算除法的过程中要使用浮点数且尽可能保留更多的精度。这依旧不能解决所有问题，我们看下面的例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 1元钱分给3个人，每个人分多少？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">float64</span> = float64(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span>)
</span></span></code></pre></div><p>上述代码输出结果如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4f1cb1ac8d81826e284b9a111085e239?method=download&amp;shareKey=c521e6d17a3a73ff778842e10fcd1736" alt=""></p>
<p>由计算结果知，每人分得<code>0.3333333333333333</code>元，而将每人分得的钱再次汇总时又变成了<code>1</code>元，那么
这<code>0.0000000000000001</code>元是从石头里面蹦出来的嘛！有些时候我真的搞不懂这些计算机。</p>
<p>这个结果很明显不符合人类的直觉，为了更加符合直觉我们结合减法来完成本次计算。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 1元钱分给3个人，每个人分多少？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">float64</span> = float64(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 最后一人分得的钱使用减法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">m3</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m3</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m3</span>)
</span></span></code></pre></div><p>上述代码输出结果如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8a9929dbaded2c1aa2f8e0e65eacce2?method=download&amp;shareKey=8fbef3b6e5cb8520149b4ad62c3f753c" alt=""></p>
<p>通过减法我们终于找回了那丢失的<code>0.0000000000000001</code>元。当然上面仅是老许举的一个例子，在实际的计算过程中可能需要通过<code>decimal</code>库进行减法以保证钱不凭空消失也不凭空增加。</p>
<p>以上均为老许的浅薄之见，有任何疑虑和错误请及时指出，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>注：</p>
<p>写本文时， 笔者所用go版本为: go1.16.6</p>
<p>文章中所用部分例子：https://github.com/Isites/go-coder/blob/master/money/main.go</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>终于解决了这个线上偶现的panic问题</title>
            <link>https://isites.gitlab.io/gopher/timeline/defer-sync-pool/</link>
            <pubDate>Tue, 23 Nov 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/defer-sync-pool/</guid>
            <description>不知道其他人是不是这样，反正老许最怕听到的词就是“偶现”，至于原因我不多说，懂的都懂。
下面直接看panic信息。
runtime error: invalid memory address or nil pointer dereference panic(0xbd1c80, 0x1271710) /root/.go/src/runtime/panic.go:969 +0x175 github.com/json-iterator/go.(*Stream).WriteStringWithHTMLEscaped(0xc00b0c6000, 0x0, 0x24) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/stream_str.go:227 +0x7b github.com/json-iterator/go.(*htmlEscapedStringEncoder).Encode(0x12b9250, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/config.go:263 +0x45 github.com/json-iterator/go.(*structFieldEncoder).Encode(0xc002e9c8d0, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:110 +0x78 github.com/json-iterator/go.(*structEncoder).Encode(0xc002e9c9c0, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:158 +0x3f4 github.com/json-iterator/go.(*structFieldEncoder).Encode(0xc002eac990, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:110 +0x78 github.com/json-iterator/go.(*structEncoder).Encode(0xc002eacba0, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:158 +0x3f4 github.com/json-iterator/go.(*OptionalEncoder).Encode(0xc002e9f570, 0xc006b18b38, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_optional.go:70 +0xf4 github.com/json-iterator/go.(*onePtrEncoder).Encode(0xc002e9f580, 0xc0096c4c00, 0xc00b0c6000) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect.go:219 +0x68 github.com/json-iterator/go.(*Stream).WriteVal(0xc00b0c6000, 0xb78d60, 0xc0096c4c00) /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect.go:98 +0x150 github.com/json-iterator/go.(*frozenConfig).Marshal(0xc00012c640, 0xb78d60, 0xc0096c4c00, 0x0, 0x0, 0x0, 0x0, 0x0) 首先我坚信一条，开源的力量值得信赖。因此老许第一波操作就是，分析业务代码是否有逻辑漏洞。很明显，同事也是值得信赖的，因此果断猜测是某些未曾设想到的数据触发了边界条件。接下来就是保存现场的常规操作。
如标题所说，这是偶现的panic问题，因此按照上面的分类采用符合当前技术栈的方法保存现场即可。接下来就是坐等收获的季节，而这一等就是好多天。中间数次收到告警，却没有符合预期的现场。</description>
            <content type="html"><![CDATA[<p>不知道其他人是不是这样，反正老许最怕听到的词就是“偶现”，至于原因我不多说，懂的都懂。</p>
<p>下面直接看<code>panic</code>信息。</p>
<pre tabindex="0"><code>runtime error: invalid memory address or nil pointer dereference

panic(0xbd1c80, 0x1271710)
        /root/.go/src/runtime/panic.go:969 +0x175
github.com/json-iterator/go.(*Stream).WriteStringWithHTMLEscaped(0xc00b0c6000, 0x0, 0x24)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/stream_str.go:227 +0x7b
github.com/json-iterator/go.(*htmlEscapedStringEncoder).Encode(0x12b9250, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/config.go:263 +0x45
github.com/json-iterator/go.(*structFieldEncoder).Encode(0xc002e9c8d0, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:110 +0x78
github.com/json-iterator/go.(*structEncoder).Encode(0xc002e9c9c0, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:158 +0x3f4
github.com/json-iterator/go.(*structFieldEncoder).Encode(0xc002eac990, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:110 +0x78
github.com/json-iterator/go.(*structEncoder).Encode(0xc002eacba0, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_struct_encoder.go:158 +0x3f4
github.com/json-iterator/go.(*OptionalEncoder).Encode(0xc002e9f570, 0xc006b18b38, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect_optional.go:70 +0xf4
github.com/json-iterator/go.(*onePtrEncoder).Encode(0xc002e9f580, 0xc0096c4c00, 0xc00b0c6000)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect.go:219 +0x68
github.com/json-iterator/go.(*Stream).WriteVal(0xc00b0c6000, 0xb78d60, 0xc0096c4c00)
        /go/pkg/mod/github.com/json-iterator/go@v1.1.11/reflect.go:98 +0x150
github.com/json-iterator/go.(*frozenConfig).Marshal(0xc00012c640, 0xb78d60, 0xc0096c4c00, 0x0, 0x0, 0x0, 0x0, 0x0)
</code></pre><p>首先我坚信一条，开源的力量值得信赖。因此老许第一波操作就是，分析业务代码是否有逻辑漏洞。很明显，同事也是值得信赖的，因此果断猜测是某些未曾设想到的数据触发了边界条件。接下来就是保存现场的常规操作。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB55378a70dcf723b1617068ca71946b42?method=download&amp;shareKey=8271f11fe3137da9849495f3fe9f899e" alt=""></p>
<p>如标题所说，这是偶现的panic问题，因此按照上面的分类采用符合当前技术栈的方法保存现场即可。接下来就是坐等收获的季节，而这一等就是好多天。中间数次收到告警，却没有符合预期的现场。</p>
<p>这个时候我不仅不慌，甚至还有点小激动。某某曾曰：“要敢于质疑，敢于挑战权威”，一念至此便一发不可收拾，我老许又要为开源事业做出贡献了嘛！说干就敢干，怀着小心思开始阅读<code>json-iterator</code>的源码。</p>
<p>刚开始研读我便明白了一个道理， “当上帝关了这扇门，一定会为你打开另一扇门”这句话是骗人的。老许只觉得上帝不仅关上了所有的门甚至还关上了所有的窗。下面我们看看他到底是怎么关门的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">cfg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">frozenConfig</span>) <span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stream</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cfg</span>.<span style="color:#a6e22e">BorrowStream</span>(<span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cfg</span>.<span style="color:#a6e22e">ReturnStream</span>(<span style="color:#a6e22e">stream</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stream</span>.<span style="color:#a6e22e">WriteVal</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">stream</span>.<span style="color:#a6e22e">Error</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">stream</span>.<span style="color:#a6e22e">Error</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">stream</span>.<span style="color:#a6e22e">Buffer</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">copied</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, len(<span style="color:#a6e22e">result</span>))
</span></span><span style="display:flex;"><span>	copy(<span style="color:#a6e22e">copied</span>, <span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">copied</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// WriteVal copy the go interface into underlying JSON, same as json.Marshal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">stream</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Stream</span>) <span style="color:#a6e22e">WriteVal</span>(<span style="color:#a6e22e">val</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">val</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">stream</span>.<span style="color:#a6e22e">WriteNil</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 省略其他代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>根据panic栈知道是因为空指针造成了panic，而<code>(*frozenConfig).Marshal</code>函数内部已经做了非空判断。到此，老许真的已经别无他法只得战略性放弃解决此次panic。毕竟，这个影响也没那么大，而且程序员哪有修的完的bug呢。经过这样一番安慰，心里确实容易接受多了。</p>
<p>事实上，在较长一段时间内我都有意识地忽略这个问题，毕竟没有找到问题的根因。这个问题在线上一直持续到一个说不上来什么日子的日子，总而言之就是兴致来了，我再次看了两眼，而这两眼很关键！</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doReq</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">req</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">paramsPool</span>.<span style="color:#a6e22e">Get</span>().(<span style="color:#f92672">*</span><span style="color:#a6e22e">model</span>.<span style="color:#a6e22e">Params</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// defer 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    	<span style="color:#a6e22e">reqBytes</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span>    	<span style="color:#75715e">// 省略其他打印日志的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// defer 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">paramsPool</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// req初始化以及发起请求和其他操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><blockquote>
<p><strong>注：</strong></p>
<ol>
<li>上述代码变量命名已经被老许通用化处理。</li>
<li>项目中实际代码远比上述复杂，但上述代码依旧是造成本次问题的最小原型。</li>
</ol>
</blockquote>
<p>上面代码中<code>paramsPool</code>是<code>sync.Pool</code>类型的变量，而<code>sync.Pool</code>想必大家都很熟悉。<code>sync.Pool</code>是为了复用已经使用过的对象(协程安全)，减少内存分配和降低GC压力。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Pool</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">New</span>: <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">Get</span>().(<span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">t</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">Get</span>().(<span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sp</span>.<span style="color:#a6e22e">Get</span>().(<span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">t1</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">t2</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img src="https://note.youdao.com/yws/api/personal/file/WEB30a2f5c4b11b2974a9dacfaa7afc06a8?method=download&amp;shareKey=c81b700ce8b721b4d27062c5f07ef4e3" alt=""></p>
<p>根据上述代码和输出结果知，<code>t1</code>变量和<code>t</code>变量地址一致，因此他们是复用对象。此时再回顾上面的<code>doReq</code>函数就很容易发现问题的根因。</p>
<p><code>defer 2</code>和<code>defer 1</code>顺序反了！！！</p>
<p><code>defer 2</code>和<code>defer 1</code>顺序反了！！！</p>
<p><code>defer 2</code>和<code>defer 1</code>顺序反了！！！</p>
<p><code>sync.Pool</code>提供的<code>Get</code>和<code>Put</code>方法是协程安全的，但是高并发调用<code>doReq</code>函数时<code>json.Marshal(req)</code>和请求初始化会存在并发问题，极有可能引起panic的并发调用时间线如下图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBab9220ec9c5c75ac59489fd69039e269?method=download&amp;shareKey=e962344375d221450b80e4b1d6306aec" alt=""></p>
<p>既然已经找到原因，解决起来就容易多了，只需调整<code>defer 2</code>和<code>defer 1</code>的调用顺序即可。老许将修改后的代码发布到线上后也确实再没有出现panic。造成这次事故的根本原因是一个微乎其微的细节，所以我们平时在开发中还是要谨慎加谨慎，避免因为这种小白错误造成不可挽回的损失。另外一个经验之谈就是，开发和查问题时尽量不要钻牛角尖，适当的停顿可能会有意想不到的奇效。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>浅谈在线广告分配策略</title>
            <link>https://isites.gitlab.io/gopher/timeline/ad-msvv/</link>
            <pubDate>Sat, 30 Oct 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/ad-msvv/</guid>
            <description>在线广告，也称网络广告、互联网广告，顾名思义，指的是在线媒体上投放的广告。平时我们在刷信息流、短视频、新闻和微博均可以看见它的影子。对于比较大的广告平台，用户定向后依旧会有大量的广告可以下发，而从大量的广告中选择合适的广告展现给用户就是本篇要讨论的主题——在线广告分配策略。
名词描述 为了更好的理解本文，先提前做一些名词描述。
eCPM(Effective Cost Per Mille): 指的是每一千次展示可以获得的广告收入。此指标反映盈利能力，不代表实际收入。不同的广告主会选择CPC、CPM等不同出价方式，因此广告分配时无法以纯粹的出价进行比较，所以才有了ecpm这一指标用于评估不同出价方式的广告可以给广告平台带来的收益。
定向广告：所谓&amp;quot;定向&amp;quot;实际上是对受众的筛选，即广告的显示是根据访问者来决定的，先进的广告管理系统 能够提供多种多样的定向方式。
最好的一定合适嘛 对于广告平台而言收益最大化是优先事项。为了保证收益最大化，对于每一次广告请求我们都选择ecpm最高的广告下发。这个逻辑从理论上来看是正确的，但在实际中就不一定了，那么它到底会有什么问题呢？
 ⼴告消耗超预算限额。 广告预算消耗不尽。 空结果问题。 部分广告消耗过快影响广告主投放体验和用户产品体验。  问题分析 问题1
对问题1进行分析时，我们需要先有这样一个共识，广告的点击、曝光等数据上报有一定的延时。
由于广告分配策略未考虑预算消耗信息，当消耗接近预算限额时未能及时减缓曝光速度，导致本应分配给其他广告主的流量依旧分配给了预算受限的广告主，这是对广告平台流量的浪费（流量越大的平台浪费会愈加严重）。
问题2
部分中小广告主竞争力弱(出价低)，很难获取足够的曝光量，这种情形当广告充裕时尤为明显。
问题3
一方面可能是因为广告资源不足，另外一方面也有可能是定向广告消耗过快(详见下面的例子)。
问题4
广告按照ecpm排序，会导致广告消耗速度差异较大直接影响广告主的投放体验，甚至于用户反复看到重复的广告直接影响用户产品体验，再反过来影响到广告的CVR。
为了进一步说明纯按价高者得这一算法的不足之处，请看下面的特殊例子。
   广告 出价($) 预算($) 定向     A 0.5 100 男,游戏   B 1 100 男,游戏,运动    以上述广告为例，现有男,游戏和男,运动请求各100。理想最大收益为150$，但是按照上述策略分配广告时，会出现男,游戏这100请求先到达时优先消耗B广告，男,运动这100请求达到时无广告可消耗。按照ecpm排序的算法又称为Greedy算法，该算法会让高价值广告快速消耗。
合适的才是最好的 Balance算法 与Greedy算法不同的是，Kalyanasundaram和Pruhs提出的Balance算法忽略单个bidder的出价，尽可能平衡所有bidder的预算消耗，使得其在线时间尽可能⻓，即尽量使得所有⼴告都保持匀速投放。其算法描述如下：
当一个满足一些定向广告的请求到达时： if 广告预算消耗完 { continue } else { 选择一个（消耗/预算）值最小的一个广告 } 相比贪心算法，Balance算法平衡所有广告的消耗速度，能够有效解决贪心算法广告快速消耗的问题，但在广告消耗不尽的问题上依旧不是最佳解决方案。我们看下面特殊例子：
   广告 出价($) 预算($) 定向     A 1 100 男,游戏   B 0.</description>
            <content type="html"><![CDATA[<p>在线广告，也称网络广告、互联网广告，顾名思义，指的是在线媒体上投放的广告。平时我们在刷信息流、短视频、新闻和微博均可以看见它的影子。对于比较大的广告平台，用户定向后依旧会有大量的广告可以下发，而从大量的广告中选择合适的广告展现给用户就是本篇要讨论的主题——在线广告分配策略。</p>
<h2 id="名词描述">名词描述</h2>
<p>为了更好的理解本文，先提前做一些名词描述。</p>
<p><code>eCPM(Effective Cost Per Mille)</code>: 指的是每一千次展示可以获得的广告收入。此指标反映盈利能力，不代表实际收入。不同的广告主会选择CPC、CPM等不同出价方式，因此广告分配时无法以纯粹的出价进行比较，所以才有了<code>ecpm</code>这一指标用于评估不同出价方式的广告可以给广告平台带来的收益。</p>
<p><code>定向广告</code>：所谓&quot;定向&quot;实际上是对受众的筛选，即广告的显示是根据访问者来决定的，先进的广告管理系统 能够提供多种多样的定向方式。</p>
<h2 id="最好的一定合适嘛">最好的一定合适嘛</h2>
<p>对于广告平台而言收益最大化是优先事项。为了保证收益最大化，对于每一次广告请求我们都选择ecpm最高的广告下发。这个逻辑从理论上来看是正确的，但在实际中就不一定了，那么它到底会有什么问题呢？</p>
<ol>
<li>⼴告消耗超预算限额。</li>
<li>广告预算消耗不尽。</li>
<li>空结果问题。</li>
<li>部分广告消耗过快影响广告主投放体验和用户产品体验。</li>
</ol>
<h3 id="问题分析">问题分析</h3>
<p><strong>问题1</strong></p>
<p>对问题1进行分析时，我们需要先有这样一个共识，广告的点击、曝光等数据上报有一定的延时。</p>
<p>由于广告分配策略未考虑预算消耗信息，当消耗接近预算限额时未能及时减缓曝光速度，导致本应分配给其他广告主的流量依旧分配给了预算受限的广告主，这是对广告平台流量的浪费（流量越大的平台浪费会愈加严重）。</p>
<p><strong>问题2</strong></p>
<p>部分中小广告主竞争力弱(出价低)，很难获取足够的曝光量，这种情形当广告充裕时尤为明显。</p>
<p><strong>问题3</strong></p>
<p>一方面可能是因为广告资源不足，另外一方面也有可能是定向广告消耗过快(详见下面的例子)。</p>
<p><strong>问题4</strong></p>
<p>广告按照ecpm排序，会导致广告消耗速度差异较大直接影响广告主的投放体验，甚至于用户反复看到重复的广告直接影响用户产品体验，再反过来影响到广告的CVR。</p>
<p>为了进一步说明纯按价高者得这一算法的不足之处，请看下面的特殊例子。</p>
<table>
<thead>
<tr>
<th style="text-align:left">广告</th>
<th style="text-align:left">出价($)</th>
<th style="text-align:left">预算($)</th>
<th style="text-align:left">定向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">0.5</td>
<td style="text-align:left">100</td>
<td style="text-align:left">男,游戏</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">1</td>
<td style="text-align:left">100</td>
<td style="text-align:left">男,游戏,运动</td>
</tr>
</tbody>
</table>
<p>以上述广告为例，现有<code>男,游戏</code>和<code>男,运动</code>请求各100。理想最大收益为<code>150$</code>，但是按照上述策略分配广告时，会出现<code>男,游戏</code>这100请求先到达时优先消耗B广告，<code>男,运动</code>这100请求达到时无广告可消耗。按照ecpm排序的算法又称为Greedy算法，该算法会让高价值广告快速消耗。</p>
<h2 id="合适的才是最好的">合适的才是最好的</h2>
<h3 id="balance算法">Balance算法</h3>
<p>与Greedy算法不同的是，Kalyanasundaram和Pruhs提出的Balance算法忽略单个bidder的出价，尽可能平衡所有bidder的预算消耗，使得其在线时间尽可能⻓，即尽量使得所有⼴告都保持匀速投放。其算法描述如下：</p>
<pre tabindex="0"><code>当一个满足一些定向广告的请求到达时：
if 广告预算消耗完 {
    continue
} else {
    选择一个（消耗/预算）值最小的一个广告
}
</code></pre><p>相比贪心算法，Balance算法平衡所有广告的消耗速度，能够有效解决贪心算法广告快速消耗的问题，但在广告消耗不尽的问题上依旧不是最佳解决方案。我们看下面特殊例子：</p>
<table>
<thead>
<tr>
<th style="text-align:left">广告</th>
<th style="text-align:left">出价($)</th>
<th style="text-align:left">预算($)</th>
<th style="text-align:left">定向</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">1</td>
<td style="text-align:left">100</td>
<td style="text-align:left">男,游戏</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">0.01</td>
<td style="text-align:left">100</td>
<td style="text-align:left">男,游戏,运动</td>
</tr>
</tbody>
</table>
<p>以上述广告为例，现有<code>男,游戏</code>和<code>男,运动</code>请求各100。理想对最大收益为<code>110$</code>，根据balance算法其总的预算消耗仅为几美元。当<code>男,游戏</code>这100请求先到达时，B广告一定会先消耗完，当<code>男,运动</code>100请求到达时依旧会无广告可消耗。</p>
<p>那Balance算法适用场景到底是什么，下面我们以极限法来考虑这个问题。</p>
<p><strong>假设一</strong>：如果广告A和广告B的出价分别为1000$和1$(CPC)</p>
<p>很明显，广告A具有更大的优势理应优先展示。根据前面的例子，Balance算法是无法解决这种极值场景的，而Greedy算法则充分兼顾了平台的利益以及广告主急切花钱的心情。</p>
<p><strong>假设二</strong>：如果所有广告出价分别为10$(CPC)</p>
<p>Greedy算法是和出价有关的，而Balance算法仅和预算有关。根据控制变量法很容易知道Balance算法正是为了这种场景而生。</p>
<p><strong>小结</strong>：根据前面的假设以及论文中的描述我们总结如下结论：</p>
<ul>
<li>Balance算法更适用于广告出价比较接近的场景</li>
<li>Greedy算法则比较适用于广告出价差异比较大的场景</li>
</ul>
<h3 id="msvv算法">MSVV算法</h3>
<p>只有小孩子才做选做题，我们成年人全都要。Balance算法和Greedy算法各有优劣且适用场景不同，那有没有算法能够融合两者的优点呢？这正式MSVV算法的思路。</p>
<p>为了更清楚描述新算法，先给出一些基本定义：</p>
<ul>
<li>消耗比例：<code>'消耗/总预算'</code>并记作 <code>$\upsilon$</code>。总预算由广告主设置，并且可动态调整。</li>
<li>权衡函数：<code>$\Psi(\upsilon) = 1 - e^{(\upsilon-1)}$</code></li>
<li>缩放出价：<code>$出价 * \Psi(\upsilon)$</code></li>
</ul>
<p>算法描述如下：</p>
<pre tabindex="0"><code>当一个满足一些定向广告的请求到达时：
if 广告预算消耗完 {
    continue
} else {
    选择一个`缩放出价`值最大的广告
}
</code></pre><p>上述的权衡函数为一个单调下降的函数，且<code>$\upsilon$</code>取值范围为[0,1]。权衡函数分布图如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8bb2b7ed66ccf56a83ea30e5691bd87d?method=download&amp;shareKey=4af409d9a077a10f90e7b10d4a4d04b4" alt=""></p>
<p>当所有广告出价相等时，由于权衡函数是一个单调下降的函数，因此MSVV算法就正好退化成Balance算法。另一方面，如果出价差异非常大时，MSVV算法在大多数情况都不会改变出价的顺序，此时MSVV表现更接近Greedy算法。考虑更极端的情况，当所有广告预算都是无限时，MSVV算法直接退化为Greedy算法，因为此时权衡函数为常量<code>$1 - {\frac 1 e}$</code>。</p>
<p>为了验证MSVV算法的适应性，我们看下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ad</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cost</span>  <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">total</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">price</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">scaled</span>(<span style="color:#a6e22e">price</span>, <span style="color:#a6e22e">cost</span>, <span style="color:#a6e22e">total</span> <span style="color:#66d9ef">float64</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">price</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1.0</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">E</span>, <span style="color:#a6e22e">cost</span><span style="color:#f92672">/</span><span style="color:#a6e22e">total</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ad</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ad</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">0.01</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 模拟`男,游戏`到达时，a和b同时消耗
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">aCp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scaled</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">price</span>, <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">cost</span>, <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">total</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bCp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scaled</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">price</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">total</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">total</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">total</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">aCp</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">bCp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">price</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">price</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 模拟`男,运动`到达时，仅b可消耗
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">total</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">price</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">cost</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cost</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>MSVV算法在前面的极值例子中收益分别为<code>116.5</code>和<code>101</code>，其整体表现基本符合预期。</p>
<h2 id="总结">总结</h2>
<p>现在回顾前面的问题，消耗过快以及减缓曝光速度都在Balance算法的射程内（广告资源不足只有通过其他手段解决了）。从广告平台的收益角度考虑Greedy算法更佳。那么结合两者优点的MSVV算法可谓是每个广告平台居家旅行之必备利器。</p>
<p>在线广告老许也是初次接触，而且正在努力储备知识，以期日后可持续发展。如果文中有不正确的地方欢迎各位读者指正和交流。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>URL中的空格、加号究竟应该使用何种方式编码</title>
            <link>https://isites.gitlab.io/gopher/timeline/http-url/</link>
            <pubDate>Sun, 10 Oct 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/http-url/</guid>
            <description>URL中不能显示地包含空格这已经是一个共识，而空格以何种形式存在，在不同的标准中又不完全一致，以致于不同的语言也有了不同的实现。
rfc2396中明确表示空格应该被编码为%20。
而W3C的标准中却又说空格可以被替换为+或者%20。
老许当场懵逼，空格被替换为+，那+本身只能被编码。既然如此，为什么不直接对空格进行编码呢。当然这只是老许心中的疑惑，以前的背景我们已经无法追溯，已成的事实我们也无法改变。但，空格到底是被替换为+还是20%，+是否需要被编码都是现在的我们需要直面的问题。
Go常用的三种URL编码方式 作为Gopher最先关注的自然是Go语言本身的实现，因此我们首先了解一下Go中常用的三种URL编码方式的异同。
url.QueryEscape fmt.Println(url.QueryEscape(&amp;#34; +Gopher指北&amp;#34;)) // 输出：+%2BGopher%E6%8C%87%E5%8C%97 使用url.QueryEscape编码时，空格被编码为+，而+本身被编码为%2B。
url.PathEscape fmt.Println(url.PathEscape(&amp;#34; +Gopher指北&amp;#34;)) // 输出：%20+Gopher%E6%8C%87%E5%8C%97 使用url.PathEscape编码时，空格被编码为20%, 而+则未被编码。
url.Values var query = url.Values{} query.Set(&amp;#34;hygz&amp;#34;, &amp;#34; +Gopher指北&amp;#34;) fmt.Println(query.Encode()) // 输出：hygz=+%2BGopher%E6%8C%87%E5%8C%97 使用(Values).Encode方法编码时，空格被编码为+，而+本身被编码为%2B，进一步查看(Values).Encode方法的源码知其内部仍旧调用url.QueryEscape函数。而(Values).Encode方法和url.QueryEscape的区别在于前者仅编码query中的key和value，后者会对=、&amp;amp;均进行编码。
对我们开发者而言，这三种编码方式到底应该使用哪一种，请继续阅读后文相信你可以在后面的文章中找到答案。
不同语言中的实现 既然空格和+在Go中的URL编码方式有不同的实现，那在其他语言中是否也存在这样的情况呢，下面以PHP和JS为例。
PHP中的URL编码 urlencode
echo urlencode(&amp;#39; +Gopher指北&amp;#39;); // 输出：+%2BGopher%E6%8C%87%E5%8C%97 rawurlencode
echo rawurlencode(&amp;#34; +Gopher指北&amp;#34;); // 输出：%20%2BGopher%E6%8C%87%E5%8C%97 PHP的urlencode和Go的url.QueryEscape函数效果一致，而rawurlencode则将空格和+均进行编码。
JS中的URL编码 encodeURI
encodeURI(&amp;#39; +Gopher指北&amp;#39;) // 输出：%20+Gopher%E6%8C%87%E5%8C%97 encodeURIComponent
encodeURIComponent(&amp;#39; +Gopher指北&amp;#39;) // 输出：%20%2BGopher%E6%8C%87%E5%8C%97 JS的encodeURI和Go的url.PathEscape函数效果一致，而encodeURIComponent则将空格和+均进行编码。
我们应该怎么做 更推荐使用url.PathEscape函数编码 在前文中已经总结了Go、PHP和JS对 +Gopher指北的编码操作，下面总结一下其对应的解码操作是否可行的二维表。
   编码/解码 url.QueryUnescape url.PathUnescape urldecode rawurldecode decodeURI decodeURIComponent     url.</description>
            <content type="html"><![CDATA[<p>URL中不能显示地包含空格这已经是一个共识，而空格以何种形式存在，在不同的标准中又不完全一致，以致于不同的语言也有了不同的实现。</p>
<p><code>rfc2396</code>中明确表示空格应该被编码为<code>%20</code>。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBaa22f5efec41ec872796c23371f784ac?method=download&amp;shareKey=38a9fcb1344fcd1db67962dca0d5f5c7" alt=""></p>
<p>而W3C的标准中却又说空格可以被替换为<code>+</code>或者<code>%20</code>。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB940ba3ff5f42c0b5fe91a08aafd9e20d?method=download&amp;shareKey=68e4496f0ceab247e709bfe1d1a116b1" alt=""></p>
<p>老许当场懵逼，空格被替换为<code>+</code>，那<code>+</code>本身只能被编码。既然如此，为什么不直接对空格进行编码呢。当然这只是老许心中的疑惑，以前的背景我们已经无法追溯，已成的事实我们也无法改变。但，空格到底是被替换为<code>+</code>还是<code>20%</code>，<code>+</code>是否需要被编码都是现在的我们需要直面的问题。</p>
<h1 id="go常用的三种url编码方式">Go常用的三种URL编码方式</h1>
<p>作为Gopher最先关注的自然是Go语言本身的实现，因此我们首先了解一下Go中常用的三种URL编码方式的异同。</p>
<h2 id="urlqueryescape">url.QueryEscape</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">QueryEscape</span>(<span style="color:#e6db74">&#34; +Gopher指北&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：+%2BGopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p>使用<code>url.QueryEscape</code>编码时，空格被编码为<code>+</code>，而<code>+</code>本身被编码为<code>%2B</code>。</p>
<h2 id="urlpathescape">url.PathEscape</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">PathEscape</span>(<span style="color:#e6db74">&#34; +Gopher指北&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：%20+Gopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p>使用<code>url.PathEscape</code>编码时，空格被编码为<code>20%</code>, 而<code>+</code>则未被编码。</p>
<h2 id="urlvalues">url.Values</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">query</span> = <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">Values</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#e6db74">&#34;hygz&#34;</span>, <span style="color:#e6db74">&#34; +Gopher指北&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">query</span>.<span style="color:#a6e22e">Encode</span>())
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：hygz=+%2BGopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p>使用<code>(Values).Encode</code>方法编码时，空格被编码为<code>+</code>，而<code>+</code>本身被编码为<code>%2B</code>，进一步查看<code>(Values).Encode</code>方法的源码知其内部仍旧调用<code>url.QueryEscape</code>函数。而<code>(Values).Encode</code>方法和<code>url.QueryEscape</code>的区别在于前者仅编码query中的key和value，后者会对<code>=</code>、<code>&amp;</code>均进行编码。</p>
<p>对我们开发者而言，这三种编码方式到底应该使用哪一种，请继续阅读后文相信你可以在后面的文章中找到答案。</p>
<h1 id="不同语言中的实现">不同语言中的实现</h1>
<p>既然空格和<code>+</code>在Go中的URL编码方式有不同的实现，那在其他语言中是否也存在这样的情况呢，下面以PHP和JS为例。</p>
<h2 id="php中的url编码">PHP中的URL编码</h2>
<p><strong>urlencode</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">echo</span> <span style="color:#a6e22e">urlencode</span>(<span style="color:#e6db74">&#39; +Gopher指北&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：+%2BGopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p><strong>rawurlencode</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">echo</span> <span style="color:#a6e22e">rawurlencode</span>(<span style="color:#e6db74">&#34; +Gopher指北&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：%20%2BGopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p>PHP的<code>urlencode</code>和Go的<code>url.QueryEscape</code>函数效果一致，而<code>rawurlencode</code>则将空格和<code>+</code>均进行编码。</p>
<h2 id="js中的url编码">JS中的URL编码</h2>
<p><strong>encodeURI</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>encodeURI(<span style="color:#e6db74">&#39; +Gopher指北&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：%20+Gopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p><strong>encodeURIComponent</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span>encodeURIComponent(<span style="color:#e6db74">&#39; +Gopher指北&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：%20%2BGopher%E6%8C%87%E5%8C%97
</span></span></span></code></pre></div><p>JS的<code>encodeURI</code>和Go的<code>url.PathEscape</code>函数效果一致，而<code>encodeURIComponent</code>则将空格和<code>+</code>均进行编码。</p>
<h1 id="我们应该怎么做">我们应该怎么做</h1>
<h2 id="更推荐使用urlpathescape函数编码">更推荐使用url.PathEscape函数编码</h2>
<p>在前文中已经总结了<code>Go</code>、<code>PHP</code>和<code>JS</code>对<code> +Gopher指北</code>的编码操作，下面总结一下其对应的解码操作是否可行的二维表。</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码/解码</th>
<th style="text-align:left">url.QueryUnescape</th>
<th style="text-align:left">url.PathUnescape</th>
<th style="text-align:left">urldecode</th>
<th style="text-align:left">rawurldecode</th>
<th style="text-align:left">decodeURI</th>
<th style="text-align:left">decodeURIComponent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">url.QueryEscape</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">N</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:left">url.PathEscape</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left"><em>YY</em></td>
<td style="text-align:left">Y</td>
<td style="text-align:left"><em>YY</em></td>
</tr>
<tr>
<td style="text-align:left">urlencode</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">N</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:left">rawurlencode</td>
<td style="text-align:left">Y</td>
<td style="text-align:left"><em>YY</em></td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">encodeURI</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
</tr>
<tr>
<td style="text-align:left">encodeURIComponent</td>
<td style="text-align:left">Y</td>
<td style="text-align:left"><em>YY</em></td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
<td style="text-align:left">Y</td>
</tr>
</tbody>
</table>
<p>上表中的<code>YY</code>和<code>Y</code>同含义，老许仅以<code>YY</code>表示在Go中推荐使用<code>url.PathEscape</code>进行编码，同时在PHP和JS中分别推荐使用<code>rawurldecode</code>和<code>decodeURIComponent</code>进行解码。</p>
<p>在实际的开发过程中，Gopher一定会存在需要解码的场景，此时就需要和URL编码方进行沟通以得到合适的方式解码。</p>
<h2 id="对值进行编码">对值进行编码</h2>
<p>那有没有通用的不需要URL编解码的方式呢？毫无疑问是有的！以<code>base32</code>编码为例，其编码字符集为<code>A-Z和数字2-7</code>，此时对值进行base32编码后就无需url编码了。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>本文使用环境分别为<code>PHP 7.3.29</code>、<code>go 1.16.6</code>和<code>js Chrome94.0.4606.71的Console</code></p>
</blockquote>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc2396.txt">https://www.rfc-editor.org/rfc/rfc2396.txt</a></li>
<li><a href="https://www.w3schools.com/tags/ref_urlencode.ASP">https://www.w3schools.com/tags/ref_urlencode.ASP</a></li>
</ul>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>sync.Once化作一道光让我顿悟</title>
            <link>https://isites.gitlab.io/gopher/timeline/sync-once/</link>
            <pubDate>Mon, 20 Sep 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/sync-once/</guid>
            <description>前几天和公司同事吃饭直接社死，同事直言我写的文章很骚。
他们怎么知道我在写公众号！
我tm没在公众号里写什么奇奇怪怪的东西吧！
求求不要让公司更多同事知道这件事了！
大地为什么还没有裂开一条缝&amp;hellip;
当时的心情历历在目，而老许此刻写下的文字却是另外一种想法。肤浅！简直太肤浅了！不要只浮于文字本身的魅力，请多关注老许分享的知识点（手动狗头）。另外一方面，老许觉得他们通过文章对我的认知有违我在公司树立的老实本分人设，但请不要奇怪也不要声张，毕竟我就是大部分程序员的缩影——“沉默寡言，心有一片海”。
我们高中物理老师常说，透过现象看本质，所以形式不重要，重要的是我想分享什么。这还要从一段有并发问题的代码说起（下面为公司部分源码简化后的模拟例子）。
type test struct { 	fff string }  var resource *test  func doSomething() error {  if test == nil {  n, e := rand.Int(rand.Reader, big.NewInt(3))  // 通过随机数模拟发生错误 	if e != nil || n.Int64() &amp;gt; 0 { 	retur fmt.Errorf(&amp;#34;random [%w] err(%d)&amp;#34;, e, n.Int64()) 	} 	// 未发生错误，则赋值 	resource = &amp;amp;test{&amp;#34;关注公众号：Gopher指北&amp;#34;}  }  // do something  return nil } 老许微微一笑，这道题我会，反手利用sync.</description>
            <content type="html"><![CDATA[<p>前几天和公司同事吃饭直接社死，同事直言我写的文章很骚。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB42049ac1e6f622a5c4f922a8d281b50b?method=download&amp;shareKey=03ed8c0a8c01be952c3be942bc6a562e" alt=""></p>
<p>他们怎么知道我在写公众号！</p>
<p>我tm没在公众号里写什么奇奇怪怪的东西吧！</p>
<p>求求不要让公司更多同事知道这件事了！</p>
<p>大地为什么还没有裂开一条缝&hellip;</p>
<p>当时的心情历历在目，而老许此刻写下的文字却是另外一种想法。肤浅！简直太肤浅了！不要只浮于文字本身的魅力，请多关注老许分享的知识点（手动狗头）。另外一方面，老许觉得他们通过文章对我的认知有违我在公司树立的老实本分人设，但请不要奇怪也不要声张，毕竟我就是大部分程序员的缩影——“沉默寡言，心有一片海”。</p>
<p>我们高中物理老师常说，透过现象看本质，所以形式不重要，重要的是我想分享什么。这还要从一段有并发问题的代码说起（下面为公司部分源码简化后的模拟例子）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">test</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fff</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">resource</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">test</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">NewInt</span>(<span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 通过随机数模拟发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		    <span style="color:#a6e22e">retur</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;random [%w] err(%d)&#34;</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>())
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 未发生错误，则赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">resource</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">test</span>{<span style="color:#e6db74">&#34;关注公众号：Gopher指北&#34;</span>}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>老许微微一笑，这道题我会，反手利用<code>sync.Once</code>一顿改造。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">resource</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">loadOnce</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">loadOnce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">NewInt</span>(<span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 通过随机数模拟发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;random [%w] err(%d)&#34;</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 未发生错误，则赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">resource</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">test</span>{<span style="color:#e6db74">&#34;关注公众号：Gopher指北&#34;</span>}
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果因为某些原因导致初始化失败，则重新赋值以便可以重入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">loadOnce</span> = <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>{}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// double check
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">resource</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;assign failed&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>写下这段代码时，老许一顿沾沾自喜：</p>
<ul>
<li>
<p><code>sync.Once</code>底层通过<code>defer</code>标记初始化完成，所以无论初始化是否成功都会标记初始化完成，即不可重入。上面的代码老许通过重新赋值的方式保证<code>sync.Once</code>可重入。</p>
</li>
<li>
<p><code>G1</code>和<code>G2</code>同时执行时，<code>G1</code>执行失败后，<code>G2</code>不会执行初始化逻辑，因此需要<code>double check</code>。</p>
</li>
</ul>
<p>不知道你们有没有经历过，很多时候在一个问题上思考良久，还不如去上一次厕所突然得到的方案来的巧妙。本次依旧如此，在改造完这段代码的当晚躺在床上休息时，脑中灵光一闪，有问题！</p>
<ul>
<li>
<p><code>sync.Once</code>通过赋值新变量的方式保证可重入，但也正因为如此<code>loadOnce</code>存在同时读写的并发问题，而且<code>sync.Once</code>内部使用<code>Mutex</code>不能复制。</p>
</li>
<li>
<p><code>double check</code>部分的逻辑和初始化的复制逻辑存在读写并发问题。</p>
</li>
</ul>
<p>夜深人静思考时，就是这一次犯错，也是这一次灵光一闪，让我思考良多，关于思考的内容稍后缓缓到来。</p>
<p>知道了问题和目标解决起来就容易多了。</p>
<p><strong>可重入且并发安全的sync.Once</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 基本结构和官方sync.Once完全一致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IOnce</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>    <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Do方法传递的函数增加一个error返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">IOnce</span>) <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadUint32</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">done</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">doSlow</span>(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不使用defer控制don标识，而通过也无妨的返回值来控制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">IOnce</span>) <span style="color:#a6e22e">doSlow</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">f</span>() <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 执行成功后才将done置为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">StoreUint32</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">done</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>最终版代码</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">resource</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ionce</span> <span style="color:#a6e22e">IOnce</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ionce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Int</span>(<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Reader</span>, <span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">NewInt</span>(<span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 通过随机数模拟发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>() &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;random [%w] err(%d)&#34;</span>, <span style="color:#a6e22e">e</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Int64</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">resource</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">test</span>{<span style="color:#e6db74">&#34;关注公众号：Gopher指北&#34;</span>}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// do something
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其实不只老许魔改过<code>sync.Once</code>，老许还在github上面看到过另一个魔改版本（很遗憾现在已经不记得是哪个仓库了无法贴出地址）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">o</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Once</span>) <span style="color:#a6e22e">doSlow</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">done</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>	    <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">StoreUint32</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">done</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">f</span>() 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>和官方实现的版本相比，仅仅是将<code>defer atomic.StoreUint32(&amp;o.done, 1)</code>修改为<code>atomic.StoreUint32(&amp;o.done, 1)</code>，老许推测此实现是想尽可能早的返回，避免锁的竞争，但是目前尚未发现适用场景所以记忆深刻。</p>
<p>前面内容并不复杂，但它确确实实给老许提了个醒，让老许有了下面一段感悟。</p>
<p>回成都之后深刻感受到了这个新一线城市的忙碌，很多时候都是时间紧任务重，而我受周围氛围和环境的影响渐渐丢失了一份&quot;不急不缓，不骄不躁，回归本心&quot;的态度。有位读者曾经告诉我“世界那么大，你才看到多少”。当老许看到这个留言时犹如当头棒喝，余生那么长，世界那么大，我们有什么好着急的又何须给自己那么大的压力（再次感谢这位读者～）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf21418759ed0be65e748ee41f3ca9d11?method=download&amp;shareKey=26d3e2d6de1dcdce4c6c1f5b5672731a" alt=""></p>
<p>人都容易受周围环境的影响，我也不例外，明明之前已经下定决心兼顾生活和工作缓步前行。以这次<code>sync.Once</code>事件为例，如果我能稍微思考一下也许就不会出现本不该出现的失误。对我们做技术的人来说，学习是一场长达一生的持久战，有的人行的快，有的人行的慢，坚持且松弛有度，不骄不躁，多思考才是我们能够走的远走的久的根本。</p>
<p>步子迈的太大，容易扯到蛋，步子迈的太快，灵魂容易跟不上。老许只希望自己在接下来的生活、学习和工作中戒骄戒燥放缓脚步坚定前行，至少一定要带着脑子工作和生活，不要让繁重的事务挤掉了思考的时间。</p>
<blockquote>
<p>这是一篇参杂少量知识点的技术人感悟水文，希望老许对自己的反思能够帮到各位读者，也欢迎有兴趣的读者后台留言交流。</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>一次带宽拉满引发的百分百超时血案！</title>
            <link>https://isites.gitlab.io/gopher/timeline/net-bandwidth/</link>
            <pubDate>Sun, 05 Sep 2021 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/net-bandwidth/</guid>
            <description>偈语: 未经他人苦,莫劝他人善
鏖战两周有余，为了排查线上某接口百分百超时的原因，如今总算有些成果。虽然仍有疑虑但是碍于时间不允许和个人能力问题先做如下总结以备来日再战。
出口带宽拉满 能够发现这个问题实属侥幸。依稀记得这是一个风雨交加的夜晚，这风、这雨注定了今夜的不平凡。果然线上百分百超时的根因被发现了！
我们的线上接口需要对外请求，而我们的流出带宽被拉满自然耗时就长因此导致超时。当然这都是结果，毕竟中间过程的艰辛已经远远超出老许的文字所能描述的范围。
反思 结果有了，该有的反思仍旧不能少。比如流出带宽被拉满为什么没有提前预警！无论是自信带宽足够还是经验不足都值得老许记上一笔。
而在带宽问题被真正发现之前，老许内心对带宽其实已有所怀疑，但是却没有认真进行验证，只听信了他人的推测导致发现问题的时间被推迟。
httptrace 有时候不得不吹一波Go对http trace的良好支持。老许也是基于此做了一个demo，该demo可以打印http请求各阶段耗时。
上述为一次http请求各阶段耗时输出，有兴趣的可去https://github.com/Isites/go-coder/blob/master/httptrace/trace.go拿到源码。
 老许对带宽的怀疑主要就是基于此demo中的源码进行线上分析测试给到的推测。
 框架问题 本部分更加适合腾讯系的兄弟们去阅读，其他非腾讯系技术可以直接跳过。
我司的框架为TarsGo，我们在线上设置handletimeout为1500ms，该参数主要用于控制某一接口总耗时不超过1500ms，而我们的超时告警均为3s，因此即使带宽已满这个百分百超时告警也不应出现。
为了研究这个原因，老许只好花些零碎的时间去阅读源码，最终发现了TarsGo@v1.1.6的handletimeout控制是无效的。
下面看一下有问题的源码:
func (s *TarsProtocol) InvokeTimeout(pkg []byte) []byte { 	rspPackage := requestf.ResponsePacket{} 	rspPackage.IRet = 1 	rspPackage.SResultDesc = &amp;#34;server invoke timeout&amp;#34; 	return s.rsp2Byte(&amp;amp;rspPackage) } 当某接口总执行时间超过handletimeout时，会调用InvokeTimeout方法告知client调用超时，而上述的逻辑中忽略了IRequestId的响应，这就导致client收到响应包时无法将响应包和某次的请求对应起来，从而导致客户端一直等待响应直至超时。
最终修改如下：
func (s *TarsProtocol) InvokeTimeout(pkg []byte) []byte { 	rspPackage := requestf.ResponsePacket{} 	// invoketimeout need to return IRequestId 	reqPackage := requestf.RequestPacket{} 	is := codec.</description>
            <content type="html"><![CDATA[<p><strong>偈语</strong>: 未经他人苦,莫劝他人善</p>
<p>鏖战两周有余，为了排查线上某接口百分百超时的原因，如今总算有些成果。虽然仍有疑虑但是碍于时间不允许和个人能力问题先做如下总结以备来日再战。</p>
<h1 id="出口带宽拉满">出口带宽拉满</h1>
<p>能够发现这个问题实属侥幸。依稀记得这是一个风雨交加的夜晚，这风、这雨注定了今夜的不平凡。果然线上百分百超时的根因被发现了！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd5b061984272ce237fa1e49f9090991c?method=download&amp;shareKey=097a49e398b431f0231fc25ab2b106f3" alt=""></p>
<p>我们的线上接口需要对外请求，而我们的流出带宽被拉满自然耗时就长因此导致超时。当然这都是结果，毕竟中间过程的艰辛已经远远超出老许的文字所能描述的范围。</p>
<h2 id="反思">反思</h2>
<p>结果有了，该有的反思仍旧不能少。比如流出带宽被拉满为什么没有提前预警！无论是自信带宽足够还是经验不足都值得老许记上一笔。</p>
<p>而在带宽问题被真正发现之前，老许内心对带宽其实已有所怀疑，但是却没有认真进行验证，只听信了他人的推测导致发现问题的时间被推迟。</p>
<h2 id="httptrace">httptrace</h2>
<p>有时候不得不吹一波Go对http trace的良好支持。老许也是基于此做了一个demo，该demo可以打印http请求各阶段耗时。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBae017d707ebfecab6294e99b2521ee75?method=download&amp;shareKey=ae68fed9224c9b0afe62d72b023f29ae" alt=""></p>
<p>上述为一次http请求各阶段耗时输出，有兴趣的可去https://github.com/Isites/go-coder/blob/master/httptrace/trace.go拿到源码。</p>
<blockquote>
<p>老许对带宽的怀疑主要就是基于此demo中的源码进行线上分析测试给到的推测。</p>
</blockquote>
<h1 id="框架问题">框架问题</h1>
<p>本部分更加适合腾讯系的兄弟们去阅读，其他非腾讯系技术可以直接跳过。</p>
<p>我司的框架为TarsGo，我们在线上设置<code>handletimeout</code>为1500ms，该参数主要用于控制某一接口总耗时不超过1500ms，而我们的超时告警均为3s，因此即使带宽已满这个百分百超时告警也不应出现。</p>
<p>为了研究这个原因，老许只好花些零碎的时间去阅读源码，最终发现了<code>TarsGo@v1.1.6</code>的<code>handletimeout</code>控制是无效的。</p>
<p>下面看一下有问题的源码:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TarsProtocol</span>) <span style="color:#a6e22e">InvokeTimeout</span>(<span style="color:#a6e22e">pkg</span> []<span style="color:#66d9ef">byte</span>) []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">requestf</span>.<span style="color:#a6e22e">ResponsePacket</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span>.<span style="color:#a6e22e">IRet</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span>.<span style="color:#a6e22e">SResultDesc</span> = <span style="color:#e6db74">&#34;server invoke timeout&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">rsp2Byte</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">rspPackage</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当某接口总执行时间超过<code>handletimeout</code>时，会调用<code>InvokeTimeout</code>方法告知client调用超时，而上述的逻辑中忽略了<code>IRequestId</code>的响应，这就导致client收到响应包时无法将响应包和某次的请求对应起来，从而导致客户端一直等待响应直至超时。</p>
<p>最终修改如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TarsProtocol</span>) <span style="color:#a6e22e">InvokeTimeout</span>(<span style="color:#a6e22e">pkg</span> []<span style="color:#66d9ef">byte</span>) []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">requestf</span>.<span style="color:#a6e22e">ResponsePacket</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//  invoketimeout need to return IRequestId
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">reqPackage</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">requestf</span>.<span style="color:#a6e22e">RequestPacket</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">is</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">codec</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">pkg</span>[<span style="color:#ae81ff">4</span>:])
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reqPackage</span>.<span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">is</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span>.<span style="color:#a6e22e">IRequestId</span> = <span style="color:#a6e22e">reqPackage</span>.<span style="color:#a6e22e">IRequestId</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span>.<span style="color:#a6e22e">IRet</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rspPackage</span>.<span style="color:#a6e22e">SResultDesc</span> = <span style="color:#e6db74">&#34;server invoke timeout&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">rsp2Byte</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">rspPackage</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>后来老许在本地用demo验证<code>handletimeout</code>终于可以控制生效。当然本次修改老许已经在github上面提交issue和pr，目前已被合入master。相关issue和pr如下：</p>
<p><a href="https://github.com/TarsCloud/TarsGo/issues/294">https://github.com/TarsCloud/TarsGo/issues/294</a></p>
<p><a href="https://github.com/TarsCloud/TarsGo/pull/295">https://github.com/TarsCloud/TarsGo/pull/295</a></p>
<h1 id="仍有疑虑">仍有疑虑</h1>
<p>到这里，事情依然没有得到完美的解决。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB72c46f05419d673285f86cec37ea4007?method=download&amp;shareKey=6df9055ae9a95a8053359ca0230a904b" alt=""></p>
<p>上图为我们对外部请求做的最大耗时统计，毛刺严重且耗时简直不符合常理。图中标红部分耗时约为881秒，而实际上我们在发起http请求时均做了严格的超时控制，这也是令老许最为头疼的问题，这几天脸上冒的痘都是为它熬夜的证明。</p>
<p>更加令人惊恐的事情是，我们将官方的<code>http</code>替换为<code>fasthttp</code>后，毛刺没有了！老许自认为对go的http源码还有几分浅薄的理解，而残酷的现实简直令人怀疑人生。</p>
<p>到目前，老许再次简阅了一遍http的源码，仍未发现问题，这大概率会成为一桩悬案了，还望各位有经验的大佬分享一二，至少让这篇文章有始有终。</p>
<blockquote>
<p>替换fasthttp时还未发现带宽被拉满</p>
</blockquote>
<h1 id="美好愿景">美好愿景</h1>
<p>最后，别无他言，直接上图！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb0b4bfb20ebd27b75169412e18e6fb30?method=download&amp;shareKey=8b7089fb9546f78e5074095ca7175a7c" alt=""></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>公司内一次分享-Go并发编程</title>
            <link>https://isites.gitlab.io/gopher/timeline/go-share/</link>
            <pubDate>Tue, 17 Aug 2021 21:00:00 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/go-share/</guid>
            <description>提到并发编程，不得不想到Go并发编程中的一句经典名言
Do not communicate by sharing memory; instead, share memory by communicating. 本次分享目标  避免Go并发编程一些常见的坑 理解为什么Go原生网络编程模型为什么这么爽  并发编程踩坑目录 优雅的代码不好定义，每位开发也有自己的风格，但是坑总是相似的。
channel误用 Case-1
func main() { 	wg := sync.WaitGroup{} 	ch := make(chan int, 10) 	for i := 0; i &amp;lt; 10; i++ { 	ch &amp;lt;- i // put task into channel 	}  	close(ch)  	wg.Add(4) 	for j := 0; j &amp;lt; 4; j++ { 	go func() { 	for { 	task := &amp;lt;-ch 	// do sth 	fmt.</description>
            <content type="html"><![CDATA[<p>提到并发编程，不得不想到Go并发编程中的一句<a href="https://blog.golang.org/codelab-share">经典名言</a></p>
<pre tabindex="0"><code>Do not communicate by sharing memory; instead, share memory by communicating.
</code></pre><h1 id="本次分享目标">本次分享目标</h1>
<ul>
<li>避免Go并发编程一些常见的坑</li>
<li>理解为什么Go原生网络编程模型为什么这么爽</li>
</ul>
<h1 id="并发编程踩坑目录">并发编程踩坑目录</h1>
<p>优雅的代码不好定义，每位开发也有自己的风格，但是坑总是相似的。</p>
<h2 id="channel误用">channel误用</h2>
<p><strong>Case-1</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#75715e">// put task into channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">4</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">task</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">task</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>2、使用for range读取，当channel关闭时，for循环会自动退出。</p>
<!-- raw HTML omitted -->
<p><strong>Case-2</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">handler</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ... ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// do sth then put result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;job result&#34;</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>): <span style="color:#75715e">//timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>2、使用有buffer的channel。</p>
<!-- raw HTML omitted -->
<p><strong>Case-3</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>  <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span>  = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int64</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">res</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">res</span>))
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">res</span>, <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>1、不一定符合预期。可能是0也可能是4。</p>
<p>2、即使是无buffer的channel也不一定符合预期</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>2、如果业务场景允许，在两个gorutine结束后再查询。</p>
<!-- raw HTML omitted -->
<p><strong>Case-4</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">l</span>  <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">4</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>生产者先获取锁再生产，消费者先消费再获取锁。生产者将channel填满，而消费者阻塞在获取锁的逻辑，最终导致死锁。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="channel底层实现">channel底层实现</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hchan</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">qcount</span>   <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 当前队列中剩余元素个数，即len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dataqsiz</span> <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 环形队列长度，即可以存放的元素个数，cap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 环形队列指针：队列缓存，头指针，环形数组实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">elemsize</span> <span style="color:#66d9ef">uint16</span>         <span style="color:#75715e">// 每个元素的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">closed</span>   <span style="color:#66d9ef">uint32</span>         <span style="color:#75715e">// 关闭标志位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">elemtype</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>         <span style="color:#75715e">// 元素类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendx</span>    <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 队列下标，指示元素写入时存放到队列中的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">recvx</span>    <span style="color:#66d9ef">uint</span>           <span style="color:#75715e">// 队列下标，指示元素从队列的该位置读出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">recvq</span>    <span style="color:#a6e22e">waitq</span>          <span style="color:#75715e">// 等待读消息的goroutine队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sendq</span>    <span style="color:#a6e22e">waitq</span>          <span style="color:#75715e">// 等待写消息的goroutine队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// lock protects all fields in hchan, as well as several
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// fields in sudogs blocked on this channel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// Do not change another G&#39;s status while holding this lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// with stack shrinking.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>              <span style="color:#75715e">// 该锁保护hchan所有字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="发送消息的流程">发送消息的流程</h4>
<p>源码见<code>runtime/chan.go</code>中的<code>chansend</code>函数。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8ecf38653e087013e72abaf66b69e432?method=download&amp;shareKey=dfc2583d4f9c4fff497082679b768120" alt=""></p>
<p><del>#### 接受消息的流程
源码见<code>runtime/chan.go</code>中的<code>chanrecv</code>函数。</del></p>
<h3 id="channel使用场景总结">channel使用场景总结</h3>
<ul>
<li>同步信号（shutdown/close/finish）</li>
<li>消息传递（queue/stream）</li>
<li>互斥（mutex）</li>
</ul>
<h3 id="channel不同操作和不通状态总结">channel不同操作和不通状态总结</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">nil的channel</th>
<th style="text-align:left">已关闭channel</th>
<th style="text-align:left">正常channel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">close</td>
<td style="text-align:left"><code>panic</code></td>
<td style="text-align:left"><code>panic</code></td>
<td style="text-align:left">成功</td>
</tr>
<tr>
<td style="text-align:left">block read</td>
<td style="text-align:left"><code>死锁</code></td>
<td style="text-align:left">零值</td>
<td style="text-align:left">阻塞或成功</td>
</tr>
<tr>
<td style="text-align:left">block write</td>
<td style="text-align:left"><code>死锁</code></td>
<td style="text-align:left"><code>panic</code></td>
<td style="text-align:left">阻塞或成功</td>
</tr>
<tr>
<td style="text-align:left">non-block read</td>
<td style="text-align:left">正常</td>
<td style="text-align:left">零值</td>
<td style="text-align:left">等待下次写入或成功</td>
</tr>
<tr>
<td style="text-align:left">non-block write</td>
<td style="text-align:left">正常</td>
<td style="text-align:left"><code>panic</code></td>
<td style="text-align:left">等待下次写入或成功</td>
</tr>
</tbody>
</table>
<h2 id="mutextrwmutext误用">mutext/rwmutext误用</h2>
<p><strong>Case-5</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">do</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">l</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">do</span>(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;have err&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ol start="2">
<li>defer unlock，但是需要注意使用此方式会增加锁粒度</li>
</ol>
<!-- raw HTML omitted -->
<p><strong>Case-6</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 加写锁，此时reader0还未释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;writer0 Call Lock&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;writer0 Lock&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;writer0 Call UnLock&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;writer0 UnLocked&#34;</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 加读锁，此时reader0还未释放锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">idx</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;reader%d Call RLock\n&#34;</span>, <span style="color:#a6e22e">idx</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;reader%d RLock\n&#34;</span>, <span style="color:#a6e22e">idx</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;reader%d Call RUnLock\n&#34;</span>, <span style="color:#a6e22e">idx</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;reader%d RUnLocked\n&#34;</span>, <span style="color:#a6e22e">idx</span>)
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>被加读锁时，写操作进来会被阻塞。在写操作阻塞期间，如果有读操作试图进来，它们也会被阻塞。当阻塞写操作的最后一个读操作解读锁时，它只会唤醒被阻塞的写操作，之后进来的读操作需要该写操作完成之后被唤醒。</p>
<!-- raw HTML omitted -->
<p><strong>Case-7</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">A1</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;w call lock&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">A1</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a1 call rlock&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;a1 rlocked&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">B2</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">B2</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">C3</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">C3</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;c3 call rlock&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;c3 rlocked&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>A1使用了defer， 使RLock()递归调用，递归调用导致已经等待Lock发生死锁。</p>
<!-- raw HTML omitted -->
<h3 id="一些建议">一些建议</h3>
<ul>
<li>Lock和UnLock配套使用</li>
<li>运行时离开当前逻辑就释放锁</li>
<li>锁的粒度越小越好，加锁后尽快释放锁</li>
<li>没有特殊原因尽量不用defer释放锁</li>
<li>rwmutext的读锁不要嵌套使用</li>
</ul>
<h2 id="mapsyncmap">map/sync.Map</h2>
<p><strong>map</strong>不可并发写！</p>
<p><strong>sync.Map</strong>可并发读写</p>
<p><strong>sync.Map特性</strong></p>
<ul>
<li>通过read和dirty两个字段将读写分离，读取时会先查询read，不存在再查询dirty， 新增时只写入dirty（如果是更新，直接更新对应指针的值，dirty和read中的值都会被更新）</li>
<li>读取read并不需要加锁，而读写dirty都需要加锁</li>
<li>另外有miss字段来统计read被穿透的次数（被穿透指需要读dirty的情况），当miss次数大于等于<code>len(dirty)</code>则将read替换为dirty，然后将dirty置为nil</li>
<li>对于在read中的数据删除，并没有真正删除key，而是从key中取出了entry，然后把<code>entry.p</code> 设为nil等待gc回收。</li>
</ul>
<p><strong>Go1.15陷阱</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sm</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">26</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">value</span> [<span style="color:#ae81ff">1000</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">value</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sm</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">sm</span>.<span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码只写不读然后删除，在Go1.15中会造成内存泄漏。</p>
<p>因为只写未读，所以数据一直在dirty中，而go1.15因为下面的提交去掉了对只在dirty中的数据删除时的<code>delete</code>操作，导致dirty中key和value一直存在从而造成内存泄漏。</p>
<p><a href="https://github.com/golang/go/commit/2e8dbae85ce88d02f651e53338984288057f14cb#diff-4bf757695a75598d57e2b575987c626d4502cc0b2a08c5b0d3e535fa63de0d1e">https://github.com/golang/go/commit/2e8dbae85ce88d02f651e53338984288057f14cb#diff-4bf757695a75598d57e2b575987c626d4502cc0b2a08c5b0d3e535fa63de0d1e</a></p>
<p>后在1.16中通过下面的提交修复了此问题</p>
<p><a href="https://github.com/golang/go/commit/94953d3e5928c8a577bad7911aabbf627269ef77">https://github.com/golang/go/commit/94953d3e5928c8a577bad7911aabbf627269ef77</a></p>
<p>但这个使用姿势肯定是不对的。</p>
<p>在1.16中完整的删除流程如下：
<img src="https://note.youdao.com/yws/api/personal/file/WEBde06ccde2c76b53dfe44cae788c5f39e?method=download&amp;shareKey=2bb25b590fb012e9c2a1b29365855b9d" alt=""></p>
<p><strong>总结</strong>：</p>
<ol>
<li>在GO1.15中不要只写不读。</li>
<li>在任何版本中一定要注意key的大小。</li>
</ol>
<h3 id="maprwmutext和syncmap使用场景">map+rwmutext和sync.map使用场景</h3>
<p>到底是使用<code>map+rwmutext</code>还是使用<code>sync.map</code>， 我汇总了不同的资料。</p>
<p>1、官方文档注释（<code>sync/map.go</code>）</p>
<pre tabindex="0"><code>// The Map type is optimized for two common use cases: (1) when the entry for a given
// key is only ever written once but read many times, as in caches that only grow,
// or (2) when multiple goroutines read, write, and overwrite entries for disjoint
// sets of keys. In these two cases, use of a Map may significantly reduce lock
// contention compared to a Go map paired with a separate Mutex or RWMutex.
</code></pre><p>1)、读特别多，写很少的场景适合sync.Map</p>
<p>2、并发读写的key无冲突时适合sync.Map</p>
<p>2、博客 <a href="https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c">https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c</a></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB029950a3d70bd54a2b60197b875c069f?method=download&amp;shareKey=26b37691f6c11643347062a45ce4f172" alt=""></p>
<p>上图说明超过4核后，sync.Map更具有优势。</p>
<p>3、 其他人benchmark结果</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3842670b32c483a0b15105ef1d4eaad4?method=download&amp;shareKey=1cbb603faddceb491e0d52cb82f6bc5c" alt=""></p>
<p>读和删除sync.Map比map+rwmutext和map+mutext性能更好</p>
<p><strong>结论</strong>：</p>
<p>读比较多的场景<code>sync.Map</code>更具有优势，读写相对均衡则<code>map+rwmutext</code>更加适合。</p>
<h2 id="synconce误用">sync.Once误用</h2>
<p><strong>Case-8</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">once</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;recovered from once&#34;</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;once in goroutine&#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">count</span> = <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;once in main&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">count</span> = <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">count</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;end&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>这意味着因为某些未考虑到的极端情况导致初始化未完成，那么整个初始化逻辑不可重入。所以我们在使用once的时候一定要注意可能引起panic的情况。</p>
<!-- raw HTML omitted -->
<h3 id="once和单例">once和单例</h3>
<p><strong>懒汉模式</strong></p>
<ul>
<li>需要的时候才创建，空间效率更优</li>
<li>同时需要考虑double check的问题</li>
</ul>
<p>可添加get方法使用once实现，或者使用mutext自己实现（需要考虑double check）</p>
<p><strong>饿汉模式</strong></p>
<ul>
<li>事先创建好，需要时直接返回，代码相对简洁</li>
</ul>
<p>为避免并发问题，可在init中创建，或者在使用前创建（注意不要并发创建，否则又要加锁）。</p>
<h2 id="waitgroup误用">WaitGroup误用</h2>
<p><strong>Case-9</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">count</span> <span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;done! count:%v\n&#34;</span>, <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">LoadInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="一些建议-1">一些建议</h3>
<ul>
<li>统一Add（不要并发Add），分别Done，避免尚未Add就Wait</li>
<li>不能将计数器设置为负数，否则会发生panic。例如：Add 负数或Done调用次数大于总数</li>
<li>WaitGroup可以重用的，但是需要等上一批的goroutine都调用wait完毕后才能继续重用WaitGroup</li>
</ul>
<pre tabindex="0"><code>// 还没wait结束就add可能会有这个panic，不过我目前尚未复现
panic(&#34;sync: WaitGroup is reused before previous Wait has returned&#34;)
</code></pre><h2 id="synccond误用">sync.Cond误用</h2>
<p><strong>使用场景</strong>：</p>
<p>我需要完成一项任务，但是这项任务需要满足一定条件才可以执行，否则我就等着。
那我可以怎么获取这个条件呢？一种是循环获取，另一种是条件满足的时候通知我就可以了。显然第二种效率高很多。
golang里面通知可以用channel的方式进行通知， 但是channel的方式还是比较适用于一对一，一对多则还是sync.Cond更加方便。</p>
<p><strong>Case-10</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">NewCond</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Broadcast</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">L</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">L</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<h3 id="一些建议-2">一些建议</h3>
<ul>
<li><code>Wait</code>调用尽量要在某种条件不满足的情况下才调用，不要使用这种方式将goroutine挂起以达到某种暂停执行的目的。</li>
<li><code>Broadcast</code>必须要在所有的Wait之后, 或者说一定要有一个<code>Boradcast</code>后于最后一次<code>Wait</code>调用。</li>
</ul>
<blockquote>
<p>Broadcast， 用于唤醒所有处于等待状态的gorutine，Signal则是用于唤醒某一个处于等待状态的gorutine</p>
</blockquote>
<h2 id="defer误用">defer误用</h2>
<p><strong>Case-11</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;logging job cost: %v\n&#34;</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">start</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;logging at job start: %v\n&#34;</span>, <span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>更适合的方式是defer+闭包。</p>
<!-- raw HTML omitted -->
<p><strong>Case-12</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;i :&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;j :&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span><span style="color:#a6e22e">n</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>函数执行流程：</p>
<p>1、defer将匿名函数压栈</p>
<p>2、函数返回时将返回值*n存入函数返回值区域</p>
<p>3、defer调用执行，*n被增加（即i）</p>
<p>4、函数退出，j使用返回值赋值自己</p>
<p>5、打印i、j</p>
<!-- raw HTML omitted -->
<p><strong>Case-13</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Case-13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fn</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fn</span>() (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>函数执行流程：</p>
<p>1、defer将匿名函数压栈的同时将返回值的地址（栈中的地址）传递给defer函数</p>
<p>2、return语句将1存入函数返回值区域</p>
<p>3、defer调用执行，更新返回值区域的值</p>
<p>4、函数退出，主调函数就会获取到defer修改后的返回值</p>
<p>扩展：为什么defer能够修改有名返回值</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="一些建议-3">一些建议</h3>
<ul>
<li>defer声明时刻即参数解析时刻</li>
<li>defer执行结果为FILO，先进后出（越先声明的defer，执行时机越靠后）。</li>
<li>尽量不要在defer中修改返回值</li>
</ul>
<h2 id="shadow变量引发的问题">Shadow变量引发的问题</h2>
<p><strong>Case-14</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>这个比较常见，在for循环中，你就认为i是同一个变量，那么上例中所有gorutine共享i变量，所以打印出的值都一样。</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>Case-15</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v1</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Inner:&#34;</span>, <span style="color:#a6e22e">v1</span>, <span style="color:#a6e22e">v2</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Outer:&#34;</span>, <span style="color:#a6e22e">v1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>同名变量使用短声明导致<code>if块中的v1和外层的v1变量不是同一个</code>。这种问题最常见的受害者就是<code>err</code>。</p>
<!-- raw HTML omitted -->
<h3 id="总结">总结</h3>
<ul>
<li>在相同的代码包不同作用域下的同名变量、方法之前存在屏蔽现象</li>
<li>在相同结构体内定义同名属性、方法不存在屏蔽现象（编译不过）</li>
<li>在内嵌类型和被内嵌类型之间定义的同名属性、方法存在屏蔽现象</li>
<li>在同一层级的内嵌类型之间定义同名方法、属性不存在屏蔽现象(编译不过)</li>
</ul>
<h2 id="selecttimeafter误用">select+time.After误用</h2>
<p><strong>Case-16</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>())
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">isTimeout</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Loop</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">Loop</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">isTimeout</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span> <span style="color:#a6e22e">Loop</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// do sth
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;end with timeout: %v\n&#34;</span>, <span style="color:#a6e22e">isTimeout</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>还会造成短时间内的内存暴涨，如果过期时间长内存会持续增张到一个很大的值。</p>
<p>原因：每次for循环time.After都会新建一个计时器，而这个计时器在时间到期之前gc是不会回收的</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>2、time.After底层会调用NewTimer(d), 在for循环外层新建一个timer，然后在select中使用新建的计时器即可</p>
<p>3、对于不使用但是时间又未到的计时器记得手动stop，避免因为某些情况导致短时间内内存爆增</p>
<!-- raw HTML omitted -->
<h2 id="go相关的检测工具">Go相关的检测工具</h2>
<p><strong>静态检查工具 go vet</strong></p>
<p>这个工具可以协助检查<code>atomic</code>包中的函数是否使用正确、是否存在copy锁的行为和结构体标签是否使用正确等。</p>
<p>多说无益，建议使用vscode的各位把下面的开关打开（goland自己百度一下哈）</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBba132fe2c784a6e1a32665d6b3ad1a29?method=download&amp;shareKey=7f299aaf0f48554497b71fbbd4785771" alt=""></p>
<p><strong>代码检查工具</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb62254c50216e1e162e1748715e50fe5?method=download&amp;shareKey=b389745472167639a6ee84d014ec6b96" alt=""></p>
<p>顺便分享一下我本地的vscode配置，大家有兴趣可以自取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;go.autocompleteUnimportedPackages&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;go.useCodeSnippetsOnFunctionSuggest&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;go.useCodeSnippetsOnFunctionSuggestWithoutType&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;go.useLanguageServer&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>数据竞争检测</strong></p>
<p>比较常用的用法如下：</p>
<pre tabindex="0"><code class="language-shel" data-lang="shel">go run -race pkg
go run -race *.go
go build -race main.go
</code></pre><p><strong>Goroutine泄漏检测</strong></p>
<p>目前我还没有机会用上，也希望我们永远不会有机会用上
<a href="https://github.com/uber-go/goleak">https://github.com/uber-go/goleak</a></p>
<p><strong>性能分析工具</strong></p>
<p>下面的文章讲的比我好：</p>
<p><a href="https://juejin.cn/post/6844904079525675016">https://juejin.cn/post/6844904079525675016</a></p>
<p><a href="https://blog.golang.org/pprof">https://blog.golang.org/pprof</a></p>
<h1 id="简洁而高性能的原生网络模型">简洁而高性能的原生网络模型</h1>
<p>Go的原生网络模型通过在底层对epoll/kqueue/iocp的封装实现了<code>goroutine-per-connection</code>模式。在这种模式下开发者对I/O是否阻塞是无感知的，并且开发者也无需考虑gorutine甚至更底层的线程、进程的调度以及上下文切换。本次分享将通过对Go源码层层推进逐步揭开Go原生网络模型的神秘面纱。</p>
<p>首先我们看一下epoll的API，只涉及三个系统调用：</p>
<p><code>epoll_create</code>: 创建一个epoll实例并返回实例句柄。</p>
<p><code>epoll_ctl</code>: 注册file descriptor等待的I/O事件到epoll实例上。</p>
<p><code>epoll_wait</code>: 阻塞监听epoll实例上所有的 file descriptor的I/O事件，它接受一个用户空间上的一块儿内存地址，内核会在I/O事件发生的时候把文件描述符列表复制到这块儿内存地址上，然后epoll_wait解除阻塞并返回，最后用户空间上的程序就可以对相应的fd进行读写了。</p>
<p>下面看一个简单echo服务体验一下Go的网络编程到底是有多爽。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">listen</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;:2333&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;listen error: &#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">listen</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">listen</span>.<span style="color:#a6e22e">Accept</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;accept error: &#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dt</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果没有数据读取将阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">dt</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;read socket error: &#34;</span>, <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果连接不可写将阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">dt</span>[:<span style="color:#a6e22e">n</span>])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>监听端口只需要一个<code>net.Listen</code>方法、接受新的请求只需要一个<code>(Listener).Accept</code>方法，读写数据分别只需要<code>(Conn).Read</code>和<code>(Conn).Write</code>方法。如此简介且语义化的API让我们的编程体验极其舒适，但这些简洁的API背后都蕴含着复杂的封装。</p>
<p><code>net.Listen(&quot;tcp&quot;, &quot;:2333&quot;)</code>方法返回的<code>net.Listener</code>接口真实类型为<code>*net.TCPListener</code>, <code>listen.Accept</code>返回的<code>net.Conn</code>接口真实类型为<code>*net.TCPConn</code>。<code>net.TCPListener</code>和<code>net.TCPConn</code>都直接或者间接持有一个<code>*net.netFD</code>类型的网络描述符，而<code>net.Listener</code>的<code>Accept</code>方法和<code>net.Conn</code>的<code>Read/Write</code>方法，都是基于<code>net.netFD</code>的数据结构操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// net/fd_posix.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Network file descriptor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">netFD</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pfd</span> <span style="color:#a6e22e">poll</span>.<span style="color:#a6e22e">FD</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// immutable until Close
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">family</span>      <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sotype</span>      <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">isConnected</span> <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// handshake completed or use of association with peer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">net</span>         <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">laddr</span>       <span style="color:#a6e22e">Addr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raddr</span>       <span style="color:#a6e22e">Addr</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// internal/poll/fd_unix.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FD</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略了很多其他字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 系统文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// System file descriptor. Immutable until Close.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Sysfd</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 读写超时等操作都是通过调用pollDesc对应方法实现的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// I/O poller.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pd</span> <span style="color:#a6e22e">pollDesc</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pollDesc</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 指向runtime/netpoll.go中的pollDesc类型的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runtimeCtx</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="netlisten">net.Listen</h2>
<p><code>net.Listen</code>中部分关键函数的调用路径如下。
<img src="https://note.youdao.com/yws/api/personal/file/WEBd0dfb27243f2e9c08f75337c130e53b6?method=download&amp;shareKey=9c9d626b8cb4a08ad9582917c8218367" alt=""></p>
<p>这里需要注意的是<code>internal/poll/fd_poll_runtime.go</code>中的<code>runtime_pollServerInit</code>和<code>runtime_pollOpen</code>函数真实实现分别为<code>runtime/netpoll.go</code>中的<code>poll_runtime_pollServerInit</code>和<code>poll_runtime_pollOpen</code>函数(通过<code>go:linkname</code>将runtime中unexported的方法暴露给其他包使用)。</p>
<p><code>poll_runtime_pollServerInit</code>函数内关键调用为<code>netpollGenericInit-&gt;runtime/netpoll_epoll.go:netpollinit</code>，<code>netpollinit</code>内部会调用<code>epollcreate1</code>创建一个epoll实例<code>epfd</code>,作为整个runtime的唯一event-loop使用，epoll实例创建成功后还会通过<code>epollctl</code>将相应的文件描述符注册到epoll实例中。</p>
<blockquote>
<p>因为使用了sync.Once，整个runtime期间仅有一个epoll实例</p>
</blockquote>
<p><code>poll_runtime_pollOpen</code>函数创建一个<code>*runtime.pollDesc</code>类型的指针<code>pd</code>并通过调用<code>netpollopen</code>函数(内部会调用epollctl函数)将相应的文件描述符和<code>pd</code>地址注册到epoll实例中。</p>
<p><strong>小结</strong>：监听某一端口时和<code>epoll_create</code>以及<code>epoll_ctl</code>这两个系统调用相关。</p>
<h2 id="listeneraccept">(Listener).Accept</h2>
<p><code>(Listener).Accept</code>中部分关键函数的调用路径如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4fa025c39070b6560c282ae6eaa2af78?method=download&amp;shareKey=4705692a4ca2d3802a3199b21aaaccc1" alt=""></p>
<p>当正常获取到文件描述符后会调用<code>(*netFD).init</code>方法，根据前面的内容知，最后会调用<code>epoll_ctl</code>将文件描述符注册到epoll实例中。</p>
<p><code>runtime_pollWait</code>实际对应<code>runtime/netpoll.go</code>中的<code>poll_runtime_pollWait</code>函数。</p>
<p>在正式看<code>poll_runtime_pollWait</code>函数逻辑之前，我们先看一下<code>runtime.pollDesc</code>的数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pollDesc</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">link</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pollDesc</span> <span style="color:#75715e">// in pollcache, protected by pollcache.lock
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// in a lock-free way by all operations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// that will blow up when GC starts moving objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lock</span>    <span style="color:#a6e22e">mutex</span> <span style="color:#75715e">// protects the following fields
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fd</span>      <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">closing</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">everr</span>   <span style="color:#66d9ef">bool</span>      <span style="color:#75715e">// marks event scanning error happened
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">user</span>    <span style="color:#66d9ef">uint32</span>    <span style="color:#75715e">// user settable cookie
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rseq</span>    <span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// protects from stale read timers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rg</span>      <span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// pdReady, pdWait, G waiting for read or nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rt</span>      <span style="color:#a6e22e">timer</span>     <span style="color:#75715e">// read deadline timer (set if rt.f != nil)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rd</span>      <span style="color:#66d9ef">int64</span>     <span style="color:#75715e">// read deadline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wseq</span>    <span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// protects from stale write timers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wg</span>      <span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// pdReady, pdWait, G waiting for write or nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wt</span>      <span style="color:#a6e22e">timer</span>     <span style="color:#75715e">// write deadline timer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wd</span>      <span style="color:#66d9ef">int64</span>     <span style="color:#75715e">// write deadline
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">self</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">pollDesc</span> <span style="color:#75715e">// storage for indirect interface. See (*pollDesc).makeArg.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>其中最值得关注的是<code>rg</code>和<code>wg</code>，其取值可能是状态也可以等待i/o就绪的groutine指针。</p>
<p>而<code>poll_runtime_pollWait</code>函数的逻辑如下:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">poll_runtime_pollWait</span>(<span style="color:#a6e22e">pd</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pollDesc</span>, <span style="color:#a6e22e">mode</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">errcode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">netpollcheckerr</span>(<span style="color:#a6e22e">pd</span>, int32(<span style="color:#a6e22e">mode</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errcode</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pollNoError</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errcode</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// As for now only Solaris, illumos, and AIX use level-triggered IO.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;solaris&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;illumos&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;aix&#34;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">netpollarm</span>(<span style="color:#a6e22e">pd</span>, <span style="color:#a6e22e">mode</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 进入netpollblock并且判断是否有期待的 I/O 事件发生
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 此处for循环是为了一直等待io ready
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">netpollblock</span>(<span style="color:#a6e22e">pd</span>, int32(<span style="color:#a6e22e">mode</span>), <span style="color:#66d9ef">false</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">errcode</span> = <span style="color:#a6e22e">netpollcheckerr</span>(<span style="color:#a6e22e">pd</span>, int32(<span style="color:#a6e22e">mode</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errcode</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">pollNoError</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errcode</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Can happen if timeout has fired and unblocked us,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// but before we had a chance to run, timeout has been reset.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// Pretend it has not happened and retry.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pollNoError</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">netpollblock</span>(<span style="color:#a6e22e">pd</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">pollDesc</span>, <span style="color:#a6e22e">mode</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">waitio</span> <span style="color:#66d9ef">bool</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">gpp</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">rg</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mode</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;w&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">gpp</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">wg</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// set the gpp semaphore to pdWait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这个 for 循环是为了等待 io ready 或者将状态设置为io wait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">old</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gpp</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">pdReady</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">*</span><span style="color:#a6e22e">gpp</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtime: double wait&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Casuintptr</span>(<span style="color:#a6e22e">gpp</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">pdWait</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// waitio此时为false，并且pollDesc一般都是正常的，所以会调用gopark将当前的goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// park住，直到对应的fd上发生可读/可写或者其其他i/o事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 在gopark内部会将当前的gorutine指针赋值给gpp(pollDesc.rg/pollDesc.wg) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 同时将gorutine状态置为waiting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 后需当io就绪后取出注册到epoll实例中的数据pollDesc，并将pollDesc中等待i/o的g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 放回调度链表重新调度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">waitio</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">netpollcheckerr</span>(<span style="color:#a6e22e">pd</span>, <span style="color:#a6e22e">mode</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">netpollblockcommit</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">gpp</span>), <span style="color:#a6e22e">waitReasonIOWait</span>, <span style="color:#a6e22e">traceEvGoBlockNet</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// be careful to not lose concurrent pdReady notification
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">old</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xchguintptr</span>(<span style="color:#a6e22e">gpp</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> &gt; <span style="color:#a6e22e">pdWait</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;runtime: corrupted polldesc&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">old</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">pdReady</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>小结</strong>：</p>
<ol>
<li>获取到文件描符述时，会通过系统调用<code>epoll_ctl</code>将文件描述符注册到epoll实例中</li>
<li>如果没有i/o事件时，会调用gopark将gorutine指针保存，并将gorutine状态置为waiting。</li>
</ol>
<h2 id="connread--connwrite">(Conn).Read &amp; (Conn).Write</h2>
<p><code>(Conn).Read</code>和<code>(Conn).Write</code>原理类似，这里仅分享<code>(Conn).Read</code>的逻辑。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBacd905c99ad4d7169fc0a298c9b75c22?method=download&amp;shareKey=3090cdec976aeef3ea6dfedc655b0a14" alt=""></p>
<p>参考前文，我们知道调用<code>(*pollDesc).waitRead</code>时，因为没有可读的数据则gorutine会被park住直到有i/o事件发生时才恢复执行。</p>
<h2 id="runtime的完美配合">runtime的完美配合</h2>
<p>到这里，前文的echo服务核心代码基本分析完毕。gorutine如何阻塞我们也已经明白，但何时恢复执行却还是一头雾水，而这就是本小节的重点。</p>
<p>前文中只出现了<code>epoll_create</code>和<code>epoll_ctl</code>，还缺少<code>epoll_wait</code>的系统调用。以linux为例，调用<code>runtime/netpoll_epoll.go:netpoll</code>函数时会调用<code>epollwait</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">netpoll</span>(<span style="color:#a6e22e">delay</span> <span style="color:#66d9ef">int64</span>) <span style="color:#a6e22e">gList</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">events</span> [<span style="color:#ae81ff">128</span>]<span style="color:#a6e22e">epollevent</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">retry</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 无阻塞查看epoll实例上是否i/o就绪的fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">epollwait</span>(<span style="color:#a6e22e">epfd</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">events</span>[<span style="color:#ae81ff">0</span>], int32(len(<span style="color:#a6e22e">events</span>)), <span style="color:#a6e22e">waitms</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 省略代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 存储要恢复的 goroutines，最后返回给调用方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">toRun</span> <span style="color:#a6e22e">gList</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ev</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">events</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 省略代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 判断发生的事件类型，读类型或者写类型等，然后给 mode 复制相应的值，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// mode 用来决定从 pollDesc 里的 rg 还是 wg 里取出 goroutine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mode</span> <span style="color:#66d9ef">int32</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span><span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">_EPOLLIN</span>|<span style="color:#a6e22e">_EPOLLRDHUP</span>|<span style="color:#a6e22e">_EPOLLHUP</span>|<span style="color:#a6e22e">_EPOLLERR</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mode</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;r&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span><span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">_EPOLLOUT</span>|<span style="color:#a6e22e">_EPOLLHUP</span>|<span style="color:#a6e22e">_EPOLLERR</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">mode</span> <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#39;w&#39;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mode</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		    <span style="color:#75715e">// 取出保存在 epollevent 里的 pollDesc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">pd</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">**</span><span style="color:#a6e22e">pollDesc</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">everr</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ev</span>.<span style="color:#a6e22e">events</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">_EPOLLERR</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">pd</span>.<span style="color:#a6e22e">everr</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 调用 netpollready，传入就绪 fd 的 pollDesc，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 把 fd 对应的 goroutine 添加到链表 toRun 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">netpollready</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">toRun</span>, <span style="color:#a6e22e">pd</span>, <span style="color:#a6e22e">mode</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">toRun</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>netpoll</code>在以下两个场景会被调用。</p>
<p>首先，runtime在做gorutine调度时会检查已经就绪的文件描述符并恢复相应的gorutine为可执行状态从而参与调度执行。</p>
<p>具体调用链路为<code>runtime.schedule()-&gt;runtime.findrunable()-&gt;runtime.netpoll()</code>。</p>
<p>其次，<code>sysmon</code>监控线程会在循环过程中检查距离上一次<code>runtime.netpoll</code>被调用是否超过了10ms。如果超过10ms，则调用它拿到可运行的gorutine列表并通过<code>injectglist</code>把g列表放入全局队列或者当前P本地队列等待被执行。</p>
<blockquote>
<p>Go runtime 在程序启动的时候会创建一个独立的 M 作为监控线程，叫sysmon ，这个线程为系统级的daemon线程，无需P即可运行， sysmon每 20us~10ms 运行一次</p>
</blockquote>
<h2 id="总结-1">总结</h2>
<p>1、client连接server时，listener通过accept调用接受新的connection，每一个新的connection都启动一个goroutine处理，accept调用会把该connection的文件描述符注册到epoll的监听列表</p>
<p>2、当gorutine调用<code>conn.Read</code>或者<code>conn.Write</code>等需要阻塞等待的函数时，会被gopark将当前gorutine置为等待状态同时将gorutine地址存入<code>pollDesc</code>。</p>
<p>3、runtime在循环调度的<code>runtime.schedule()</code>函数以及<code>sysmon</code>监控线程中调用<code>runtime.nepoll</code>以获取可运行的goroutine列表并通过<code>injectglist</code>把剩下的g放入调度队列等待重新执行。</p>
<h2 id="问题">问题</h2>
<p>Go netpoller的设计不可谓不精巧、性能也不可谓不高，配合goroutine开发网络应用的时候就一个字：爽。因此Go的网络编程模式是及其简洁高效的，然而，没有任何一种设计和架构是完美的， <code>goroutine-per-connection</code>这种模式虽然简单高效，但是在某些极端的场景下也会暴露出问题：goroutine虽然非常轻量，它的自定义栈内存初始值仅为2KB，后面按需扩容；海量连接的业务场景下， <code>goroutine-per-connection</code>，此时goroutine数量以及消耗的资源就会呈线性趋势暴涨，虽然Go scheduler内部做了g的缓存链表，可以一定程度上可缓解高频创建和销毁goroutine的压力，但是对于<code>瞬时性暴涨的长连接场景就无能为力了</code>，大量的goroutines会被不断创建出来侵占系统资源，然后资源被侵占又反过来影响Go的调度，进而导致性能下降。</p>
<h1 id="资源分享">资源分享</h1>
<h2 id="天天向上资料分享">天天向上资料分享</h2>
<p><strong>知识图谱</strong>:
<a href="https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map">https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map</a></p>
<p><strong>CodeReview</strong>:
<a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></p>
<p><strong>项目布局（这个参考一下就行了还需因地制宜）</strong>:
<a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a></p>
<p><strong>最新的官方Q&amp;A</strong>:
<a href="https://stackoverflow.com/collectives/go">https://stackoverflow.com/collectives/go</a></p>
<p><strong>官方博客</strong>:
<a href="https://blog.golang.org/index">https://blog.golang.org/index</a></p>
<p><strong>官方文档</strong>:
<a href="https://golang.org/doc/">https://golang.org/doc/</a></p>
<p><strong>我十分推荐的一个大神</strong>:
<a href="https://draveness.me/golang/">https://draveness.me/golang/</a></p>
<p><strong>包百科全书（想找一些好用的包可以来这里翻一番）</strong>:
<a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a></p>
<h2 id="装逼工具分享">装逼工具分享</h2>
<p><strong>mac便捷的工具</strong>:
<a href="https://github.com/nikitavoloboev/my-mac-os">https://github.com/nikitavoloboev/my-mac-os</a></p>
<p><strong>chrome插件推荐</strong></p>
<ul>
<li>FeHelper</li>
<li>Vimium</li>
<li>彩云小译</li>
</ul>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>惊！Go里面居然有这样精妙的小函数！</title>
            <link>https://isites.gitlab.io/gopher/timeline/fns/</link>
            <pubDate>Tue, 03 Aug 2021 21:00:00 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/fns/</guid>
            <description>各位哥麻烦腾个道，前面是大型装逼现场。
首先老许要感谢他人的认同，这是我乐此不彼的动力，同时我也需要反思。这位小姐姐还是比较委婉， 但用我们四川话来说，前一篇文章的标题是真的cuo。
老许反复思考后决定哗众取宠一波，感叹号双连取名曰“惊！Go里面居然有这样精妙的小函数！”。下面就让我们来看看和标题没那么符合的一些小函数。
返回a/b向上舍入最接近的整数
func divRoundUp(n, a uintptr) uintptr { 	return (n + a - 1) / a } 这个方法用过的人应该不少，最典型的就是分页计算。
判断x是否为2的n次幂
func isPowerOfTwo(x uintptr) bool { 	return x&amp;amp;(x-1) == 0 } 这个也挺容易理解的，唯一需要注意的是x需要大于0，因为该等式0也是成立的。
向上/下将x舍入为a的倍数，且a必须是2的n次幂
// 向上将x舍入为a的倍数，例如：x=6，a=4则返回值为8 func alignUp(x, a uintptr) uintptr { 	return (x + a - 1) &amp;amp;^ (a - 1) }  // 向上将x舍入为a的倍数，例如：x=6，a=4则返回值为4 func alignDown(x, a uintptr) uintptr { 	return x &amp;amp;^ (a - 1) } 在这里老许再次明确一个概念，2的n次幂即为1左移n位。然后上述代码中^为单目运算法按位取反，则^ (a - 1)的运算结果是除了最低n位为0其余位全为1。剩余的部分则是一个简单的加减运算以及按位与。</description>
            <content type="html"><![CDATA[<p>各位哥麻烦腾个道，前面是大型装逼现场。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe4065167c25d3997e1de76682278cdb4?method=download&amp;shareKey=cfbd95aa6ed1cb7f611be67d06c381c3" alt=""></p>
<p>首先老许要感谢他人的认同，这是我乐此不彼的动力，同时我也需要反思。这位小姐姐还是比较委婉， 但用我们四川话来说，<a href="https://mp.weixin.qq.com/s/2MGYuqT_Xzy2_MwteQruQw">前一篇文章</a>的标题是真的<code>cuo</code>。</p>
<p>老许反复思考后决定哗众取宠一波，感叹号双连取名曰“<strong>惊！Go里面居然有这样精妙的小函数！</strong>”。下面就让我们来看看和标题没那么符合的一些小函数。</p>
<p><strong>返回a/b向上舍入最接近的整数</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">divRoundUp</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个方法用过的人应该不少，最典型的就是分页计算。</p>
<p><strong>判断x是否为2的n次幂</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isPowerOfTwo</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">&amp;</span>(<span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个也挺容易理解的，唯一需要注意的是x需要大于0，因为该等式0也是成立的。</p>
<p><strong>向上/下将x舍入为a的倍数，且a必须是2的n次幂</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 向上将x舍入为a的倍数，例如：x=6，a=4则返回值为8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">alignUp</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;^</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向上将x舍入为a的倍数，例如：x=6，a=4则返回值为4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">alignDown</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;^</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这里老许再次明确一个概念，<code>2的n次幂即为1左移n位</code>。然后上述代码中<code>^</code>为单目运算法按位取反，则<code>^ (a - 1)</code>的运算结果是除了最低n位为0其余位全为1。剩余的部分则是一个简单的加减运算以及按位与。</p>
<p>上述代码分开来看每一部分都认识，合在一起就一脸懵逼了。幸运的是，经过老许的不懈努力终于找到了一种能够理解的方式。</p>
<p>以<code>x=10，a=4</code>为例。<code>a</code>为2的2次幂即1左移2位。<code>x</code>可看作两部分之和，第一部分x1为<code>0b1000</code>,第二部分x2为<code>0b0011</code>。<code>x</code>的拆分方式是1左移<code>n</code>位可得到<code>a</code>来决定的，即x的最低n位为x2，x1则为x-x2。因此x1相当于0b10左移2位得到，即x1已经是a的整数倍，此时x2只要大于0则x2+a-1一定会向前进1，<code>x1+1</code>或<code>x1</code>不就是x向上舍入的a的整数倍嘛，最后和<code>^ (a - 1)</code>进行与运算将最低2位清零得到最终的返回结果。</p>
<p>有一说一，我肯定是写不出这样的逻辑，这也令我不得不感叹大佬们对计算机的理解简直出神入化。这样的函数牛逼归牛逼，但是在实际开发中还是尽量少用。一是有使用场景的限制（a必须为2的n次幂），二是不易理解，当然炫技和装逼除外（性能要求极高也除外）。</p>
<p><strong>布尔转整形</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// bool2int returns 0 if x is false or 1 if x is true.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bool2int</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">bool</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> int(uint8(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>))))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果让我来写这个函数，一个稀松平常的<code>switch</code>就完事儿，而现在我又多了一种装逼的套路。老许在这里特别友情提示，字节切片和字符串也可使用上述方式进行相互转换。</p>
<p><strong>计算不同类型最低位0的位数</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ntz8tab</span> = [<span style="color:#ae81ff">256</span>]<span style="color:#66d9ef">uint8</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x08</span>, <span style="color:#f92672">...</span>, <span style="color:#ae81ff">0x00</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ctz8 returns the number of trailing zero bits in x; the result is 8 for x == 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Ctz8</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint8</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">ntz8tab</span>[<span style="color:#a6e22e">x</span>])
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">deBruijn32ctz</span> = <span style="color:#ae81ff">0x04653adf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">deBruijnIdx32ctz</span> = [<span style="color:#ae81ff">32</span>]<span style="color:#66d9ef">byte</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">26</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">25</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">27</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ctz32 counts trailing (low-order) zeroes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and if all are zero, then 32.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Ctz32</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">x</span>                       <span style="color:#75715e">// isolate low-order bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">deBruijn32ctz</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">27</span>  <span style="color:#75715e">// extract part of deBruijn sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">deBruijnIdx32ctz</span>[<span style="color:#a6e22e">y</span>]) <span style="color:#75715e">// convert to bit index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> int((<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">26</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">32</span>)  <span style="color:#75715e">// adjustment if zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">deBruijn64ctz</span> = <span style="color:#ae81ff">0x0218a392cd3d5dbf</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">deBruijnIdx64ctz</span> = [<span style="color:#ae81ff">64</span>]<span style="color:#66d9ef">byte</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">19</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">40</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">17</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">38</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">46</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">48</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">35</span>, <span style="color:#ae81ff">54</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">41</span>, <span style="color:#ae81ff">57</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">63</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">39</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">37</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">47</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">53</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">56</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">62</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">36</span>, <span style="color:#ae81ff">44</span>, <span style="color:#ae81ff">52</span>, <span style="color:#ae81ff">55</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">61</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">60</span>, <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">59</span>, <span style="color:#ae81ff">58</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ctz64 counts trailing (low-order) zeroes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// and if all are zero, then 64.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Ctz64</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint64</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">x</span>                       <span style="color:#75715e">// isolate low-order bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">deBruijn64ctz</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">58</span>  <span style="color:#75715e">// extract part of deBruijn sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">deBruijnIdx64ctz</span>[<span style="color:#a6e22e">y</span>]) <span style="color:#75715e">// convert to bit index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> int((<span style="color:#a6e22e">x</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">57</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">64</span>)  <span style="color:#75715e">// adjustment if zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">z</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Ctz8</code>、<code>Ctz32</code>和<code>Ctz64</code>分别计算无符号8、32、64位数最低位为0的个数，即某个数左移的位数。</p>
<p>函数的作用通过翻译倒是能理解，我也能深刻的明白这是典型的空间换时间，然而要问一句为什么我是万万答不上来的。不过老许已经替你们找好了答案，答案就藏在这篇<a href="http://supertech.csail.mit.edu/papers/debruijn.pdf">Using de Bruijn Sequences to Index a 1 in a Computer Word</a>论文中。欢迎巨佬们去挑战一下，而我只想坐享其成，那么在巨佬们分析完这篇论文之前就让这些函数安家在我的收藏栏里方便以后炫技。</p>
<p>这里特别说明，术业有专攻，我们不一定要所有东西都会，但要尽可能知道有这么一个东西存在。这即是老许为自己找的一个不去研究此论文的接口，也是写下此篇文章的意义之一（万一有人提到了<code>Bruijn Sequences</code>关键词，我们也不至于显得过分无知）。</p>
<p><strong>math/bits包中的部分函数</strong></p>
<p>如果有人知道这个包，那请原谅我的无知直接跳过本部分即可。老许发现这个包是源于<code>ntz8tab</code>变量所在文件<code>runtime/internal/sys/intrinsics_common.go</code>中的一句注释。</p>
<pre tabindex="0"><code>// Copied from math/bits to avoid dependence.
</code></pre><p>作为一个资深的CV工程师， 看到这句的第一反应就是我终于可以挺直腰杆了。适当Copy代码不丢人！</p>
<p><code>math/bits</code>这个包函数较多，老许挑几个介绍即可，其余的还请各位读者自行挖掘。</p>
<p><code>LeadingZeros(x uint) int</code>: 返回x所有高位为0的个数。</p>
<p><code>TrailingZeros(x uint) int</code>: 返回x最低位为0的个数。</p>
<p><code>OnesCount(x uint) int</code>：返回x中bit位为1的个数。</p>
<p><code>Reverse(x uint) uint</code>: 将x按bit位倒序后再返回。</p>
<p><code>Len(x uint) int</code>: 返回表示x的有效bit位个数（高位中的0不计数）。</p>
<p><code>ReverseBytes(x uint) uint</code>: 将x按照每8位一组倒序后返回。</p>
<p><strong>将x逃逸至堆</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Dummy annotation marking that the value x escapes,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// for use in cases where the reflect code is so clever that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the compiler cannot follow.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">escapes</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">dummy</span>.<span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">dummy</span>.<span style="color:#a6e22e">x</span> = <span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dummy</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>老许是在<code>reflect.ValueOf</code>函数中发现此函数的调用，当时就觉着挺有意思。如今再次回顾也依旧佩服不已。读书是和作者的对话，阅读源码是和开发者的对话，看到此函数就仿佛看到Go语言开发者们和编译器斗智斗勇的场景。</p>
<p><strong>让出当前Processor</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Gosched yields the processor, allowing other goroutines to run. It does not
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// suspend the current goroutine, so execution resumes automatically.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Gosched</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">checkTimeouts</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mcall</span>(<span style="color:#a6e22e">gosched_m</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>让出当前的Processor，允许其他goroutine执行。在实际的开发当中老许还未遇到需要使用此函数的场景，但多了解总是有备无患。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.16.6</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>讲的是切片，但好像又不只是切片？</title>
            <link>https://isites.gitlab.io/gopher/timeline/slice/</link>
            <pubDate>Mon, 26 Jul 2021 22:09:00 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/slice/</guid>
            <description>我内心一直有一个欲望，想要高声呼喊“我胡汉三又回来了”，而现在就是合适的时机。
正式开干之前有点手生，太久没有写技术类的文章，总有点怠惰，不得不说坚持确实是一件很难的事情。如果不是因为愧疚和写点东西能让自己稍微平静下来一些，我可能还将继续怠惰下去。
另外还有一件很有意思的事情分享一下。前一篇在公众号上的文章仅思考就花了近一个月，写只花了一天，而技术文章我一般边思考边写平均耗时一周。结果是不会骗人的，前一篇文章阅读量首次突破一千，果然这届读者的思想深度至少也有一个月那么多，老许佩服佩服。
切片底层结构 切片和结构体的互转 其他不扯多了，我们还是回归本篇主题。 在正式了解切片底层结构之前， 我们先看几行代码。
type mySlice struct { 	data uintptr 	len int 	cap int }  s := mySlice{} fmt.Println(fmt.Sprintf(&amp;#34;%+v&amp;#34;, s)) // {data:0 len:0 cap:0} s1 := make([]int, 10) s1[2] = 2 fmt.Println(fmt.Sprintf(&amp;#34;%+v, len(%d), cap(%d)&amp;#34;, s1, len(s1), cap(s1))) // [0 0 2 0 0 0 0 0 0 0], len(10), cap(10) s = *(*mySlice)(unsafe.Pointer(&amp;amp;s1)) fmt.Println(fmt.Sprintf(&amp;#34;%+v&amp;#34;, s)) // {data:824634515456 len:10 cap:10} fmt.Printf(&amp;#34;%p, %v\n&amp;#34;, s1, unsafe.</description>
            <content type="html"><![CDATA[<p>我内心一直有一个欲望，想要高声呼喊“我胡汉三又回来了”，而现在就是合适的时机。</p>
<p>正式开干之前有点手生，太久没有写技术类的文章，总有点怠惰，不得不说坚持确实是一件很难的事情。如果不是因为愧疚和写点东西能让自己稍微平静下来一些，我可能还将继续怠惰下去。</p>
<p>另外还有一件很有意思的事情分享一下。前一篇在公众号上的文章仅思考就花了近一个月，写只花了一天，而技术文章我一般边思考边写平均耗时一周。结果是不会骗人的，前一篇文章阅读量首次突破一千，果然这届读者的思想深度至少也有一个月那么多，老许佩服佩服。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb829169226c8236ca3fd6bb1d31a4827?method=download&amp;shareKey=4371d20b80ab922011b921e562525227" alt=""></p>
<h1 id="切片底层结构">切片底层结构</h1>
<h2 id="切片和结构体的互转">切片和结构体的互转</h2>
<p>其他不扯多了，我们还是回归本篇主题。 在正式了解切片底层结构之前， 我们先看几行代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">mySlice</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">len</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cap</span>  <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mySlice</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%+v&#34;</span>, <span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// {data:0 len:0 cap:0}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s1</span>[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%+v, len(%d), cap(%d)&#34;</span>, <span style="color:#a6e22e">s1</span>, len(<span style="color:#a6e22e">s1</span>), cap(<span style="color:#a6e22e">s1</span>))) <span style="color:#75715e">// [0 0 2 0 0 0 0 0 0 0], len(10), cap(10)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">mySlice</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s1</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%+v&#34;</span>, <span style="color:#a6e22e">s</span>)) <span style="color:#75715e">// {data:824634515456 len:10 cap:10}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p, %v\n&#34;</span>, <span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">data</span>)) <span style="color:#75715e">// 0xc0000c2000, 0xc0000c2000
</span></span></span></code></pre></div><p>在上述代码中，通过获取切片的地址，并将其转为<code>*mySlice</code>, 成功获得了切片的长度和容量。以及一个类似于指针一样的东西。而这个指针就是指向存储真实数据的数组，下面我们来进行验证。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//Data强转为一个数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span>[<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span>[<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">data</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 修改数组中的数据后切片中对应位置的值也发生了变化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s1</span>)  <span style="color:#75715e">// [0 0 2 0 4 0 0 0 0 0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">s2</span>) <span style="color:#75715e">// [0 0 2 0 4]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">s3</span>) <span style="color:#75715e">// [0 0 2 0 4 0 0 0 0 0]
</span></span></span></code></pre></div><p>到这里，切片的底层结构已经呼之欲出了，不过为了做更进一步的验证，我们继续测试结构体转为切片的过程。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 一个长度为5的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">dt</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s4</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s5</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mySlice</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将数组地址赋值给data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">data</span>: uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">dt</span>)),
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">len</span>:  <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cap</span>:  <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 结构体强转为切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s4</span> = <span style="color:#f92672">*</span>((<span style="color:#f92672">*</span>[]<span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s5</span>)))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s4</span>, len(<span style="color:#a6e22e">s4</span>), cap(<span style="color:#a6e22e">s4</span>)) <span style="color:#75715e">// [0 0] 2 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 修改数组中的值， 切片内容也会发生变化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dt</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">dt</span>, <span style="color:#a6e22e">s4</span>) <span style="color:#75715e">// [0 3 0 0 0] [0 3]
</span></span></span></code></pre></div><p>通过上述三段代码，我们将切片的底层结构以结构体的形式更加清晰的表达出来。如下图所示，其中第一部分（Data）为指向数组的地址，第二部分（Len）为切片的长度即数组已使用的长度， 第三部分（Cap）为数组的长度。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB70ff878bc93b11ab7d9d75748459095c?method=download&amp;shareKey=6dee0526707b15611b604dc99fbd8b72" alt=""></p>
<p><strong>小结</strong>：切片是对数组的包装，底层仍使用数组存储数据。</p>
<blockquote>
<p>额外再多说一嘴：</p>
<p>reflect包要操作切片时通过<code>reflect.SliceHeader</code>结构体，详见https://github.com/golang/go/blob/master/src/reflect/value.go#L2329</p>
<p>runtime对切片进行扩容时使用<code>slice</code>结构体, 详见https://github.com/golang/go/blob/master/src/runtime/slice.go#L12</p>
</blockquote>
<h2 id="unsafe题外话">unsafe题外话</h2>
<p>在前一部分的Demo中几乎离不开<code>unsafe</code>包的使用。当然本篇并不是介绍此包的用法，只是作为一个题外话简单看一下它为什么不安全。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">otherOP</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> = new(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = new(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">otherOP</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) <span style="color:#75715e">// 如果注释此函数调用，最终输出结果会发生变化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(uintptr(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">a</span>)) <span style="color:#f92672">+</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(int(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>)))) = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">a</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">b</span>)
</span></span></code></pre></div><p>上述代在是否注释<code>otherOP</code>时，其输出结果是不一致的。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfddf1fcfc2050d9232fd69336a2f5a75?method=download&amp;shareKey=a0f94f779e70eca0d74cc95c2276aa34" alt=""></p>
<p>当变量逃逸至堆上时变量<code>a</code>和变量<code>b</code>内存地址相邻，故能够通过<code>a</code>变量地址去设置<code>b</code>变量的值。当未逃逸到堆上时，设置变量<code>b</code>的值并未生效，如此我们根本无法得知修改了哪一块儿内存的值，这种不确定性在老许看来即是我们需要慎重使用此包的原因。</p>
<blockquote>
<p>关于上述demo的补充解释：</p>
<ol>
<li>reflect.ValueOf会调用底层的escapes方法以保证对象逃逸到堆中</li>
<li>Go中采用按大小分割的空闲链表内存分配器以及多级缓存，故a，b变量在大小一致且本demo变量较少的的情况下很有可能被分配到连续的内存空间中</li>
</ol>
</blockquote>
<h1 id="创建切片">创建切片</h1>
<p>创建切片方式有四种。第一种直接通过<code>var</code>进行变量声明，第二种通过类型推导，第三种通过<code>make</code>方式去创建，第四种通过切片表达式创建。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 通过变量声明的方式创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 类型推导
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// make创建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>) <span style="color:#75715e">// c := make([]int, 0, 5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 切片表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>[:<span style="color:#ae81ff">3</span>]
</span></span></code></pre></div><p>上述例子中，前三种没什么特别好说的，老许主要介绍一下第四种,以及它的相关限制和注意事项。</p>
<h2 id="简单的切片表达式">简单的切片表达式</h2>
<p>对于字符串、数组、数组指针和切片（切片指针不能使用下面的表达式）均可使用下面的表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">low</span>:<span style="color:#a6e22e">high</span>] <span style="color:#75715e">// 生成的切片长度为high-low
</span></span></span></code></pre></div><p>通过上述表达式可创建新的子串或者切片。特别注意的是，对字符串使用此表达式时既不是生成字符串切片也不是生成字节切片而是生成<code>子字符串</code>。另外，老许在<a href="https://mp.weixin.qq.com/s/MHMg0oxZrUfhuuCZlod5cA">go中字符串的编码问题</a>中提到Go中的字符串存储的就是utf8字节切片，所以我们在使用此方法获取包含中文等特殊字符时有可能会出现意想不到的结果。正确得到子串的方式应该是先转为rune切片再截取。</p>
<p>上述表达式已经可以十分方便地创建新的切片，然而更加方便地是<code>low</code>和<code>high</code>还可以省略。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:]  <span style="color:#75715e">// same as s[2 : len(a)]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">3</span>]  <span style="color:#75715e">// same as s[0 : 3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span>[:]   <span style="color:#75715e">// same as s[0 : len(a)]
</span></span></span></code></pre></div><p><strong>下标限制</strong></p>
<p>对不同的类型使用切片表达式，<code>low</code>和<code>high</code>的取值范围不同。对于字符串和数组/数组指针而言，<code>low</code>和<code>high</code>的取值范围为<code>0 &lt;= low &lt;= len(s)</code>。对于切片而言，<code>low</code>和<code>high</code>的取值范围为<code>0 &lt;= low &lt;= cap(s)</code>。在<a href="https://mp.weixin.qq.com/s/G8MrTgwH88ABB-OOYreXIA">切片面试题系列一</a>中正是对此知识点的考察。</p>
<p><strong>切片容量</strong></p>
<p>通过切片表达式生成的切片，其底层数组共享，因此切片的容量为底层数组的长度减去<code>low</code>。由此可以推断下述代码输出结果为<code>3 8</code>和<code>3 13</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span> [<span style="color:#ae81ff">10</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s2</span> []<span style="color:#66d9ef">int</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s1</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">s</span>), cap(<span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span>
</span></span></code></pre></div><h2 id="完整的切片表达式">完整的切片表达式</h2>
<p>说实话这种方式真的不常用，虽然它可以控制切片的容量，但老许在实际开发中并未使用过。其完整表达式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">low</span> : <span style="color:#a6e22e">high</span> : <span style="color:#a6e22e">max</span>]
</span></span></code></pre></div><p>这种表达式有几个需要注意的点分别是：</p>
<ul>
<li>只适用于数组、数组指针和切片不适用于字符串。</li>
<li>和简单切片表达式不同的是，它只能忽略<code>low</code>这个下标且忽略后该下标默认值为0。</li>
<li>和简单切片表达式一样，通过完整切片表达式生成的切片底层数组共享</li>
</ul>
<p><strong>下标限制</strong></p>
<p>对数组/数组指针而言，下标取值范围为<code>0 &lt;= low &lt;= high &lt;= max &lt;= len(s)</code>。对切片而言，下标取值范围为<code>0 &lt;= low &lt;= high &lt;= cap(s)</code>。在<a href="https://mp.weixin.qq.com/s/O5533KWvDkyrsiCpBRP9EA">切片面试题系列二</a>中正是对此知识点的考察。</p>
<p><strong>切片容量</strong></p>
<p>前面提到此切片表达式可以控制切片的容量。在<code>low</code>一定的情况下，通过改变<code>max</code>在允许范围内的值即可改变切片的容量，其容量计算方式为<code>max - low</code>。</p>
<h1 id="切片扩容">切片扩容</h1>
<p><code>runtime/slice.go</code>文件的<code>growslice</code>函数实现了切片的扩容逻辑,在正式分析内部逻辑之前我们先看看<code>growslice</code>的函数签名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cap</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">growslice</span>(<span style="color:#a6e22e">et</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">old</span> <span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">slice</span>
</span></span></code></pre></div><p>第一个参数<code>_type</code>是Go语言类型的运行时表示，其中包含了很多元信息，例如：类型大小、对齐以及种类等。</p>
<p>第二个参数为待扩容切片的信息。</p>
<p>第三个参数为真实需要的容量，即原容量和新增元素数量之和，老许对其简称为所需容量。为了更加容易理解所需容量的含义，我们先看一段代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 此时切片长度和容量均为3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">4</span>) <span style="color:#75715e">// 此时所需容量为3 + 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>} <span style="color:#75715e">// 此时切片长度和容量均为3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">s1</span> = append(<span style="color:#a6e22e">s1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>) <span style="color:#75715e">// 此时所需容量为3 + 3
</span></span></span></code></pre></div><h2 id="扩容逻辑">扩容逻辑</h2>
<p>有了上面的概念之后，下面我们看看切片扩容算法：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1327300fe17b24f8445d1060e1c7ce3d?method=download&amp;shareKey=427d873743a6bc9219f1259075c3af99" alt=""></p>
<p>上图逻辑总结如下：</p>
<p>首先，如果所需容量大于2倍当前容量则新容量为所需容量。</p>
<p>其次，判断当前容量是否大于1024。如果当前容量小于1024则新容量等于2倍当前容量。如果当前容量大于等于1024则新容量循环增加1/4倍新容量直到新容量大于等于所需容量。</p>
<p>老许在这里特别提示，和<code>0</code>的比较是有用的。初始时，老许也觉得这逻辑十分多余，后来有一天突然顿悟，这实际上是对整形溢出的判断。因为平时开发中很少会考虑这个问题，一时间惊为天人。也许我们和大神之间的代码差距仅仅是少了对溢出的判断。</p>
<p>另外一个有意思的事情是，切片的逻辑最开始也不是这样的。这逻辑并不复杂，即使是刚入门的人写起来也毫无压力。然而即便是这样简单的逻辑，也是经过多个版本的迭代才有了如今的模样。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc4310c28ed5948d6d5ee3ee1d4fbc1a3?method=download&amp;shareKey=f4fb2bbd7bfbbacb661a069b0eaca404" alt=""></p>
<p>有一说一，在老许看来1.6中的扩容逻辑并不算优雅。想到这儿，一种“我赢了”的感觉油然而生，程序猿的快乐就是如此简单。</p>
<h2 id="计算内存容量">计算内存容量</h2>
<p>前文中的扩容逻辑是理想的内存分配容量，而真实的内存分配十分复杂。在Go1.6中切片扩容分配内存时分为四种情况，分别是类型大小为1字节、类型大小为指针大小、类型大小为2的n次幂和其他。而切片扩容分配内存时在不同的Go版本中又略有不同，这里只介绍1.16中类型大小为2的n次幂时内存分配。</p>
<p>下面直接上代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">shift</span> <span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">8</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Mask shift for better code generation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// et.size = 1 &lt;&lt; n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// shift = n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// &amp;63是因为uint64中1最大左移63，再大就溢出了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">shift</span> = uintptr(<span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Ctz64</span>(uint64(<span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">size</span>))) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">63</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">shift</span> = uintptr(<span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Ctz32</span>(uint32(<span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">size</span>))) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">31</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述代码中，通过对指针大小判断以区分当前运行的是32位还是64位平台。<code>Ctz64</code>和<code>Ctz32</code>函数是针对不同类型计算最低位<code>0</code>的个数。又因为类型大小是2的n次幂，则0的个数即为n。</p>
<blockquote>
<p>类型大小为2的n次幂，则类型大小一定为 1 &laquo; n，因此计算最低位0的个数即可得到左移的位数。</p>
<p>源码中通过<code>x&amp;(x-1) == 0</code>表达式判断一个无符号整数是否为2的n次幂。我们平时开发中如果有类似的逻辑，请参考切片扩容源码开始装逼之旅。</p>
</blockquote>
<p>接下来是计算内存容量的逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">capmem</span> = <span style="color:#a6e22e">roundupsize</span>(uintptr(<span style="color:#a6e22e">newcap</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#a6e22e">shift</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">newcap</span> = int(<span style="color:#a6e22e">capmem</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">shift</span>)
</span></span></code></pre></div><p>结合前文易知，<code>uintptr(newcap) &lt;&lt; shift</code>实际上可以理解为<code>uintptr(newcap) * et.size</code>，<code>capmem &gt;&gt; shift</code>可理解为<code>capmem / et.size</code>。<code>uintptr(newcap) &lt;&lt; shift</code>是最理想的所需内存大小，而实际分配内存时因为内存对齐等问题无法达到理想状况，所以通过<code>roundupsize</code>计算出实际需要的内存大小,最后再计算出真实容量。有了这个理解之后我们接下来着重分析<code>roundupsize</code>函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">roundupsize</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">uintptr</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> &lt; <span style="color:#a6e22e">_MaxSmallSize</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">smallSizeMax</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> uintptr(<span style="color:#a6e22e">class_to_size</span>[<span style="color:#a6e22e">size_to_class8</span>[<span style="color:#a6e22e">divRoundUp</span>(<span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">smallSizeDiv</span>)]])
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> uintptr(<span style="color:#a6e22e">class_to_size</span>[<span style="color:#a6e22e">size_to_class128</span>[<span style="color:#a6e22e">divRoundUp</span>(<span style="color:#a6e22e">size</span><span style="color:#f92672">-</span><span style="color:#a6e22e">smallSizeMax</span>, <span style="color:#a6e22e">largeSizeDiv</span>)]])
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">+</span><span style="color:#a6e22e">_PageSize</span> &lt; <span style="color:#a6e22e">size</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">size</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">alignUp</span>(<span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">_PageSize</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面函数有很多含义不清楚的变量，老许接下来会对其一一解释。</p>
<p><code>_MaxSmallSize</code>: 其值为<code>32768</code>，即32kb大小。在Go中，当对象大小超过32kb时，内存分配策略和小于等于32kB时是有区别的。</p>
<p><code>smallSizeMax</code>: 其值为1024字节。</p>
<p><code>smallSizeDiv</code>: 其值为8字节。</p>
<p><code>largeSizeDiv</code>: 其值为128字节。</p>
<p><code>_PageSize</code>: 8192字节，即8kb大小。Go按页来管理内存，而每一页的大小就为8kb。</p>
<p><code>class_to_size</code>: Go中的内存分配会按照不同跨度（也可理解为内存大小）将内存分割成不同内存块链表。当需要分配内存时，按照对象大小去匹配最合适的跨度找到空闲的内存块儿。Go中总共分为67个跨度，<code>class_to_size</code>是一个长度为68的数组，分别记录<code>0</code>和这67个跨度的值。源码详见<code>sruntime/izeclasses.go</code>。</p>
<p><code>size_to_class8</code>: 这是一个长度为129的数组，代表的内存大小区间为<code>0~1024</code>字节。以索引<code>i</code>为例，此位置的对象大小<code>m</code>为<code>i * smallSizeDiv</code>，<code>size_to_class8[i]</code>的值为<code>class_to_size</code>数组中跨度最接近<code>m</code>的下标。</p>
<p><code>size_to_class128</code>：这是一个长度为249的数组，代表的内存大小区间为<code>1024~32768</code>字节。以索引<code>i</code>为例，此位置的对象大小<code>m</code>为<code>smallSizeMax + i*largeSizeDiv</code>, <code>size_to_class128[i]</code>的值为<code>class_to_size</code>数组中跨度最接近<code>m</code>的下标。</p>
<p><code>divRoundUp</code>: 此函数返回<code>a/b</code>向上舍入最接近的整数。</p>
<p><code>alignUp</code>: <code>alignUp(size, _PageSize) = _PageSize * divRoundUp(size, _PageSize)</code>。</p>
<p>最终将计算实际需要内存大小的逻辑表示如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB24cf5d5ab57e3dc5f6ae8b7bee3291b3?method=download&amp;shareKey=cc439fd08c9f8f324f655c514e00f45f" alt=""></p>
<p>到这里，切片扩容的核心逻辑就已经分析完毕。本篇不对类型大小为1字节、类型大小为指针大小以及其他大小进行扩容逻辑分析的原因是整体逻辑差别不大。在老许看来源码中对类型大小区分的主要目的是为了尽可能减少除法和乘法运算。每每阅读这些优秀的源码都令老许直呼细节怪物。</p>
<p>为了加深印象我们以<a href="https://mp.weixin.qq.com/s/qdABTKsNjeG7KpKFRaKMww">切片面试题系列三</a>中的一个例子进行一次演算。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s3</span> = append(<span style="color:#a6e22e">s3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(cap(<span style="color:#a6e22e">s3</span>))
</span></span></code></pre></div><p>根据前文知，所需容量为5，又因所需容量大于2倍当前容量，故新容量也为5。</p>
<p>又因为int类型大小为8（等于64位平台上的指针大小），所以实际需要的内存大小为<code>5 * 8 = 40</code>字节。而67个跨度中最接近40字节的跨度为48字节，所以实际分配的内存容量为48字节。</p>
<p>最终计算真实的容量为<code>48 / 8 = 6</code>，和老许实际运行输出一致。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.16.6</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/slice/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>天涯未远，上海再见，百度再见</title>
            <link>https://isites.gitlab.io/gopher/timeline/leave-sh/</link>
            <pubDate>Sun, 06 Jun 2021 10:59:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/leave-sh/</guid>
            <description>关于离开想说的都在标题里。
离开的原因有很多，但是老许并不打算在这里详细阐述。说的越多都是在反复鞭尸自己的无能，老许对此次的离开总结为两个字——“败犬”（并无意冒犯他人，仅仅是对自己的总结。如果有兴趣交流的可以在公众号后台私我）。
以下为老许近一个多月的反思，这份反思没有什么大道理，更没有什么必须记住的知识点，老许写下来只是希望和各位读者有一个平等交流的机会。
一个无解的行业现状 &amp;ldquo;居安思危&amp;rdquo;，古人诚不欺我。我自认为在百度工作期间还是成长了很多，但是难免有松懈的时候，因此总的算下来是以一种平缓的速度进步。很长一段时间内老许都满足于现状，直到在金三银四的浪潮里开始挣扎。
“没有进步应该下十八层地狱，进步的慢更是一种原罪”，这是老许不由自主的感叹。以leetcode为例，不刷个一两百道题仿佛都不好意思出去面试。不知道这是不是内卷的一种。如果是，那一定是这个行业的人越来越多造成的。在程序猿从业人口越来越多的情况下，已经身在其中的人真是一刻也不容松懈呀。
 写下这一段我也很犹豫，总有散播焦虑的嫌疑，但事实上这就是我真实的感受。
 我简直毫无自控力 我简直毫无自控力，这个感悟来自于接受offer之后，把“某音”又重新装了回来。为什么会存在把它卸载这个事情呢？源自于开始找工作之后发现它严重影响了我的复习时间。明明知道应该把大量时间花在复习上，却总是不知不觉间刷起了短视频。虽然最近又把“某音”卸载了，但是又开始沉迷于某小破站。果然自控力对我来说就是扯淡。
和我等凡人不同，有些人明明已经成为了神，还是以极强的自控力给自己制定各种OKR和学习计划。看到这类人的时候，老许充分意识到作为一名凡夫俗子还是有点好高骛远了。他们欲带皇冠必承其重，我也不奢求自己有超强的自控力，只要在主次不颠倒的情况下，劳逸结合，按照合理的节奏前进即可，为达这个目的哪怕是以卸载这种强硬手段。
关于学习的反思 很早以前有人告诉我，“好记性不如烂笔头，但是最终你依旧要把它记在脑子里面才行”。这句话我深以为然，也是一直如此践行着。因此很多东西我做笔记也只是为了记住，而今终于自食恶果。
相信很多人都有这样一种感觉，年纪越大记忆力越来越差。我之前对某些知识点记忆不熟，也归咎于这个原因。我虽然做了笔记，但是没有对知识点做一个系统性的梳理，因此在我脑海中的知识点是杂乱无序的，自然忘的快。
幸运的是，我周边有这样的人在记忆知识点时会利用脑图做系统性的梳理。发现这一点时我幡然醒悟，我以前一直没有用一个有效的方法去记知识点。这个方法并不是什么秘密，很多人都知道但是并没有去使用。我相信这些人都和我一样只是缺少一个鹈鹕灌顶大彻大悟的契机。因此，我发自内心的感谢和我相遇的每一个人。
两个人的知识点不可能完全重合，因为你不可能看完所有的书，也不可能遇到他人遇到的所有实际问题，所以除了认真学习，获取知识点的另外一种有效途径就是交流和分享
对未来的规划和选择 这一段心里想了很多很多，有关于公司的选择，有关于未来的发展计划，但这些我自己也充满了不自信，所以就不在这里献丑了。
老许继续写下这段的原因是提醒自己现在的我还有选择的权利，如果有一天连选择的权利都没有了才是真正的穷途末路。虽然对未来依旧忐忑，但对老许来说一定会坚持的三件事是运动、挣钱和学习。相信这对所有人来说都是一样的（仿佛一句废话）。
最后，很庆幸有这样的一段时间，让自己重新思考，或许前路依旧迷雾重重，但依旧要砥砺前行。
最后的最后，感谢这一路上遇见的人和事。
【关注公众号】</description>
            <content type="html"><![CDATA[<p>关于离开想说的都在标题里。</p>
<p>离开的原因有很多，但是老许并不打算在这里详细阐述。说的越多都是在反复鞭尸自己的无能，老许对此次的离开总结为两个字——“败犬”（并无意冒犯他人，仅仅是对自己的总结。如果有兴趣交流的可以在公众号后台私我）。</p>
<p>以下为老许近一个多月的反思，这份反思没有什么大道理，更没有什么必须记住的知识点，老许写下来只是希望和各位读者有一个平等交流的机会。</p>
<h2 id="一个无解的行业现状">一个无解的行业现状</h2>
<p>&ldquo;居安思危&rdquo;，古人诚不欺我。我自认为在百度工作期间还是成长了很多，但是难免有松懈的时候，因此总的算下来是以一种平缓的速度进步。很长一段时间内老许都满足于现状，直到在金三银四的浪潮里开始挣扎。</p>
<p>“没有进步应该下十八层地狱，进步的慢更是一种原罪”，这是老许不由自主的感叹。以<code>leetcode</code>为例，不刷个一两百道题仿佛都不好意思出去面试。不知道这是不是内卷的一种。如果是，那一定是这个行业的人越来越多造成的。在程序猿从业人口越来越多的情况下，已经身在其中的人真是一刻也不容松懈呀。</p>
<blockquote>
<p>写下这一段我也很犹豫，总有散播焦虑的嫌疑，但事实上这就是我真实的感受。</p>
</blockquote>
<h2 id="我简直毫无自控力">我简直毫无自控力</h2>
<p>我简直毫无自控力，这个感悟来自于接受offer之后，把“某音”又重新装了回来。为什么会存在把它卸载这个事情呢？源自于开始找工作之后发现它严重影响了我的复习时间。明明知道应该把大量时间花在复习上，却总是不知不觉间刷起了短视频。虽然最近又把“某音”卸载了，但是又开始沉迷于某小破站。果然自控力对我来说就是扯淡。</p>
<p>和我等凡人不同，有些人明明已经成为了神，还是以极强的自控力给自己制定各种OKR和学习计划。看到这类人的时候，老许充分意识到作为一名凡夫俗子还是有点好高骛远了。他们欲带皇冠必承其重，我也不奢求自己有超强的自控力，只要在主次不颠倒的情况下，劳逸结合，按照合理的节奏前进即可，为达这个目的哪怕是以卸载这种强硬手段。</p>
<h2 id="关于学习的反思">关于学习的反思</h2>
<p>很早以前有人告诉我，“好记性不如烂笔头，但是最终你依旧要把它记在脑子里面才行”。这句话我深以为然，也是一直如此践行着。因此很多东西我做笔记也只是为了记住，而今终于自食恶果。</p>
<p>相信很多人都有这样一种感觉，年纪越大记忆力越来越差。我之前对某些知识点记忆不熟，也归咎于这个原因。我虽然做了笔记，但是没有对知识点做一个系统性的梳理，因此在我脑海中的知识点是杂乱无序的，自然忘的快。</p>
<p>幸运的是，我周边有这样的人在记忆知识点时会利用脑图做系统性的梳理。发现这一点时我幡然醒悟，我以前一直没有用一个有效的方法去记知识点。这个方法并不是什么秘密，很多人都知道但是并没有去使用。我相信这些人都和我一样只是缺少一个鹈鹕灌顶大彻大悟的契机。因此，我发自内心的感谢和我相遇的每一个人。</p>
<p>两个人的知识点不可能完全重合，因为你不可能看完所有的书，也不可能遇到他人遇到的所有实际问题，所以除了认真学习，获取知识点的另外一种有效途径就是交流和分享</p>
<h2 id="对未来的规划和选择">对未来的规划和选择</h2>
<p>这一段心里想了很多很多，有关于公司的选择，有关于未来的发展计划，但这些我自己也充满了不自信，所以就不在这里献丑了。</p>
<p>老许继续写下这段的原因是提醒自己现在的我还有选择的权利，如果有一天连选择的权利都没有了才是真正的穷途末路。虽然对未来依旧忐忑，但对老许来说一定会坚持的三件事是运动、挣钱和学习。相信这对所有人来说都是一样的（仿佛一句废话）。</p>
<p>最后，很庆幸有这样的一段时间，让自己重新思考，或许前路依旧迷雾重重，但依旧要砥砺前行。</p>
<p>最后的最后，感谢这一路上遇见的人和事。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>有趣！一行代码居然无法获取请求的完整URL</title>
            <link>https://isites.gitlab.io/gopher/timeline/get-full-url/</link>
            <pubDate>Mon, 29 Mar 2021 19:36:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/get-full-url/</guid>
            <description>缘起 做Web服务的时候，可能会有这样一个业务场景，获取一个HTTP请求的完整URL。很巧，老许就碰到了这样的业务场景。面对如此简单的需求，CV大法根本没有展示才能的机会。啪啪啪，获取请求的完整URL代码就出来了。
当时离验证只差一步，老许信心满满，很快，打脸来得很快就像龙卷风。。。
从图中可以知道，req.URL中的Scheme和Host均为空，所以r.URL.String()无法得到完整的请求连接。这个结果让老许一阵激动，万万没想到有一天我也有机会发现Go源码中可能遗漏的赋值。老许强行按耐住心中的激动，准备好好研究一番，万一成为了Go的Contributor呢^ω^。最后发现官方实现没有问题，因此就有了今天这篇文章。
HTTP1.1中为什么无法获取完整的连接 HTTP1.1的Server读取请求并构建Request.URL对象的逻辑在request.go文件的readRequest方法中，下面老许对其源码做一个简单分析总结。
 读取请求的第一行，HTTP请求的第一行又称为请求行。  // First line: GET /index.html HTTP/1.0 var s string if s, err = tp.ReadLine(); err != nil { 	return nil, err } 将请求行的内容分别解析为req.Method、req.RequestURI和req.Proto。  var ok bool req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s) 将req.RequestURI解析为req.URL。  rawurl := req.RequestURI if req.URL, err = url.ParseRequestURI(rawurl); err != nil { 	return nil, err }  注：当请求方法是CONNECT时，上述流程略有变化
 通过上面的流程我们知道req.URL的数据来源为req.RequestURI，而req.RequestURI到底是什么让我们继续阅读后文。
请求资源 根据rfc7230中的定义， 请求行分为请求方法、请求资源和HTTP版本，分别对应上述的req.Method、req.RequestURI和req.Proto（request-target在本文均被译作请求资源）。
关于请求方法有哪些想必不用老许在这儿科普了吧。至于常用的HTTP版本无非就是HTTP1.1和HTTP2。 下面主要介绍请求资源的几种形式。</description>
            <content type="html"><![CDATA[<h2 id="缘起">缘起</h2>
<p>做Web服务的时候，可能会有这样一个业务场景，获取一个HTTP请求的完整URL。很巧，老许就碰到了这样的业务场景。面对如此简单的需求，CV大法根本没有展示才能的机会。啪啪啪，获取请求的完整URL代码就出来了。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1b388f6771a1db510b40ef8a8d5eebae?method=download&amp;shareKey=9cb4b3dffe79b0a2eaa385a09947d7a6" alt=""></p>
<p>当时离验证只差一步，老许信心满满，很快，打脸来得很快就像龙卷风。。。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB996f7f766dd31e910911a18f8b86fa44?method=download&amp;shareKey=25f35485c3812f561c3da580916f7f4d" alt=""></p>
<p>从图中可以知道，<code>req.URL</code>中的<code>Scheme</code>和<code>Host</code>均为空，所以<code>r.URL.String()</code>无法得到完整的请求连接。这个结果让老许一阵激动，万万没想到有一天我也有机会发现Go源码中可能遗漏的赋值。老许强行按耐住心中的激动，准备好好研究一番，万一成为了Go的Contributor呢^ω^。最后发现官方实现没有问题，因此就有了今天这篇文章。</p>
<h2 id="http11中为什么无法获取完整的连接">HTTP1.1中为什么无法获取完整的连接</h2>
<p>HTTP1.1的Server读取请求并构建<code>Request.URL</code>对象的逻辑在request.go文件的<code>readRequest</code>方法中，下面老许对其源码做一个简单分析总结。</p>
<ol>
<li>读取请求的第一行，HTTP请求的第一行又称为请求行。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// First line: GET /index.html HTTP/1.0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">tp</span>.<span style="color:#a6e22e">ReadLine</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>将请求行的内容分别解析为<code>req.Method</code>、<code>req.RequestURI</code>和<code>req.Proto</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Method</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">RequestURI</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Proto</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#a6e22e">parseRequestLine</span>(<span style="color:#a6e22e">s</span>)
</span></span></code></pre></div><ol start="3">
<li>将<code>req.RequestURI</code>解析为<code>req.URL</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">rawurl</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">RequestURI</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">ParseRequestURI</span>(<span style="color:#a6e22e">rawurl</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注：当请求方法是CONNECT时，上述流程略有变化</p>
</blockquote>
<p>通过上面的流程我们知道<code>req.URL</code>的数据来源为<code>req.RequestURI</code>，而<code>req.RequestURI</code>到底是什么让我们继续阅读后文。</p>
<h3 id="请求资源">请求资源</h3>
<p>根据rfc7230中的定义， 请求行分为请求方法、请求资源和HTTP版本，分别对应上述的<code>req.Method</code>、<code>req.RequestURI</code>和<code>req.Proto</code>（request-target在本文均被译作请求资源）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fcef32e2e58798269cc3809e45c75c4?method=download&amp;shareKey=5b2a53ff2aff6ebbed544e692d92c85d" alt=""></p>
<p>关于请求方法有哪些想必不用老许在这儿科普了吧。至于常用的HTTP版本无非就是HTTP1.1和HTTP2。 下面主要介绍请求资源的几种形式。</p>
<h4 id="origin-form">origin-form</h4>
<p>这种形式是请求资源中最常见的形式，其格式定义如下。</p>
<pre tabindex="0"><code>origin-form    = absolute-path [ &#34;?&#34; query ]
</code></pre><p>当直接向服务器发起请求时，除开CONNECT和OPTIONS请求，只允许发送path和query作为请求资源。如果请求链接的path为空，则必须发送<code>/</code>作为请求资源。请求链接中的Host信息以Header头的形式发送。</p>
<p>以<code>http://www.example.org/where?q=now</code>为例，请求行和Host请求头信息如下</p>
<pre tabindex="0"><code>GET /where?q=now HTTP/1.1
Host: www.example.org
</code></pre><h4 id="absolute-form">absolute-form</h4>
<p>这种形式目前仅在向代理发起请求时使用，其格式定义如下。</p>
<pre tabindex="0"><code>absolute-form  = absolute-URI
</code></pre><p>根据rfc7230中的定义，目前client仅会向代理发送这种形式的请求资源，但为了将来某个HTTP版本可能会转换为这种形式的请求资源所以server需要支持这种形式的请求资源。这大概就是为什么<code>req.URL</code>中大部分字段值为空却仍然将URL各部分定义完整的原因。</p>
<p>一个<code>absolute-form</code>形式的请求行例子如下。</p>
<pre tabindex="0"><code>GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</code></pre><h4 id="authority-form">authority-form</h4>
<p><code>authority-form</code>形式的请求资源仅用于<code>CONNECT</code>请求中，其格式定义如下。</p>
<pre tabindex="0"><code>authority-form = authority
</code></pre><p>发送<code>CONNECT</code>请求时，client只能发送URI的authority部分（不包含userinfo和@定界符）作为请求资源。这样讲比较抽象， 我们先来看看<code>http-URI</code>的定义。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9a1f70183935d70850b51956403b3d96?method=download&amp;shareKey=34a7404d25c494cd9c889216ed50819e" alt=""></p>
<p>通过上面这张图大概能够猜出来<code>authority</code>应该是指Host信息。Very Good！你没有猜错！</p>
<pre tabindex="0"><code>The origin server for an &#34;http&#34; URI is identified by the authority component, which includes a host identifier and optional TCP port.
</code></pre><p>上面是rfc7230对于authority的解释。老许根据自己的翻译，在这里单方面宣布<code>authority</code>包括主机标识符和可选的端口信息。一个<code>authority-form</code>形式的请求行例子如下。</p>
<pre tabindex="0"><code>CONNECT www.example.com:80 HTTP/1.1
</code></pre><h4 id="asterisk-form">asterisk-form</h4>
<p><code>asterisk-form</code>形式的请求资源仅适用于<code>OPTIONS</code>请求且只能为<code>*</code>，其格式定义如下。</p>
<pre tabindex="0"><code>asterisk-form  = &#34;*&#34;
</code></pre><p>一个<code>asterisk-form</code>形式的请求行例子如下。</p>
<pre tabindex="0"><code>OPTIONS * HTTP/1.1
</code></pre><p>对上面几种形式的请求资源有所了解后，我们再次回到获取请求的完整URL这一问题本身。以最常用的<code>absolute-form</code>为例（其他形式的请求资源我们在开发中几乎不用考虑），请求资源中本身就缺少<code>Host</code>和<code>Scheme</code>信息，所以一行代码自然无法获取请求的完整URL。难道我们就无法获取到请求的完整URL嘛？当然不是，我们还可以通过以下两种方案得到完整的URL。</p>
<p><strong>方案一</strong>：</p>
<ol>
<li>通过<code>req.Host</code>得到Host相关信息。</li>
<li>如果<code>req.TLS == nil</code>则为HTTP请求，否则为HTTPS请求。</li>
<li>通过步骤1、步骤2并结合请求行信息即可得到完整的URL。</li>
</ol>
<p><strong>方案二</strong>：
在配置文件中配置好服务的Host信息，获取完整请求时只需要读取配置文件并拼接<code>req.RequestURI</code>即可。事实上老许采用的就是方案二，因为很多服务都在网关后面。当客户端使用HTTPS请求网关，网关以HTTP请求服务时使用<code>req.TLS == nil</code>判断就不合理了。</p>
<h2 id="http2中为什么无法获取完整的连接">HTTP2中为什么无法获取完整的连接</h2>
<p>需要注意的是在HTTP2中已经没有请求行的概念了，取而代之的是请求伪标头，这一点老许在<a href="https://mp.weixin.qq.com/s/HTGg5HYRSVY-4-H9Sf1zww">Go发起HTTP2.0请求流程分析(后篇)——标头压缩</a>这篇文章中提到过。</p>
<p>下图为一次HTTP2请求的部分Header信息。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB21b6c46dfb68ab42e0f5f00830a3cda5?method=download&amp;shareKey=444b90bc7502a0befde80ba2a08ae545" alt=""></p>
<p>从图中可以发现，HTTP1.1中的请求行已经没有了。根据rfc7540中的定义，请求的伪标头字段有<code>:method</code>、<code>:scheme</code>、<code>:authority</code>和<code>:path</code>。</p>
<p><code>:method</code>和<code>:scheme</code>不需要老许多说，看英文单词的意思就可以了。</p>
<p><code>:authority</code>: 根据前文的解释，其值为主机标识符和可选的端口信息。另外需要注意的是HTTP2中没有<code>Host</code>请求头。</p>
<p><code>:path</code>: 如果是<code>OPTIONS</code>请求，则其值为<code>*</code>。其他情况该值为请求URI的path和query，如果path为空则其值为<code>/</code>。</p>
<p>在对HTTP2请求的伪标头有了一个基本了解后，下面我们来看一下<code>Request.URL</code>的赋值过程。HTTP2的Server读取请求并构建<code>Request.URL</code>对象的逻辑在h2_bundle.go文件的<code>(*http2serverConn).newWriterAndRequestNoBody</code>方法中。</p>
<ol>
<li>如果是<code>CONNECT</code>请求通过<code>:authority</code>构建<code>url_</code>，否则通过<code>:path</code>构建<code>url_</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">method</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;CONNECT&#34;</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">url_</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">URL</span>{<span style="color:#a6e22e">Host</span>: <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">requestURI</span> = <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span> <span style="color:#75715e">// mimic HTTP/1 server behavior
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">url_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">url</span>.<span style="color:#a6e22e">ParseRequestURI</span>(<span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">path</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">http2streamError</span>(<span style="color:#a6e22e">st</span>.<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">http2ErrCodeProtocol</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">requestURI</span> = <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">path</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>将<code>url_</code>赋值给<code>req.URL</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">req</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Request</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Method</span>:     <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">method</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">URL</span>:        <span style="color:#a6e22e">url_</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RemoteAddr</span>: <span style="color:#a6e22e">sc</span>.<span style="color:#a6e22e">remoteAddrStr</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Header</span>:     <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">header</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">RequestURI</span>: <span style="color:#a6e22e">requestURI</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Proto</span>:      <span style="color:#e6db74">&#34;HTTP/2.0&#34;</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ProtoMajor</span>: <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ProtoMinor</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">TLS</span>:        <span style="color:#a6e22e">tlsState</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Host</span>:       <span style="color:#a6e22e">rp</span>.<span style="color:#a6e22e">authority</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Body</span>:       <span style="color:#a6e22e">body</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Trailer</span>:    <span style="color:#a6e22e">trailer</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于<code>:path</code>标头的值也不包含Host信息，所以HTTP2的server也无法通过<code>req.URL.String()</code>得到请求的完整URL。</p>
<p>在这里我们反思一个问题。通过伪标头字段已经能够得到完整的URL，为什么仍然只读取<code>:path</code>和<code>:authority</code>中的一个来赋值<code>req.URL</code>呢？</p>
<p>老许在这里猜测可能原因是希望开发者无需关心请求是HTTP1.1还是HTTP2，避免不必要的HTTP版本判断。</p>
<p>关于获取请求完整URL的思考就到这里。最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
</ol>
</blockquote>
<p>参考：</p>
<p><a href="https://tools.ietf.org/html/rfc7230">https://tools.ietf.org/html/rfc7230</a></p>
<p><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>白话Go内存模型&amp;Happen-Before</title>
            <link>https://isites.gitlab.io/gopher/timeline/go-memory-model/</link>
            <pubDate>Thu, 04 Mar 2021 18:53:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/go-memory-model/</guid>
            <description>Go内存模型明确指出，一个goroutine如何才能观察到其他goroutine对同一变量的写操作。
当多个goroutine并发同时存取同一个数据时必须把并发的存取操作序列化。在Go中保证读写的序列化可以通过channel通信或者其他同步原语（例如sync包中的互斥锁、读写锁和sync/atomic中的原子操作）。
Happens Before 在单goroutine中，读取和写入的行为一定是和程序指定的执行顺序表现一致。换言之，编译器和处理器在不改变语言规范所定义的行为前提下才可以对单个goroutine中的指令进行重排序。
a := 1 b := 2 由于指令重排序，b := 2可能先于a := 1执行。单goroutine中，该执行顺序的调整并不会影响最终结果。但多个goroutine场景下可能就会出现问题。
var a, b int // goroutine A go func() {  a := 5  b := 1 }() // goroutine B go func() {  for b == 1 {}  fmt.Println(a) }() 执行上述代码时，预期goroutine B能够正常输出5，但因为指令重排序，b := 1可能先于a := 5执行，最终goroutine B可能输出0。
 注：上述例子是个不正确的示例，仅作说明用。
 为了明确读写的操作的要求，Go中引入了happens before，它表示执行内存操作的一种偏序关系。
happens-before的作用 多个goroutine访问共享变量时，它们必须建立同步事件来确保happens-before条件，以此确保读能够观察预期的写。
什么是Happens Before 如果事件e1发生在事件e2之前，那么我们说e2发生在e1之后。 同样，如果e1不在e2之前发生也没有在e2之后发生，那么我们说e1和e2同时发生。
在单个goroutine中，happens-before的顺序就是程序执行的顺序。那happens-before到底是什么顺序呢？我们看看下面的条件。
如果对于一个变量v的读操作r和写操作w满足下述两个条件，r才允许观察到w：</description>
            <content type="html"><![CDATA[<p>Go内存模型明确指出，一个goroutine如何才能观察到其他goroutine对同一变量的写操作。</p>
<p>当多个goroutine并发同时存取同一个数据时必须把并发的存取操作序列化。在Go中保证读写的序列化可以通过channel通信或者其他同步原语（例如sync包中的互斥锁、读写锁和sync/atomic中的原子操作）。</p>
<h1 id="happens-before">Happens Before</h1>
<p>在单goroutine中，读取和写入的行为一定是和程序指定的执行顺序表现一致。换言之，编译器和处理器在不改变语言规范所定义的行为前提下才可以对单个goroutine中的指令进行重排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><p>由于指令重排序，<code>b := 2</code>可能先于<code>a := 1</code>执行。单goroutine中，该执行顺序的调整并不会影响最终结果。但多个goroutine场景下可能就会出现问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// goroutine A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// goroutine B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>执行上述代码时，预期goroutine B能够正常输出5，但因为指令重排序，<code>b := 1</code>可能先于<code>a := 5</code>执行，最终goroutine B可能输出0。</p>
<blockquote>
<p><strong>注</strong>：上述例子是个不正确的示例，仅作说明用。</p>
</blockquote>
<p>为了明确读写的操作的要求，Go中引入了<code>happens before</code>，它表示执行内存操作的一种偏序关系。</p>
<h2 id="happens-before的作用">happens-before的作用</h2>
<p>多个goroutine访问共享变量时，它们必须建立同步事件来确保happens-before条件，以此确保读能够观察预期的写。</p>
<h2 id="什么是happens-before">什么是Happens Before</h2>
<p>如果事件e1发生在事件e2之前，那么我们说e2发生在e1之后。 同样，如果e1不在e2之前发生也没有在e2之后发生，那么我们说e1和e2同时发生。</p>
<p>在单个goroutine中，happens-before的顺序就是程序执行的顺序。那happens-before到底是什么顺序呢？我们看看下面的条件。</p>
<p>如果对于一个变量v的读操作r和写操作w满足下述两个条件，r才<strong>允许</strong>观察到w：</p>
<ol>
<li>r没有发生在w之前。</li>
<li>没有其他写操作发生在w之后和r之前。</li>
</ol>
<p>为了保证变量v的一个读操作r能够观察到一个特定的写操作w，需要确保w是唯一允许被r观察的写操作。那么，如果 r、w 都满足以下条件，r就能<strong>确保</strong>观察到w：</p>
<ol>
<li>w发生在r之前。</li>
<li>其他写操作发生在w之前后者r之后。</li>
</ol>
<p>单goroutine中不存在并发，这两个条件是等价的。老许在此基础上扩展一下，对于单核心的运行环境这两组条件同样等价。并发情况下，后一组条件比第一组更加严格。</p>
<p>假如你很疑惑，那就对了！老许最开始也很疑惑，这两组条件就是一样的呀。为此老许特地和原文进行了反复对比确保上述的理解是没有问题的。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBebd7cd55c1ff407b05900807355c9010?method=download&amp;shareKey=91b03f6fdf992ed04c06d873219e3725" alt=""></p>
<p>我们换个思路，进行反向推理。如果这两组条件一样，那原文没必要写两次，果然此事并不简单。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ef1aa573f52434032ce40c6d525509f?method=download&amp;shareKey=464df8124d6c3a538a5f20189d68890c" alt=""></p>
<p>在继续分析之前，要先感谢一下我的语文老师，没有你我就无法发现它们的不同。</p>
<p><code>r没有发生在w之前</code>，则r可能的情况是r发生在w之后或者和w同时发生，如下图（实心表示可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9d6ef4da5ed351b7be9714404cea7a16?method=download&amp;shareKey=535d89b4786491f6b3ae27f7527b34bf" alt=""></p>
<p><code>没有其他写操作发生在w之后和r之前</code>，则其他写w&rsquo;可能发生在w之前或者和w同时发生，也可能发生在r之后或者和r同时发生，如下图（实心表示可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb31fc5b4f9b84711a39f34270bd4eca1?method=download&amp;shareKey=7cb5b00eca87f4552676665227d2ccd5" alt=""></p>
<p>第二组条件就很明确了，w发生在r之前且其他写操作只能发生在w之前或者r之后，如下图（空心表示不可同时）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBcd7396985d35dba916d914f9139d2ca0?method=download&amp;shareKey=bcaa56ab18dd267da16c10431ddad674" alt=""></p>
<p>到这儿应该明白为什么第二组条件比第一组条件更加严格了吧。在第一组的条件下是允许观察到w，第二组是保证能观察到w。</p>
<h1 id="go中的同步">Go中的同步</h1>
<p>下面是Go中约定好的一些同步事件，它们能确保程序遵循happens-before原则，从而使并发的goroutine相对有序。</p>
<h2 id="go的初始化">Go的初始化</h2>
<p>程序初始化运行在单个goroutine中，但是该goroutine可以创建其他并发运行的goroutine。</p>
<p>如果包p导入了包q，则q包init函数执行结束先于p包init函数的执行。main函数的执行发生在所有init函数执行完成之后。</p>
<h2 id="goroutine的创建结束">goroutine的创建结束</h2>
<p>goroutine的创建先于goroutine的执行。老许觉得这基本就是废话，但事情总是没有那么简单，其隐含之意大概是goroutine的创建是阻塞的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sleep</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sleep</span>())
</span></span></code></pre></div><p>上述代码会阻塞主goroutine一秒，然后才创建子goroutine。</p>
<p>goroutine的退出是无法预测的。如果用一个goroutine观察另一个goroutine，请使用锁或者Channel来保证相对有序。</p>
<h2 id="channel的发送和接收">Channel的发送和接收</h2>
<p>Channel通信是goroutine之间同步的主要方式。</p>
<ul>
<li>
<p>Channel的发送动作先于相应的接受动作完成之前。</p>
</li>
<li>
<p>无缓冲Channel的接受先于该Channel上的发送完成之前。</p>
</li>
</ul>
<p>这两点总结起来分别是<code>开始发送</code>、<code>开始接受</code>、<code>发送完成</code>和<code>接受完成</code>四个动作，其时序关系如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>开始发送 &gt; 接受完成
</span></span><span style="display:flex;"><span>开始接受 &gt; 发送完成
</span></span></code></pre></div><blockquote>
<p>注意：开始发送和开始接受并无明确的先后关系</p>
</blockquote>
<ul>
<li>
<p>Channel的关闭发生在由于通道关闭而返回零值接受之前。</p>
</li>
<li>
<p>容量为C的Channel第k个接受先于该Channel上的第k+C个发送完成之前。</p>
</li>
</ul>
<p>这里使用极限法应该更加易于理解，如果C为0，k为1则其含义和无缓冲Channel的一致。</p>
<h2 id="lock">Lock</h2>
<p>对于任何sync.Mutex或sync.RWMutex变量l以及n &lt; m，第n次l.Unlock()的调用先于第m次l.Lock()的调用返回。</p>
<p>假设n为1，m为2，则第二次调用l.Lock()返回前一定要先调用l.UnLock()。</p>
<p>对于sync.RWMutex的变量l存在这样一个n，使得l.RLock()的调用返回在第n次l.Unlock()之后发生，而与之匹配的l.RUnlock()发生在第n + 1次l.Lock()之前。</p>
<p>不得不说，上面这句话简直不是人能理解的。老许将其翻译成人话：</p>
<p>有写锁时：l.RLock()的调用返回发生在l.Unlock()之后。</p>
<p>有读锁时：l.RUnlock()的调用发生在l.Lock()之前。</p>
<blockquote>
<p>注意：调用l.RUnlock()前不调用l.RLock()和调用l.Unlock()前不调用l.Lock()会引起panic。</p>
</blockquote>
<h2 id="once">Once</h2>
<p>once.Do(f)中f的返回先于任意其他once.Do的返回。</p>
<h1 id="不正确的同步">不正确的同步</h1>
<p><strong>错误示范一</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">g</span>() {
</span></span><span style="display:flex;"><span>	print(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	print(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">g</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个例子看起来挺简单，但是老许相信大部分人应该会忽略指令重排序引起的异常输出。假如goroutine f指令重排序后，<code>b=2</code>先于<code>a=1</code>发生，此时主goroutine观察到b发生变化而未观察到a变化，因此有可能输出<code>20</code>。</p>
<blockquote>
<p>老许在本地实验了多次结果都是输出<code>00</code>，<code>20</code>这个输出估计只活在理论之中了。</p>
</blockquote>
<p><strong>错误示范二</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">done</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setup</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span> = <span style="color:#e6db74">&#34;hello, world&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doprint</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">done</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">once</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">setup</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	print(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoprint</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">doprint</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这种双重检测本意是为了避免同步的开销，但是依旧有可能打印出空字符串而不是“hello, world”。说实话老许自己都不敢保证以前没有写过这样的代码。现在唯一能想到的场景就是其中一个goroutine doprint执行到<code>done = true</code>（指令重排序导致<code>done=true</code>先于<code>a=&quot;hello, world&quot;</code>执行）时，另一个goroutine doprint刚开始执行并观察到done的值为true从而打印空字符串。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。当然，发现错误也还请及时联系老许改正。</p>
<p><strong>参考</strong></p>
<p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>1分钟内的Linux性能分析法</title>
            <link>https://isites.gitlab.io/gopher/timeline/60-linux/</link>
            <pubDate>Mon, 01 Feb 2021 20:30:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/60-linux/</guid>
            <description>本着“拿来主义”的精神，吸收他人长处为己用。老许翻译一篇Linux性能分析相关的文章分享给各位读者，同时也加深自己的印象。
 你登录到具有性能问题的Linux服务器时，第一分钟要检查什么？
在Netflix，我们拥有庞大的Linux EC2云实例，以及大量的性能分析工具来监视和调查它们的性能。这些工具包括Atlas和Vector。Atlas用于全云监控，Vector用于按需实例分析。这些工具能帮助我们解决大部分问题，但有时候我们仍需登录实例并运行一些标准的Linux性能工具。
 Atlas：根据github上面的文档老许简单说一下自己的认知。一个可以管理基于时间维度数据的后端，同时具有内存存储功能可以非常快速地收集和报告大量指标。
Vector：Vector是一个主机上的性能监视框架，它可以将各种指标展示在工程师的浏览器上面。
 总结 在这篇文章中，Netflix性能工程团队将向您展示通过命令行进行性能分析是，前60秒应该使用那些Linux标准工具。在60秒内，你可以通过以下10个命令来全面了解系统资源使用情况和正在运行的进程。首先寻找错误和饱和指标，因为他们很容易理解，然后是资源利用率。饱和是指资源负载超出其处理能力，其可以表现为一个请求队列的长度或者等待时间。
uptime dmesg | tail vmstat 1 mpstat -P ALL 1 pidstat 1 iostat -xz 1 free -m sar -n DEV 1 sar -n TCP,ETCP 1 top 其中一些命令需要安装sysstat软件包。这些命令暴露的指标是一种帮助你完成USE Method（Utilization Saturation and Errors Method）——一种查找性能瓶颈的方法。这涉及检查所有资源（CPU、内存、磁盘等）利用率，饱和度和错误等指标。同时还需注意通过排除法可以逐步缩小资源检查范围。
以下各节通过生产系统中的示例总结了这些命令。这些命令的更多信息，请参考使用手册。
uptime $ uptime 23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02 这是一种快速查看平均负载的方法，它指示了等待运行的进程数量。在Linux系统上，这些数字包括要在CPU上运行的进程以及处于I/O（通常是磁盘I/O）阻塞的进程。这提供了资源负载的大概状态，没有其他工具就无法理解更多。仅值得一看。
这三个数字分别代表着1分钟、5分钟和15分钟内的平均负载。这三个指标让我们了解负载是如何随时间变化的。例如，你被要求检查有问题的服务器，而1分钟的值远低于15分钟的值，则意味着你可能登录的太晚而错过了问题现场。
在上面的例子中，最近的平均负载增加，一分钟值达到30，而15分钟值达到19。数字如此之大意味着很多：可能是CPU需求（可以通过后文中介绍的vmstat或mpstat命令来确认）。
dmesg | tail $ dmesg | tail [1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0 [.</description>
            <content type="html"><![CDATA[<blockquote>
<p>本着“拿来主义”的精神，吸收他人长处为己用。老许翻译一篇Linux性能分析相关的文章分享给各位读者，同时也加深自己的印象。</p>
</blockquote>
<p>你登录到具有性能问题的Linux服务器时，第一分钟要检查什么？</p>
<p>在Netflix，我们拥有庞大的Linux EC2云实例，以及大量的性能分析工具来监视和调查它们的性能。这些工具包括<code>Atlas</code>和<code>Vector</code>。<code>Atlas</code>用于全云监控，<code>Vector</code>用于按需实例分析。这些工具能帮助我们解决大部分问题，但有时候我们仍需登录实例并运行一些标准的Linux性能工具。</p>
<blockquote>
<p>Atlas：根据github上面的文档老许简单说一下自己的认知。一个可以管理基于时间维度数据的后端，同时具有内存存储功能可以非常快速地收集和报告大量指标。</p>
<p>Vector：Vector是一个主机上的性能监视框架，它可以将各种指标展示在工程师的浏览器上面。</p>
</blockquote>
<h3 id="总结">总结</h3>
<p>在这篇文章中，Netflix性能工程团队将向您展示通过命令行进行性能分析是，前60秒应该使用那些Linux标准工具。在60秒内，你可以通过以下10个命令来全面了解系统资源使用情况和正在运行的进程。首先寻找错误和饱和指标，因为他们很容易理解，然后是资源利用率。饱和是指资源负载超出其处理能力，其可以表现为一个请求队列的长度或者等待时间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>uptime
</span></span><span style="display:flex;"><span>dmesg | tail
</span></span><span style="display:flex;"><span>vmstat <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>mpstat -P ALL <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>pidstat <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>iostat -xz <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>free -m
</span></span><span style="display:flex;"><span>sar -n DEV <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>sar -n TCP,ETCP <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>top
</span></span></code></pre></div><p>其中一些命令需要安装sysstat软件包。这些命令暴露的指标是一种帮助你完成<code>USE Method（Utilization Saturation and Errors Method）</code>——一种查找性能瓶颈的方法。这涉及检查所有资源（CPU、内存、磁盘等）利用率，饱和度和错误等指标。同时还需注意通过排除法可以逐步缩小资源检查范围。</p>
<p>以下各节通过生产系统中的示例总结了这些命令。这些命令的更多信息，请参考使用手册。</p>
<h3 id="uptime">uptime</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ uptime 
</span></span><span style="display:flex;"><span>23:51:26 up 21:31, <span style="color:#ae81ff">1</span> user, load average: 30.02, 26.43, 19.02
</span></span></code></pre></div><p>这是一种快速查看平均负载的方法，它指示了等待运行的进程数量。在Linux系统上，这些数字包括要在CPU上运行的进程以及处于I/O（通常是磁盘I/O）阻塞的进程。这提供了资源负载的大概状态，没有其他工具就无法理解更多。仅值得一看。</p>
<p>这三个数字分别代表着1分钟、5分钟和15分钟内的平均负载。这三个指标让我们了解负载是如何随时间变化的。例如，你被要求检查有问题的服务器，而1分钟的值远低于15分钟的值，则意味着你可能登录的太晚而错过了问题现场。</p>
<p>在上面的例子中，最近的平均负载增加，一分钟值达到30，而15分钟值达到19。数字如此之大意味着很多：可能是CPU需求（可以通过后文中介绍的vmstat或mpstat命令来确认）。</p>
<h3 id="dmesg--tail">dmesg | tail</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ dmesg | tail
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>1880957.563150<span style="color:#f92672">]</span> perl invoked oom-killer: gfp_mask<span style="color:#f92672">=</span>0x280da, order<span style="color:#f92672">=</span>0, oom_score_adj<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>1880957.563400<span style="color:#f92672">]</span> Out of memory: Kill process <span style="color:#ae81ff">18694</span> <span style="color:#f92672">(</span>perl<span style="color:#f92672">)</span> score <span style="color:#ae81ff">246</span> or sacrifice child
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>1880957.563408<span style="color:#f92672">]</span> Killed process <span style="color:#ae81ff">18694</span> <span style="color:#f92672">(</span>perl<span style="color:#f92672">)</span> total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>2320864.954447<span style="color:#f92672">]</span> TCP: Possible SYN flooding on port 7001. Dropping request.  Check SNMP counters.
</span></span></code></pre></div><p>如果有消息，它将查看最近的10条系统消息。通过此命令查找可能导致性能问题的错误。上面的示例包括<code>oom-killer</code>和TCP丢弃请求。</p>
<p>不要错过这一步！<code>dmesg</code>始终值得被检查。</p>
<h3 id="vmstat-1">vmstat 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ vmstat <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----
</span></span><span style="display:flex;"><span> r  b swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">34</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889792</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591828</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">5</span>    <span style="color:#ae81ff">6</span>   <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">96</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">3</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889920</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">592</span> <span style="color:#ae81ff">13284</span> <span style="color:#ae81ff">4282</span> <span style="color:#ae81ff">98</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200890112</span>  <span style="color:#ae81ff">73708</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">9501</span> <span style="color:#ae81ff">2154</span> <span style="color:#ae81ff">99</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200889568</span>  <span style="color:#ae81ff">73712</span> <span style="color:#ae81ff">591856</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">11900</span> <span style="color:#ae81ff">2459</span> <span style="color:#ae81ff">99</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">32</span>  <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">200890208</span>  <span style="color:#ae81ff">73712</span> <span style="color:#ae81ff">591860</span>    <span style="color:#ae81ff">0</span>    <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span>     <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">15898</span> <span style="color:#ae81ff">4840</span> <span style="color:#ae81ff">98</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p>vmstat是虚拟内存状态的缩写。它在每一行上打印关键服务的统计信息。</p>
<p>vmstat在参数1下运行，以显示一秒钟的摘要。在某些版本中，第一行的某些列展示的是自启动以来的平均值，而不是前一秒的平均值。现在请跳过第一行，除非你想学习并记住那一列是那一列。</p>
<p>要检查的列：</p>
<ul>
<li><strong>r</strong>：在CPU上运行并等待切换的进程数。这为确定CPU饱和比平均负载提供了更好的信号，因为它不包括I/O。简单来说就是：r的值大于CPU数量即为饱和状态。</li>
<li><strong>free</strong>：可用内存以字节为单位，如果数字很大，则说明你有足够的可用内存。<code>free -m</code>命令能够更好的描述此状态。</li>
<li><strong>si, so</strong>：swap-ins和swap-outs. 如果这两个值不为0，则说明内存不足。</li>
<li><strong>us, sy, id, wa, st</strong>：这是总CPU时间的百分比。他们分别是用户时间、系统时间（内核）、空闲时间（包括I/O等待）、I/O等待和被盗时间（虚拟机所消耗的时间）。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB01cdb925877dcd06f2f969101decea65?method=download&amp;shareKey=5388ed636ef3cecb60d096cff7ad6615" alt=""></p>
<blockquote>
<p>最后关于us, sy, id, wa, st的解释和原文不太一样，所以老许贴一下vmstat手册中的解释。</p>
</blockquote>
<p>通过用户时间+系统时间来确认CPU是否繁忙。如果有持续的等待I/O，意味着磁盘瓶颈。这是CPU空闲的时候，因为任务等待I/O被阻塞。你可以将I/O等待视为CPU空闲的另一种形式，同时它也提供了CPU为什么空闲的线索。</p>
<p>I/O处理需要消耗系统时间。一个系统时间占比较高（比如超过20%）值得进一步研究，可能是内核处理I/O的效率低下。</p>
<p>在上面的例子中，CPU时间几乎完全处于用户级别，即CPU时间几乎被应用程序占用。CPU平均利用率也超过90%，这不一定是问题，还需要通过r列的值检查饱和度。</p>
<h3 id="mpstat--p-all-1">mpstat -P ALL 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ mpstat -P ALL <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015  _x86_64_ <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle
</span></span><span style="display:flex;"><span>07:38:50 PM  all  98.47   0.00   0.75    0.00   0.00   0.00    0.00    0.00    0.00   0.78
</span></span><span style="display:flex;"><span>07:38:50 PM    <span style="color:#ae81ff">0</span>  96.04   0.00   2.97    0.00   0.00   0.00    0.00    0.00    0.00   0.99
</span></span><span style="display:flex;"><span>07:38:50 PM    <span style="color:#ae81ff">1</span>  97.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   2.00
</span></span><span style="display:flex;"><span>07:38:50 PM    <span style="color:#ae81ff">2</span>  98.00   0.00   1.00    0.00   0.00   0.00    0.00    0.00    0.00   1.00
</span></span><span style="display:flex;"><span>07:38:50 PM    <span style="color:#ae81ff">3</span>  96.97   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00   3.03
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>此命令用于显示每个CPU的CPU时间明细，可用于检查不平衡的情况。单个热CPU可能是因为存在一个单线程应用。</p>
<h3 id="pidstat-1">pidstat 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ pidstat <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015    _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>07:41:02 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
</span></span><span style="display:flex;"><span>07:41:03 PM     <span style="color:#ae81ff">0</span>         <span style="color:#ae81ff">9</span>    0.00    0.94    0.00    0.94     <span style="color:#ae81ff">1</span>  rcuos/0
</span></span><span style="display:flex;"><span>07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4214</span>    5.66    5.66    0.00   11.32    <span style="color:#ae81ff">15</span>  mesos-slave
</span></span><span style="display:flex;"><span>07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4354</span>    0.94    0.94    0.00    1.89     <span style="color:#ae81ff">8</span>  java
</span></span><span style="display:flex;"><span>07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6521</span> 1596.23    1.89    0.00 1598.11    <span style="color:#ae81ff">27</span>  java
</span></span><span style="display:flex;"><span>07:41:03 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6564</span> 1571.70    7.55    0.00 1579.25    <span style="color:#ae81ff">28</span>  java
</span></span><span style="display:flex;"><span>07:41:03 PM <span style="color:#ae81ff">60004</span>     <span style="color:#ae81ff">60154</span>    0.94    4.72    0.00    5.66     <span style="color:#ae81ff">9</span>  pidstat
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>07:41:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
</span></span><span style="display:flex;"><span>07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">4214</span>    6.00    2.00    0.00    8.00    <span style="color:#ae81ff">15</span>  mesos-slave
</span></span><span style="display:flex;"><span>07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6521</span> 1590.00    1.00    0.00 1591.00    <span style="color:#ae81ff">27</span>  java
</span></span><span style="display:flex;"><span>07:41:04 PM     <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">6564</span> 1573.00   10.00    0.00 1583.00    <span style="color:#ae81ff">28</span>  java
</span></span><span style="display:flex;"><span>07:41:04 PM   <span style="color:#ae81ff">108</span>      <span style="color:#ae81ff">6718</span>    1.00    0.00    0.00    1.00     <span style="color:#ae81ff">0</span>  snmp-pass
</span></span><span style="display:flex;"><span>07:41:04 PM <span style="color:#ae81ff">60004</span>     <span style="color:#ae81ff">60154</span>    1.00    4.00    0.00    5.00     <span style="color:#ae81ff">9</span>  pidstat
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p><code>pidstat</code>有点像top的每个进程摘要，但是会打印滚动摘要，而不是清除屏幕。这对于观察随时间变化的模式很有用，还可以将看到的内容记录下来。</p>
<p>上面的示例中，两个java进程消耗了大部分CPU时间。%CPU这一列是所有CPU的总和。<code>1591%</code>意味着java进程几乎耗尽了16个CPU。</p>
<h3 id="iostat--xz-1">iostat -xz 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ iostat -xz <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015  _x86_64_ <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>avg-cpu:  %user   %nice %system %iowait  %steal   %idle
</span></span><span style="display:flex;"><span>          73.96    0.00    3.73    0.03    0.06   22.21
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Device:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
</span></span><span style="display:flex;"><span>xvda        0.00     0.23    0.21    0.18     4.52     2.08    34.37     0.00    9.98   13.80    5.42   2.44   0.09
</span></span><span style="display:flex;"><span>xvdb        0.01     0.00    1.02    8.94   127.97   598.53   145.79     0.00    0.43    1.78    0.28   0.25   0.25
</span></span><span style="display:flex;"><span>xvdc        0.01     0.00    1.02    8.86   127.79   595.94   146.50     0.00    0.45    1.82    0.30   0.27   0.26
</span></span><span style="display:flex;"><span>dm-0        0.00     0.00    0.69    2.32    10.47    31.69    28.01     0.01    3.23    0.71    3.98   0.13   0.04
</span></span><span style="display:flex;"><span>dm-1        0.00     0.00    0.00    0.94     0.01     3.78     8.00     0.33  345.84    0.04  346.81   0.01   0.00
</span></span><span style="display:flex;"><span>dm-2        0.00     0.00    0.09    0.07     1.35     0.36    22.50     0.00    2.55    0.23    5.62   1.78   0.03
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>...<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p>这是一个非常好的工具，不仅可以了解块设备（磁盘）的工作负载还可以了解其性能。</p>
<ul>
<li><strong>r/s, w/s, rkB/s, wkB/s</strong>：分别表示每秒交付给设备的读写请求数和每秒读写的KB数。这些可以描述设备的工作负载。性能问题可能仅仅是由于施加了过多的负载。</li>
<li><strong>await</strong>：I/O处理时间（毫秒为单位），这包括队列中请求所花费的时间以及为请求服务所花费的时间。如果值大于预期的平均时间，可能是因为设备已经饱和或设备出现问题。</li>
<li><strong>avgqu-sz</strong>：发送给设备请求的平均队列长度。该值大于1表明设备已达饱和状态（尽管设备通常可以并行处理请求，尤其是有多个后端磁盘的虚拟设备）。</li>
<li><strong>%util</strong>：设备利用率。这是一个显示设备是否忙碌的百分比，其含义为设备每秒的工作时间占比。该值大于60%时通常会导致性能不佳（可以在await中看出来），不过它也和具体的设备有关。值接近100%时，意味着设备已饱和。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd50303583de5aa29ab979335165035d3?method=download&amp;shareKey=12535f772898d9ce28dd23ebcc104686" alt=""></p>
<blockquote>
<p>关于avgqu-sz的解释和原文不太一样，所以老许贴一下iostat手册中的解释。</p>
</blockquote>
<p>如果存储设备是位于很多磁盘前面的逻辑磁盘设备，则100%利用率可能仅仅意味着所有时间都在处理I/O，但是后端磁盘可能远远还没有饱和，而且还能处理更多的工作。</p>
<p>请记住，磁盘I/O性能不佳不一定是应用程序的问题。通常使用许多技术来异步执行I/O，以保证应用程序不被阻塞或直接遭受延迟（例如，预读用于读取，缓冲用于写入）。</p>
<h3 id="free--m">free -m</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ free -m
</span></span><span style="display:flex;"><span>             total       used       free     shared    buffers     cached
</span></span><span style="display:flex;"><span>Mem:        <span style="color:#ae81ff">245998</span>      <span style="color:#ae81ff">24545</span>     <span style="color:#ae81ff">221453</span>         <span style="color:#ae81ff">83</span>         <span style="color:#ae81ff">59</span>        <span style="color:#ae81ff">541</span>
</span></span><span style="display:flex;"><span>-/+ buffers/cache:      <span style="color:#ae81ff">23944</span>     <span style="color:#ae81ff">222053</span>
</span></span><span style="display:flex;"><span>Swap:            <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>          <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>看最右边两列：</p>
<ul>
<li><strong>buffers</strong>：缓冲区缓存，用于块设备I/O。</li>
<li><strong>cached</strong>：页缓存，用于文件系统。</li>
</ul>
<p>我们检查他们的值是否接近0，接近0会导致更高的磁盘I/O（可以通过iostat来确认）以及更糟糕的磁盘性能。上面的示例看起来不错，每个值都有许多兆字节。</p>
<p><code>-/+ buffers/cache</code>为已用内存和可用内存提供更加清晰的描述。Linux将部分空闲内存用作缓存，但是在应用程序需要时可以快速回收。因此，用作缓存的内存应该应该以某种方式包含在free这一列，<code>-/+ buffers/cache</code>这一行就是做这个事情的。</p>
<blockquote>
<p>上面这一段翻译，可能比较抽象，感觉说的不像人话，老许来转述成人能理解的话：</p>
<p>total = used + free</p>
<p>used = (-/+ buffers/cache这一行used对应列) + buffers + cached</p>
<p>=&gt; 24545 = 23944 + 59 + 541</p>
<p>free = (-/+ buffers/cache这一行free对应列) - buffers - cached</p>
<p>=&gt; 221453 = 222053 - 59 - 541</p>
</blockquote>
<p>如果在Linux使用了ZFS会令人更加疑惑（就像我们对某些服务所做的一样），因为ZFS有自己的文件系统缓存。而<code>free -m</code>并不能正确反应该文件系统缓存。它可能表现为，系统可用内存不足，而实际上该内存可根据需要从ZFS缓存中使用。</p>
<blockquote>
<p>ZFS: Zettabyte File System,也叫动态文件系统，更多信息见百度百科</p>
</blockquote>
<h3 id="sar--n-dev-1">sar -n DEV 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sar -n DEV <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015     _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
</span></span><span style="display:flex;"><span>12:16:49 AM      eth0  18763.00   5032.00  20686.42    478.30      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>12:16:49 AM        lo     14.00     14.00      1.36      1.36      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>12:16:49 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
</span></span><span style="display:flex;"><span>12:16:50 AM      eth0  19763.00   5101.00  21999.10    482.56      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>12:16:50 AM        lo     20.00     20.00      3.25      3.25      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>12:16:50 AM   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p>可以用这个工具检查网络接口的吞吐量： rxkB/s和txkB/s。作为工作负载的度量，还可以检查吞吐量是否达到上限。在上面的列子中，eth0的接受速度达到22Mbyte/s（176Mbit/s），该值远低于1Gbit/s的限制。</p>
<blockquote>
<p>原文中无rxkB/s和txkB/s的解释，老许特意找了使用手册中的说明。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc64cc99088cee47bede3119305116a7c?method=download&amp;shareKey=238ac957dd1380595eb90706cfb9c157" alt=""></p>
<p>这个版本还有%ifutil作设备利用率，这也是我们使用Brendan的nicstat工具来测量的。和nicstat工具一样，这很难正确，而且本例中看起来该值并不起作用。</p>
<blockquote>
<p>老许试了一下自己的云服务发现%ifutil指标并不一定都有。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46426284a4f97e9d965dc6c74b3045c0?method=download&amp;shareKey=341078089ef7ed5608f35d1bef2f516a" alt=""></p>
<h3 id="sar--n-tcpetcp-1">sar -n TCP,ETCP 1</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sar -n TCP,ETCP <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Linux 3.13.0-49-generic <span style="color:#f92672">(</span>titanclusters-xxxxx<span style="color:#f92672">)</span>  07/14/2015    _x86_64_    <span style="color:#f92672">(</span><span style="color:#ae81ff">32</span> CPU<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:17:19 AM  active/s passive/s    iseg/s    oseg/s
</span></span><span style="display:flex;"><span>12:17:20 AM      1.00      0.00  10233.00  18846.00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
</span></span><span style="display:flex;"><span>12:17:20 AM      0.00      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:17:20 AM  active/s passive/s    iseg/s    oseg/s
</span></span><span style="display:flex;"><span>12:17:21 AM      1.00      0.00   8359.00   6039.00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s
</span></span><span style="display:flex;"><span>12:17:21 AM      0.00      0.00      0.00      0.00      0.00
</span></span><span style="display:flex;"><span>^C
</span></span></code></pre></div><p>这是一些关键TCP指标的总结。其中包括：</p>
<ul>
<li><strong>active/s</strong>：本地每秒启动的TCP连接数（例如，通过connect()）。</li>
<li><strong>passive/s</strong>：远程每秒启动的TCP连接数（例如，通过accept()）</li>
<li><strong>retrans/s</strong>：TCP每秒重传次数。</li>
</ul>
<p>active和passive连接数通常用于服务器负载的粗略度量。将active视为向外的连接，passive视为向内的连接可能会有帮助，但这样区分并不严格（例如，localhost连接到localhost）。</p>
<p>重传是网络或服务器出问题的迹象。它可能是不可靠的网络（例如，公共Internet），也可能是由于服务器过载并丢弃了数据包。上面的示例显示每秒仅一个新的TCP连接。</p>
<h3 id="top">top</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ top
</span></span><span style="display:flex;"><span>top - 00:15:40 up 21:56,  <span style="color:#ae81ff">1</span> user,  load average: 31.09, 29.87, 29.92
</span></span><span style="display:flex;"><span>Tasks: <span style="color:#ae81ff">871</span> total,   <span style="color:#ae81ff">1</span> running, <span style="color:#ae81ff">868</span> sleeping,   <span style="color:#ae81ff">0</span> stopped,   <span style="color:#ae81ff">2</span> zombie
</span></span><span style="display:flex;"><span>%Cpu<span style="color:#f92672">(</span>s<span style="color:#f92672">)</span>: 96.8 us,  0.4 sy,  0.0 ni,  2.7 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
</span></span><span style="display:flex;"><span>KiB Mem:  25190241+total, <span style="color:#ae81ff">24921688</span> used, 22698073+free,    <span style="color:#ae81ff">60448</span> buffers
</span></span><span style="display:flex;"><span>KiB Swap:        <span style="color:#ae81ff">0</span> total,        <span style="color:#ae81ff">0</span> used,        <span style="color:#ae81ff">0</span> free.   <span style="color:#ae81ff">554208</span> cached Mem
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">20248</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>  0.227t 0.012t  <span style="color:#ae81ff">18748</span> S  <span style="color:#ae81ff">3090</span>  5.2  29812:58 java
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">4213</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2722544</span>  <span style="color:#ae81ff">64640</span>  <span style="color:#ae81ff">44232</span> S  23.5  0.0 233:35.37 mesos-slave
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">66128</span> titancl+  <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">24344</span>   <span style="color:#ae81ff">2332</span>   <span style="color:#ae81ff">1172</span> R   1.0  0.0   0:00.07 top
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">5235</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> 38.227g <span style="color:#ae81ff">547004</span>  <span style="color:#ae81ff">49996</span> S   0.7  0.2   2:02.74 java
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">4299</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span> 20.015g 2.682g  <span style="color:#ae81ff">16836</span> S   0.3  1.1  33:14.42 java
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">1</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>   <span style="color:#ae81ff">33620</span>   <span style="color:#ae81ff">2920</span>   <span style="color:#ae81ff">1496</span> S   0.0  0.0   0:03.82 init
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">2</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:00.02 kthreadd
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">3</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:05.35 ksoftirqd/0
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">5</span> root       <span style="color:#ae81ff">0</span> -20       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:00.00 kworker/0:0H
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">6</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   0:06.94 kworker/u256:0
</span></span><span style="display:flex;"><span>     <span style="color:#ae81ff">8</span> root      <span style="color:#ae81ff">20</span>   <span style="color:#ae81ff">0</span>       <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span>      <span style="color:#ae81ff">0</span> S   0.0  0.0   2:38.05 rcu_sched
</span></span></code></pre></div><p>top命令包含我们之前检查的许多指标。运行它可以很方便地查看是否有任何东西和之前的命令结果差别很大。</p>
<p>top的缺点是随着时间推移不能看到相关变化，像vmstat和pidstat之类提供滚动输出的工具则能体现的更加清楚。如果你没有足够快地暂停输出（Ctrl-S暂停, Ctrl-Q继续），随着屏幕的清除间歇性问题的证据很有可能丢失。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<p>翻译原文</p>
<p><a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55">https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55</a></p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>Go中的SSRF攻防战</title>
            <link>https://isites.gitlab.io/gopher/timeline/go-ssrf/</link>
            <pubDate>Tue, 19 Jan 2021 20:30:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/go-ssrf/</guid>
            <description>写在最前面 “年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。
关于自称，老许就不扯太远了，下面还是回到本篇的主旨。
什么是SSRF SSRF英文全拼为Server Side Request Forgery，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。
上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。
“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。
回合一：千变万化的内网地址 为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用182.61.200.7（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。
   格式 值 描述     点分十进制 182.61.200.7 常规表现方式   点分八进制 0266.075.0310.07 每个字节被单独转换为八进制   点分十六进制 0xb6.0x3d.0xc8.0x7 每个字节被单独转换为十六进制   十进制 3057502215 用十进制写出的32位整数   八进制 026617344007 用八进制写出32位整数   十六进制 0xb63dc807 用十六进制写出32位整数   点分混合制（4） 182.0x3d.0310.7等 点分格式中，每个字节都可用任意的进制表达   点分混合制（3） 182.0x3d.0144007等 将后面16位用八进制表示   点分混合制（2） 182.4048903等 将后面24为用10进制表示    注意⚠️：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。
上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址0:0:0:0:0:0:0:1为例。</description>
            <content type="html"><![CDATA[<h3 id="写在最前面">写在最前面</h3>
<p>“年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。</p>
<p>关于自称，老许就不扯太远了，下面还是回到本篇的主旨。</p>
<h3 id="什么是ssrf">什么是SSRF</h3>
<p>SSRF英文全拼为<code>Server Side Request Forgery</code>，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5e3f093a7664785b0c96e4d4a4fdd095?method=download&amp;shareKey=30bddd4078d8dbe0f8bd62c34814ad94" alt=""></p>
<p>上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。</p>
<p>“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。</p>
<h3 id="回合一千变万化的内网地址">回合一：千变万化的内网地址</h3>
<p>为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用<code>182.61.200.7</code>（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">点分十进制</td>
<td style="text-align:left">182.61.200.7</td>
<td style="text-align:left">常规表现方式</td>
</tr>
<tr>
<td style="text-align:left">点分八进制</td>
<td style="text-align:left">0266.075.0310.07</td>
<td style="text-align:left">每个字节被单独转换为八进制</td>
</tr>
<tr>
<td style="text-align:left">点分十六进制</td>
<td style="text-align:left">0xb6.0x3d.0xc8.0x7</td>
<td style="text-align:left">每个字节被单独转换为十六进制</td>
</tr>
<tr>
<td style="text-align:left">十进制</td>
<td style="text-align:left">3057502215</td>
<td style="text-align:left">用十进制写出的32位整数</td>
</tr>
<tr>
<td style="text-align:left">八进制</td>
<td style="text-align:left">026617344007</td>
<td style="text-align:left">用八进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">0xb63dc807</td>
<td style="text-align:left">用十六进制写出32位整数</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（4）</td>
<td style="text-align:left">182.0x3d.0310.7等</td>
<td style="text-align:left">点分格式中，每个字节都可用任意的进制表达</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（3）</td>
<td style="text-align:left">182.0x3d.0144007等</td>
<td style="text-align:left">将后面16位用八进制表示</td>
</tr>
<tr>
<td style="text-align:left">点分混合制（2）</td>
<td style="text-align:left">182.4048903等</td>
<td style="text-align:left">将后面24为用10进制表示</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。</p>
<p>上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址<code>0:0:0:0:0:0:0:1</code>为例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">格式</th>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒分十六进制表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0:1</td>
<td style="text-align:left">格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16b，每个X的前导0是可以省略</td>
</tr>
<tr>
<td style="text-align:left">0位压缩表示法</td>
<td style="text-align:left">::1</td>
<td style="text-align:left">连续的一段0可以压缩为“::”，但”::”只能出现一次</td>
</tr>
<tr>
<td style="text-align:left">内嵌IPv4地址表示法</td>
<td style="text-align:left">0:0:0:0:0:0:0.0.0.1</td>
<td style="text-align:left">X:X:X:X:X:X:d.d.d.d（前96b使用冒分十六进制，最后32b地址则使用IPv4的点分十进制表示）</td>
</tr>
</tbody>
</table>
<p><strong>注意⚠️</strong>：冒分十六进制表示法中每个X的前导0是可以省略的，那么我可以部分省略，部分不省略，从而将一个IPv6地址写出不同的表现形式。0位压缩表示法和内嵌IPv4地址表示法同理也可以将一个IPv6地址写出不同的表现形式。</p>
<p>讲了这么多，老许已经无法统计一个IP可以有多少种不同的写法，麻烦数学好的算一下。</p>
<p>内网IP你以为到这儿就完了嘛？当然不！不知道各位读者有没有听过<code>xip.io</code>这个域名。<code>xip</code>可以帮你做自定义的DNS解析，并且可以解析到任意IP地址（包括内网）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB85b07b5da343c8b1be8be6bdd19869f5?method=download&amp;shareKey=a3ffcab0e1c03fbfa6383c5d736f3ea4" alt=""></p>
<p>我们通过<code>xip</code>提供的域名解析，还可以将内网IP通过域名的方式进行访问。</p>
<p>关于内网IP的访问到这儿仍将继续！搞过Basic验证的应该都知道，可以通过<code>http://user:passwd@hostname/</code>进行资源访问。如果攻击者换一种写法或许可以绕过部分不够严谨的逻辑，如下所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBac6328b4d92be511501ea6d4d2a7042d?method=download&amp;shareKey=86a8308849c419d602d621b2bab1c93d" alt=""></p>
<p>关于内网地址，老许掏空了所有的知识储备总结出上述内容，因此老许说一句千变万化的内网地址不过分吧！</p>
<p>此时此刻，老许只想问一句，当恶意攻击者用这些不同表现形式的内网地址进行图片上传时，你怎么将其识别出来并拒绝访问。不会真的有大佬用正则表达式完成上述过滤吧，如果有请留言告诉我让小弟学习一下。</p>
<p>花样百出的内网地址我们已经基本了解，那么现在的问题是怎么将其转为一个我们可以进行判断的IP。总结上面的内网地址可分为三类：一、本身就是IP地址，仅表现形式不统一；二、一个指向内网IP的域名；三、一个包含Basic验证信息和内网IP的地址。根据这三类特征，在发起请求之前按照如下步骤可以识别内网地址并拒绝访问。</p>
<ol>
<li>解析出地址中的HostName。</li>
<li>发起DNS解析，获得IP。</li>
<li>判断IP是否是内网地址。</li>
</ol>
<p>上述步骤中关于内网地址的判断，请不要忽略IPv6的回环地址和IPv6的唯一本地地址。下面是老许判断IP是否为内网IP的逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// IsLocalIP 判断是否是内网ip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断是否是回环地址, ipv4时是127.0.0.1；ipv6时是::1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">IsLoopback</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断ipv4是否是内网
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To4</span>(); <span style="color:#a6e22e">ip4</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">||</span> <span style="color:#75715e">// 10.0.0.0/8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">172</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">16</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">31</span>) <span style="color:#f92672">||</span> <span style="color:#75715e">// 172.16.0.0/12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			(<span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">192</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ip4</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">168</span>) <span style="color:#75715e">// 192.168.0.0/16
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 判断ipv6是否是内网
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">To16</span>(); <span style="color:#a6e22e">ip16</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 参考 https://tools.ietf.org/html/rfc4193#section-3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 参考 https://en.wikipedia.org/wiki/Private_network#Private_IPv6_addresses
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 判断ipv6唯一本地地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xfd</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">ip16</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 不是ip直接返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下图为按照上述步骤检测请求是否是内网请求的结果。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB733788caa1f3e7307a0eb6eaf237db5e?method=download&amp;shareKey=5df8b437bde3f8a6b40eb03f66e15d57" alt=""></p>
<p><strong>小结</strong>：URL形式多样，可以使用DNS解析获取规范的IP，从而判断是否是内网资源。</p>
<h3 id="回合二url跳转">回合二：URL跳转</h3>
<p>如果恶意攻击者仅通过IP的不同写法进行攻击，那我们自然可以高枕无忧，然而这场矛与盾的较量才刚刚开局。</p>
<p>我们回顾一下回合一的防御策略，检测请求是否是内网资源是在正式发起请求之前，如果攻击者在请求过程中通过URL跳转进行内网资源访问则完全可以绕过回合一中的防御策略。具体攻击流程如下。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe9de4e2a016b1d1f9b0d2dfa09ba7811?method=download&amp;shareKey=65a87ed928726fc6c7fc34d362b1824d" alt=""></p>
<p>如图所示，通过URL跳转攻击者可获得内网资源。在介绍如何防御URL跳转攻击之前，老许和各位读者先一起复习一下HTTP重定向状态码——3xx。</p>
<p>根据维基百科的资料，3xx重定向码范围从300到308共9个。老许特意瞧了一眼go的源码，发现官方的<code>http.Client</code>发出的请求仅支持如下几个重定向码。</p>
<p><code>301</code>：请求的资源已永久移动到新位置；该响应可缓存；重定向请求一定是GET请求。</p>
<p><code>302</code>：要求客户端执行临时重定向；只有在Cache-Control或Expires中进行指定的情况下，这个响应才是可缓存的；重定向请求一定是GET请求。</p>
<p><code>303</code>：当POST（或PUT / DELETE）请求的响应在另一个URI能被找到时可用此code，这个code存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源；303响应禁止被缓存；重定向请求一定是GET请求。</p>
<p><code>307</code>：临时重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p><code>308</code>：永久重定向；不可更改请求方法，如果原请求是POST，则重定向请求也是POST。</p>
<p>3xx状态码复习就到这里，我们继续SSRF的攻防回合讨论。既然服务端的URL跳转可能带来风险，那我们只要禁用URL跳转就完全可以规避此类风险。然而我们并不能这么做，这个做法在规避风险的同时也极有可能误伤正常的请求。那到底该如何防范此类攻击手段呢？</p>
<p>看过老许“<a href="https://mp.weixin.qq.com/s/6WYhwaRrjv6W6NZCNw2CeA">Go中的HTTP请求之——HTTP1.1请求流程分析</a>”这篇文章的读者应该知道，对于重定向有业务需求时，可以自定义http.Client的<code>CheckRedirect</code>。下面我们先看一下<code>CheckRedirect</code>的定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">CheckRedirect</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span>
</span></span></code></pre></div><p>这里特别说明一下，<code>req</code>是即将发出的请求且请求中包含前一次请求的响应，<code>via</code>是已经发出的请求。在知晓这些条件后，防御URL跳转攻击就变得十分容易了。</p>
<ol>
<li>根据前一次请求的响应直接拒绝<code>307</code>和<code>308</code>的跳转（此类跳转可以是POST请求，风险极高）。</li>
<li>解析出请求的IP，并判断是否是内网IP。</li>
</ol>
<p>根据上述步骤，可如下定义<code>http.Client</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CheckRedirect</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>, <span style="color:#a6e22e">via</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 跳转超过10次，也拒绝继续跳转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">via</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;redirect too much&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">Response</span>.<span style="color:#a6e22e">StatusCode</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">307</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">308</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 拒绝跳转访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unsupport redirect method&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 判断ip
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>.<span style="color:#a6e22e">Host</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;have local ip&#34;</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%s -&gt; %s is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">req</span>.<span style="color:#a6e22e">URL</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	},
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上自定义CheckRedirect可以防范URL跳转攻击，但此方式会进行多次DNS解析，效率不佳。后文会结合其他攻击方式介绍更加有效率的防御措施。</p>
<p><strong>小结</strong>：通过自定义<code>http.Client</code>的<code>CheckRedirect</code>可以防范URL跳转攻击。</p>
<h3 id="回合三dns-rebinding">回合三：DNS Rebinding</h3>
<p>众所周知，发起一次HTTP请求需要先请求DNS服务获取域名对应的IP地址。如果攻击者有可控的DNS服务，就可以通过DNS重绑定绕过前面的防御策略进行攻击。</p>
<p>具体流程如下图所示。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa90ecbaeb18110063a5e91d1704f4c8a?method=download&amp;shareKey=fc64d48577f5e66e69ea10616cd28344" alt=""></p>
<p>验证资源是是否合法时，服务器进行了第一次DNS解析，获得了一个非内网的IP且TTL为0。对解析的IP进行判断，发现非内网IP可以后续请求。由于攻击者的DNS Server将TTL设置为0，所以正式发起请求时需要再次进行DNS解析。此时DNS Server返回内网地址，由于已经进入请求资源阶段再无防御措施，所以攻击者可获得内网资源。</p>
<blockquote>
<p>额外提一嘴，老许特意看了Go中DNS解析的部分源码，发现Go并没有对DNS的结果作缓存，所以即使TTL不为0也存在DNS重绑定的风险。</p>
</blockquote>
<p>在发起请求的过程中有DNS解析才让攻击者有机可乘。如果我们能对该过程进行控制，就可以避免DNS重绑定的风险。对HTTP请求控制可以通过自定义<code>http.Transport</code>来实现，而自定义<code>http.Transport</code>也有两个方案。</p>
<p><strong>方案一</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">port</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">addr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 解析host和 端口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// dns解析域名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ips</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">LookupIP</span>(<span style="color:#a6e22e">host</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 对所有的ip串行发起请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ip</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ips</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v -&gt; %v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">addr</span>, <span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">ip</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 非内网IP可继续访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 拼接地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">addr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">JoinHostPort</span>(<span style="color:#a6e22e">ip</span>.<span style="color:#a6e22e">String</span>(), <span style="color:#a6e22e">port</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 此时的addr仅包含IP和端口信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">con</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">addr</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">con</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;connect failed&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>transport.DialContext</code>的作用是创建未加密的TCP连接，我们通过自定义此函数可规避DNS重绑定风险。另外特别说明一下，如果传递给<code>dialer.DialContext</code>方法的地址是常规IP格式则可使用net包中的<code>parseIPZone</code>函数直接解析成功，否则会继续发起DNS解析请求。</p>
<p><strong>方案二</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">dialer</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dialer</span>{}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">Control</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">network</span>, <span style="color:#a6e22e">address</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">RawConn</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// address 已经是ip:port的格式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">SplitHostPort</span>(<span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%v is localip?: %v\n&#34;</span>, <span style="color:#a6e22e">address</span>, <span style="color:#a6e22e">IsLocalIP</span>(<span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">ParseIP</span>(<span style="color:#a6e22e">host</span>)))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">transport</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">DefaultTransport</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Transport</span>).<span style="color:#a6e22e">Clone</span>()
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用官方库的实现创建TCP连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">transport</span>.<span style="color:#a6e22e">DialContext</span> = <span style="color:#a6e22e">dialer</span>.<span style="color:#a6e22e">DialContext</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用此client请求，可避免DNS重绑定风险
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Transport</span>: <span style="color:#a6e22e">transport</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>dialer.Control</code>在创建网络连接之后实际拨号之前调用，且仅在go版本大于等于1.11时可用，其具体调用位置在<code>sock_posix.go</code>中的<code>(*netFD).dial</code>方法里。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB149c44c0f615142a792ed61dc8ef81d2?method=download&amp;shareKey=a215bcf6853fe43b9a3d1f6b74a8fb3a" alt=""></p>
<p>上述两个防御方案不仅仅可以防范DNS重绑定攻击，也同样可以防范其他攻击方式。事实上，老许更加推荐方案二，简直一劳永逸！</p>
<p><strong>小结</strong>：</p>
<ol>
<li>攻击者可以通过自己的DNS服务进行DNS重绑定攻击。</li>
<li>通过自定义<code>http.Transport</code>可以防范DNS重绑定攻击。</li>
</ol>
<h3 id="个人经验">个人经验</h3>
<p>1、不要下发详细的错误信息！不要下发详细的错误信息！不要下发详细的错误信息！</p>
<p>如果是为了开发调试，请将错误信息打进日志文件里。强调这一点不仅仅是为了防范SSRF攻击，更是为了避免敏感信息泄漏。例如，DB操作失败后直接将error信息下发，而这个error信息很有可能包含SQL语句。</p>
<blockquote>
<p>再额外多说一嘴，老许的公司对打进日志文件的某些信息还要求脱敏，可谓是十分严格了。</p>
</blockquote>
<p>2、限制请求端口。</p>
<p>在结束之前特别说明一下，SSRF漏洞并不只针对HTTP协议。本篇只讨论HTTP协议是因为go中通过<code>http.Client</code>发起请求时会检测协议类型，某P*P语言这方面检测就会弱很多。虽然<code>http.Client</code>会检测协议类型，但是攻击者仍然可以通过漏洞不断更换端口进行内网端口探测。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/ssrf/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>2020总结：稍微努力了一下，依旧是咸鱼一条</title>
            <link>https://isites.gitlab.io/gopher/timeline/2020summary/</link>
            <pubDate>Thu, 31 Dec 2020 00:12:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/2020summary/</guid>
            <description>2020最深刻的印记是新冠疫情，于笔者最深刻的印记是在这一年下定决心做了一些新的尝试。既然有了新的尝试，笔者也就随大流来一发年终总结。
关于“新世界杂货铺”这个名字 2020的年终总结，最想谈的就是新世界杂货铺这个名字。为什么想先谈名字呢？因为笔者最近正在思考要不要换个名字，毕竟这个名字和公众号的内容实在没什么直接联系。笔者一度怀疑就是因为这个名字才导致笔者的粉丝增长缓慢。
先说一说为什么叫这个名字吧。专注于技术分享但是又不止于技术分享故谓之“杂货铺”，比如笔者曾经深夜偷偷发了一篇“7年，爷青结，感谢春物的陪伴！”这样的文章，以后只会更多！对笔者而言，做公众号是一次崭新的尝试所以最终才取名为“新世界杂货铺”。名字的由来差不多就是这样，至于明年要不要换个名字，笔者还在犹豫，姑且走一步看一步吧。
关于分享 毫无疑问，2020年的上半年算是废了，到下半年笔者才下定决心做出改变。而改变的第一步，笔者选择了百家号。
2020年7月5日，正式在百家号发布笔者的第一篇原创文章。在百家号发表几篇文章后，笔者差点丧失继续创作的动力（因为某些原因，笔者就不描述过多细节了）。直到2020年8月，笔者将主要创作平台移至公众号、简书和掘金等平台，才有了继续下去的动力。
说实话，持续原创输出十分不易，特别是冬天到了笔者就更加懒了，笔者坚持码下的每一个字对笔者而言都是自我挑战成功的硕果。截止目前，笔者已在公众号发布21篇原创，创作不易，但是笔者仍然想坚持下去，只为心中不迷茫！
关于粉丝 自己写的文章有几斤几两笔者还是比较清楚，所以对于粉丝数量十分佛系。
毕竟粉丝少，只能这样安慰自己，要不然为什么想换名字呢？果然，男人的嘴骗人的鬼！
粉丝数量能拿出手的就只有简书，截止目前已有5k+的粉丝量。
据笔者观察，这5k的粉丝几乎都是僵尸粉，估摸着是为了增加我在简书创作的动力才将我推送给新注册的用户。不管怎么样，这个粉丝量还是令笔者很舒心。这暗示已经非常明显了！
健康和体重 就健康而言笔者还是有些感触。去年年末，因为肾结石去了趟医院。每每回忆起当时的情形都令笔者十分后悔，后悔自己为什么不多喝水，为什么一直坐着，为什么不多运动！在此，特意提醒各位读者一定要多运动多喝水，少坐！
鉴于笔者曾经遭受了非人的折磨，所以从2020年初开始就坚持做俯卧撑，并买了站立办公椅。比较遗憾的是笔者从11月才开始记录俯卧撑的数量，截止到12月底两个月共完成2085个俯卧撑。
健康是一方面，另一方面笔者也希望自己能够跨入瘦子的行列。笔者还特意为自己设定了一个奖励，只要体重减到130就奖励自己一副贵一点的眼镜。然而都已经到年底了，这个目标还遥遥无期，果然每一个胖子都非一日之功。
看过的书 又到了晒书的时间，以下是笔者今年已经读完的书。
万万没想到笔者这种不常看书的人一年时间也能读完4本，由此可见不积跬步，无以至千里，古人诚不欺我。
这四本书中，笔者最喜欢第二本。该书全名为《好好吃饭：无须自控力，三观最正的瘦身指南》，只看书名相信各位读者就应该明白笔者为什么喜欢这本书了。对了，笔者一般都使用微信读书，欢迎各位道友加好友一起交流。
春暖花开，面朝2021 每一篇年终总结的最后都会立一些Flag，本篇亦不例外。
Flag1：一定要保持一个健康的身体，最好是能瘦下来，毕竟笔者的眼镜确实该换了。
Flag2：持续学习输出，粉丝也能持续增长就更好了。
鉴于笔者对自己有一个较为全面的认知，所以Flag就不立多了，多了也只是自己骗自己。
最后一口毒鸡汤 细细想来，2020于我来说和大部分人一样，稍微努力了一下，然而依旧是条咸鱼。工作没有什么变化，生活没有什么变化，经济状况还是没有什么变化。这是最好的结果，也是最坏的结果，或许有些时候真的要豁出去才能打破常规。
不矫情了，笔者最后祝愿所有人在新的一年里平淡且美好！
【关注公众号】</description>
            <content type="html"><![CDATA[<p>2020最深刻的印记是新冠疫情，于笔者最深刻的印记是在这一年下定决心做了一些新的尝试。既然有了新的尝试，笔者也就随大流来一发年终总结。</p>
<h3 id="关于新世界杂货铺这个名字">关于“新世界杂货铺”这个名字</h3>
<p>2020的年终总结，最想谈的就是<code>新世界杂货铺</code>这个名字。为什么想先谈名字呢？因为笔者最近正在思考要不要换个名字，毕竟这个名字和公众号的内容实在没什么直接联系。笔者一度怀疑就是因为这个名字才导致笔者的粉丝增长缓慢。</p>
<p>先说一说为什么叫这个名字吧。专注于技术分享但是又不止于技术分享故谓之“杂货铺”，比如笔者曾经深夜偷偷发了一篇“<a href="https://mp.weixin.qq.com/s/nHN4zaLjNUCIq7XqMkrb3Q">7年，爷青结，感谢春物的陪伴！</a>”这样的文章，以后只会更多！对笔者而言，做公众号是一次崭新的尝试所以最终才取名为“新世界杂货铺”。名字的由来差不多就是这样，至于明年要不要换个名字，笔者还在犹豫，姑且走一步看一步吧。</p>
<h3 id="关于分享">关于分享</h3>
<p>毫无疑问，2020年的上半年算是废了，到下半年笔者才下定决心做出改变。而改变的第一步，笔者选择了百家号。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7dea7d9d63718d8d1f23eb738d35821e?method=download&amp;shareKey=bd1e7324298f2050b3764c9c7b18e1c4" alt=""></p>
<p>2020年7月5日，正式在百家号发布笔者的第一篇原创文章。在百家号发表几篇文章后，笔者差点丧失继续创作的动力（因为某些原因，笔者就不描述过多细节了）。直到2020年8月，笔者将主要创作平台移至公众号、简书和掘金等平台，才有了继续下去的动力。</p>
<p>说实话，持续原创输出十分不易，特别是冬天到了笔者就更加懒了，笔者坚持码下的每一个字对笔者而言都是自我挑战成功的硕果。截止目前，笔者已在公众号发布21篇原创，创作不易，但是笔者仍然想坚持下去，只为心中不迷茫！</p>
<h3 id="关于粉丝">关于粉丝</h3>
<p>自己写的文章有几斤几两笔者还是比较清楚，所以对于粉丝数量十分佛系。</p>
<p>毕竟粉丝少，只能这样安慰自己，要不然为什么想换名字呢？果然，男人的嘴骗人的鬼！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6bef7dddedd0bca2761c87fa92865aa?method=download&amp;shareKey=76fedee423af1eb973500c00b4837220" alt=""></p>
<p>粉丝数量能拿出手的就只有简书，截止目前已有5k+的粉丝量。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb9d7faf93d4e2ac2fa7dac8b37bda850?method=download&amp;shareKey=cfbfa3096956d2d18278df93f1390533" alt=""></p>
<p>据笔者观察，这5k的粉丝几乎都是僵尸粉，估摸着是为了增加我在简书创作的动力才将我推送给新注册的用户。不管怎么样，这个粉丝量还是令笔者很舒心。这暗示已经非常明显了！</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB542290a0e3155af40b2f43c0818ba03b?method=download&amp;shareKey=2d7880e21d51a5318fb284e8ac3a35ed" alt=""></p>
<h3 id="健康和体重">健康和体重</h3>
<p>就健康而言笔者还是有些感触。去年年末，因为肾结石去了趟医院。每每回忆起当时的情形都令笔者十分后悔，后悔自己为什么不多喝水，为什么一直坐着，为什么不多运动！在此，特意提醒各位读者一定要多运动多喝水，少坐！</p>
<p>鉴于笔者曾经遭受了非人的折磨，所以从2020年初开始就坚持做俯卧撑，并买了站立办公椅。比较遗憾的是笔者从11月才开始记录俯卧撑的数量，截止到12月底两个月共完成<strong>2085</strong>个俯卧撑。</p>
<p>健康是一方面，另一方面笔者也希望自己能够跨入瘦子的行列。笔者还特意为自己设定了一个奖励，只要体重减到130就奖励自己一副贵一点的眼镜。然而都已经到年底了，这个目标还遥遥无期，果然每一个胖子都非一日之功。</p>
<h3 id="看过的书">看过的书</h3>
<p>又到了晒书的时间，以下是笔者今年已经读完的书。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB39c851807ac2fc74a926e123dbefa078?method=download&amp;shareKey=cc248d8560deeedb67243a55efcf7a35" alt=""></p>
<p>万万没想到笔者这种不常看书的人一年时间也能读完4本，由此可见不积跬步，无以至千里，古人诚不欺我。</p>
<p>这四本书中，笔者最喜欢第二本。该书全名为《好好吃饭：无须自控力，三观最正的瘦身指南》，只看书名相信各位读者就应该明白笔者为什么喜欢这本书了。对了，笔者一般都使用微信读书，欢迎各位道友加好友一起交流。</p>
<h3 id="春暖花开面朝2021">春暖花开，面朝2021</h3>
<p>每一篇年终总结的最后都会立一些Flag，本篇亦不例外。</p>
<p>Flag1：一定要保持一个健康的身体，最好是能瘦下来，毕竟笔者的眼镜确实该换了。</p>
<p>Flag2：持续学习输出，粉丝也能持续增长就更好了。</p>
<p>鉴于笔者对自己有一个较为全面的认知，所以Flag就不立多了，多了也只是自己骗自己。</p>
<h3 id="最后一口毒鸡汤">最后一口毒鸡汤</h3>
<p>细细想来，2020于我来说和大部分人一样，稍微努力了一下，然而依旧是条咸鱼。工作没有什么变化，生活没有什么变化，经济状况还是没有什么变化。这是最好的结果，也是最坏的结果，或许有些时候真的要豁出去才能打破常规。</p>
<p>不矫情了，笔者最后祝愿所有人在新的一年里平淡且美好！</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>码了2000多行代码就是为了讲清楚TLS握手流程（续）</title>
            <link>https://isites.gitlab.io/gopher/timeline/gotls1.2/</link>
            <pubDate>Sun, 13 Dec 2020 23:47:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/gotls1.2/</guid>
            <description>在“码了2000多行代码就是为了讲清楚TLS握手流程”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。
在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。
结论先行 为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。
单向认证 单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。
下面是笔者运行Demo打印的调试信息：
根据调试信息知，TLS1.2单向认证中总共收发数据四次，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。
笔者将调试信息转换为下述时序图，以方便各位读者理解。
双向认证 双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。
下面是笔者运行Demo打印的调试信息：
同单向认证一样，笔者将调试信息转换为下述时序图。
双向认证和单向认证相比，Server发消息给Client时会额外发送一个certificateRequestMsg消息，Client收到此消息后会将证书信息（certificateMsg）和签名信息（certificateVerifyMsg）发送给Server。
双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有四次。
总结 1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。
2、TLS1.2中除了finishedMsg其余消息均未加密。
3、在TLS1.2中，ChangeCipherSpec消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。
和TLS1.3的比较 消息格式的变化 对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是certificateMsg和certificateMsgTLS13的定义：
// TLS1.2 type certificateMsg struct { 	raw []byte 	certificates [][]byte } // TLS1.3 type certificateMsgTLS13 struct { 	raw []byte 	certificate tls.Certificate 	ocspStapling bool 	scts bool } 其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。
   TLS1.2 TLS1.3     certificateRequestMsg certificateRequestMsgTLS13   certificateMsg certificateMsgTLS13    消息类型的变化 TLS1.</description>
            <content type="html"><![CDATA[<p>在“<a href="https://mp.weixin.qq.com/s/ALmouugbrCHrNbyk3OTtSQ">码了2000多行代码就是为了讲清楚TLS握手流程</a>”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。</p>
<p>在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。</p>
<h3 id="结论先行">结论先行</h3>
<p>为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。</p>
<h4 id="单向认证">单向认证</h4>
<p>单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7b4e407a4d300561e2889311bff03b7f?method=download&amp;shareKey=df9641649e598375a3c8bc5baaa93fe9" alt=""></p>
<p>根据调试信息知，TLS1.2单向认证中总共收发数据<strong>四次</strong>，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。</p>
<p>笔者将调试信息转换为下述时序图，以方便各位读者理解。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe8229b8e38739b1e3cbe114c158d8a98?method=download&amp;shareKey=1a4a0f4fe5bd9d2b9e6406b4575fe312" alt=""></p>
<h4 id="双向认证">双向认证</h4>
<p>双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。</p>
<p>下面是笔者运行Demo打印的调试信息：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB87df88f5543af04290af0c21dca8c17a?method=download&amp;shareKey=2fec2f1d33ffb7dd40c0b47a19c6eb83" alt=""></p>
<p>同单向认证一样，笔者将调试信息转换为下述时序图。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cafa6a349cf1fff0e319767af00dfb1?method=download&amp;shareKey=df90677bde25f8ef809ddd93365759e2" alt=""></p>
<p>双向认证和单向认证相比，Server发消息给Client时会额外发送一个<code>certificateRequestMsg</code>消息，Client收到此消息后会将证书信息（<code>certificateMsg</code>）和签名信息（<code>certificateVerifyMsg</code>）发送给Server。</p>
<p>双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有<strong>四次</strong>。</p>
<h4 id="总结">总结</h4>
<p>1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。</p>
<p>2、TLS1.2中除了<code>finishedMsg</code>其余消息均未加密。</p>
<p>3、在TLS1.2中，<code>ChangeCipherSpec</code>消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。</p>
<h3 id="和tls13的比较">和TLS1.3的比较</h3>
<h4 id="消息格式的变化">消息格式的变化</h4>
<p>对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是<code>certificateMsg</code>和<code>certificateMsgTLS13</code>的定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// TLS1.2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsg</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">certificates</span> [][]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// TLS1.3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">certificateMsgTLS13</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">raw</span>          []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">certificate</span>  <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Certificate</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ocspStapling</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">scts</span>         <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">certificateRequestMsg</td>
<td style="text-align:left">certificateRequestMsgTLS13</td>
</tr>
<tr>
<td style="text-align:left">certificateMsg</td>
<td style="text-align:left">certificateMsgTLS13</td>
</tr>
</tbody>
</table>
<h4 id="消息类型的变化">消息类型的变化</h4>
<p>TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">TLS1.2</th>
<th style="text-align:left">TLS1.3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">serverKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">clientKeyExchangeMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">serverHelloDoneMsg</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">encryptedExtensionsMsg</td>
</tr>
</tbody>
</table>
<h4 id="消息加密的变化">消息加密的变化</h4>
<p>前篇中提到，TLS1.3中除了<code>clientHelloMsg</code>和<code>serverHelloMsg</code>其他消息均做了加密处理，且握手期间和应用数据使用不同的密钥加密。</p>
<p>TLS1.2中仅有<code>finishedMsg</code>做了加密处理，且应用数据也使用该密钥加密。</p>
<p>TLS1.3会计算两次密钥，Client和Server读取对方的<code>HelloMsg</code>和<code>finishedMsg</code>之后即可计算密钥。</p>
<blockquote>
<p>“Client和Server会各自计算两次密钥，计算时机分别是读取到对方的HelloMsg和finishedMsg之后”，这是前篇中的描述，计算时机描述不准确以上面为准。</p>
</blockquote>
<p>TLS1.2只计算一次密钥，Client和Server分别收到<code>serverKeyExchangeMsg</code>和<code>clientKeyExchangeMsg</code>之后即可计算密钥，和TLS1.3不同的是TLS1.2密钥计算后并不会立即对接下来发送的数据进行加密，只有当发送/接受<code>ChangeCipherSpec</code>消息后才会对接下来的数据进行加解密。</p>
<h4 id="生成密钥过程">生成密钥过程</h4>
<p>TLS1.2和TLS1.3生成密钥的过程还是比较相似的， 下图为Client读取<code>serverKeyExchangeMsg</code>之后的部分处理逻辑：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB931699839f1e500f2493ca4854c4443e?method=download&amp;shareKey=ffa6348e50fcedca417a2b9b3f3b2c36" alt=""></p>
<p>图中<code>X25519</code>是椭圆曲线迪菲-赫尔曼（Elliptic-curve Diffie–Hellman ，缩写为ECDH）密钥交换方案之一，这在前篇已经提到过故本篇不再赘述。</p>
<p>根据Debug结果，本例中<code>ka.preMasterSecret</code>和TLS1.3中的共享密钥生成逻辑完全一致。不仅如此，在后续的代码分析中，笔者发现TLS1.2也使用了<code>AEAD</code>加密算法对数据进行加解密（AEAD在前篇中已经提到过故本篇不再赘述）。</p>
<p>下图为笔者Debug结果：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB46c9f6e0eebb4d6e53f69bc2715959e1?method=download&amp;shareKey=83cb14cdf13ea7c2968b6f55260741af" alt=""></p>
<p>图中<code>prefixNonceAEAD</code>即为TLS1.2中AEAD加密算法的一种实现。</p>
<p>这里需要注意的是TLS1.3也会计算<code>masterSecret</code>。为了方便理解，我们先回顾一下TLS1.3中生成<code>masterSecret</code>的部分源码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 基于共享密钥派生hs.handshakeSecret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">sharedKey</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">earlySecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 基于hs.handshakeSecret 派生hs.masterSecret
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">extract</span>(<span style="color:#66d9ef">nil</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">handshakeSecret</span>, <span style="color:#e6db74">&#34;derived&#34;</span>, <span style="color:#66d9ef">nil</span>))
</span></span></code></pre></div><p>由上易知，TLS1.3先通过共享密钥派生出<code>handshakeSecret</code>，最后通过<code>handshakeSecret</code>派生出<code>masterSecret</code>。与此相比，TLS1.2生成<code>masterSecret</code>仅需一步：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span> = <span style="color:#a6e22e">masterFromPreMasterSecret</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">preMasterSecret</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">hello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>)
</span></span></code></pre></div><p><code>masterFromPreMasterSecret</code>函数的作用是利用<code>HMAC</code>（HMAC在前篇中已经提到故本篇不再赘述）算法对Client和Server的随机数以及共享密钥进行摘要，从而计算得到<code>masterSecret</code>。</p>
<p><code>masterSecret</code>在后续的过程中并不会用于数据加密，下面笔者带各位读者分别看一下TLS1.3和TLS1.2生成数据加密密钥的过程。</p>
<p>TLS1.3生成数据加密密钥（以Client计算serverSecret为例）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">serverSecret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">deriveSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">masterSecret</span>,
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">serverApplicationTrafficLabel</span>, <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">transcript</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">setTrafficSecret</span>(<span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">serverSecret</span>)
</span></span></code></pre></div><p>前篇中提到<code>hs.suite.deriveSecret</code>内部会通过<code>hs.transcript</code>计算出消息摘要从而重新得到一个<code>serverSecret</code>。<code>setTrafficSecret</code>方法内部会对<code>serverSecret</code>计算得到AEAD加密算法所需要的key和iv（初始向量：Initialization vector）。</p>
<p>因此可知TLS1.3计算密钥和Client/Server生成的随机数无直接关系，而与Client/Server当前收发的所有消息的摘要有关。</p>
<blockquote>
<p>补充：
IV通常是随机或者伪随机的。它和数据加密的密钥一起使用可以增加使用字典攻击的攻击者破解密码的难度。例如，如果加密数据中存在重复的序列，则攻击者可以假定消息中相应的序列也是相同的，而IV就是为了防止密文中出现相应的重复序列。</p>
<p>参考：</p>
<p><a href="https://whatis.techtarget.com/definition/initialization-vector-IV">https://whatis.techtarget.com/definition/initialization-vector-IV</a>
<a href="https://en.wikipedia.org/wiki/Initialization_vector">https://en.wikipedia.org/wiki/Initialization_vector</a></p>
</blockquote>
<p>TLS1.2生成数据加密密钥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">clientMAC</span>, <span style="color:#a6e22e">serverMAC</span>, <span style="color:#a6e22e">clientKey</span>, <span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">clientIV</span>, <span style="color:#a6e22e">serverIV</span> <span style="color:#f92672">:=</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">keysFromMasterSecret</span>(<span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">suite</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">masterSecret</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">clientHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">tr</span>.<span style="color:#a6e22e">serverHello</span>.<span style="color:#a6e22e">random</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">macLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">keyLen</span>, <span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">ivLen</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">serverCipher</span> = <span style="color:#a6e22e">hs</span>.<span style="color:#a6e22e">suite</span>.<span style="color:#a6e22e">aead</span>(<span style="color:#a6e22e">serverKey</span>, <span style="color:#a6e22e">serverIV</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">prepareCipherSpec</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">vers</span>, <span style="color:#a6e22e">serverCipher</span>, <span style="color:#a6e22e">serverHash</span>)
</span></span></code></pre></div><p>前文中提到<code>masterSecret</code>的生成与Client和Server的随机数有关，而通过<code>keysFromMasterSecret</code>计算AEAD所需的key和iv依旧与随机数有关。</p>
<p><strong>小结</strong>：</p>
<p>1、本例中TLS1.2和TLS1.3均使用<code>X25519</code>算法计算共享密钥。</p>
<p>2、本例中TLS1.2和TLS1.3均使用<code>AEAD</code>进行数据加解密。</p>
<p>3、TLS1.3通过共享密钥派生两次才得到<code>masterSecret</code>，而TLS1.2以共享密钥、Client和Server的随机数一起计算得到<code>masterSecret</code>。</p>
<p>4、TLS1.3通过消息的摘要再次计算得到一个数据加密密钥，而TLS1.2直接通过<code>masterSecret</code>计算得到AEAD所需的key和iv。</p>
<h3 id="tls11和tls10不支持http2">TLS1.1和TLS1.0不支持HTTP2</h3>
<p>在前面提到本文的例子已经支持解析TLS1.x的握手流程，这个时候笔者突然很好奇浏览器还支持那些版本的TLS协议。</p>
<p>然后笔者在谷歌浏览器上首先测试了TLS1.1的服务，为了方便测试笔者改造了之前<a href="">服务器推送的案例</a>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">server</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Server</span>{<span style="color:#a6e22e">Addr</span>: <span style="color:#e6db74">&#34;:8080&#34;</span>, <span style="color:#a6e22e">Handler</span>: <span style="color:#66d9ef">nil</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span> = new(<span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">Config</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">PreferServerCipherSuites</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;h2&#34;</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 服务端支持的最大tls版本调整为1.1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">MaxVersion</span> = <span style="color:#a6e22e">tls</span>.<span style="color:#a6e22e">VersionTLS11</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">ListenAndServeTLS</span>(<span style="color:#e6db74">&#34;ca.crt&#34;</span>, <span style="color:#e6db74">&#34;ca.key&#34;</span>)
</span></span></code></pre></div><p>运行Demo后得到如下截图：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2c8bf091ddf6f390b4a56357eb87fd2f?method=download&amp;shareKey=86fc79ae656452976818c5931a504bf8" alt=""></p>
<p>图中红框部分<code>obsolete</code>的意思笔者也不知，正好学习一波（技术人的英语大概就是这样慢慢积累起来的吧）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBab135aec59a8a4c6f59e89b5e1537686?method=download&amp;shareKey=fd9e75e79f9b3cccacfdc54e38e6193f" alt=""></p>
<p>这下笔者明白了，TLS1.1已经不被支持所以页面才无法正常访问，然而事实真是如此嘛？</p>
<p>直到几天后笔者开始写这篇文章时，内心仍是十分疑惑，于是使用了<code>curl</code>命令再次访问。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB5f9afe2142e28f4f2094daca63d5e17b?method=download&amp;shareKey=51250aff915a34a94c60da68ad7719cf" alt=""></p>
<p>图中蓝框部分正是TLS1.1的握手流程，有兴趣的读者可以使用笔者的例子和<code>curl -v</code>命令进行双向验证。</p>
<p>图中红框部分提示说“HTTP2的数据发送失败”，笔者才恍然大悟，将上述代码作如下微调后页面可正常访问。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span> = append(<span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">TLSConfig</span>.<span style="color:#a6e22e">NextProtos</span>, <span style="color:#e6db74">&#34;http/1.1&#34;</span>)
</span></span></code></pre></div><p>经过笔者的测试，TLS1.0同TLS1.1一样均不支持HTTP2协议，当然这两个协议也不推荐继续使用。</p>
<h3 id="写在最后">写在最后</h3>
<p>“纸上得来终觉浅，绝知此事需躬行”。笔者不敢保证把TLS握手流程的每个细节都讲的十分清楚，所以建议各位读者去github克隆代码，然后自己一步一步Debug必然能够加深印象并彻底理解。当然，顺便关注或者star一下这种随手为之的小事，笔者相信各位读者还是十分乐意的～</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p><strong>注</strong>：</p>
<ol>
<li>写本文时， 笔者所用go版本为: go1.15.2</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/http2/tls/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>区分Protobuf 3中缺失值和默认值</title>
            <link>https://isites.gitlab.io/gopher/timeline/gopb3/</link>
            <pubDate>Tue, 01 Dec 2020 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/gopb3/</guid>
            <description>这两天翻了翻以前的项目，发现不同项目中关于Protobuf 3缺失值和默认值的区分居然有好几种实现。今天笔者冷饭新炒，结合项目中的实现以及切身经验共总结出如下六种方案。
增加标识字段 众所周知，在Go中数字类型的默认值为0（这里仅以数字类型举例），这在某些场景下往往会引起一定的歧义。
 以is_show字段为例，如果没有该字段表示不更新DB中的数据，如果有该字段且值为0则表示更新DB中的数据为不可见，如果有该字段且值为1则表示更新DB中的数据为可见。
 上述场景中，实际要解决的问题是如何区分默认值和缺失字段。增加标识字段是通过额外增加一个字段来达到区分的目的。
例如：增加一个has_show_field字段标识is_show是否为有效值。如果has_show_field为true则is_show为有效值，否则认为is_show未设置值。
此方案虽然直白，但每次设置is_show的值时还需设置has_show_field的值，甚是麻烦故笔者十分不推荐。
字段含义和默认值区分 字段含义和默认值区分即不使用对应类型的默认值作为该字段的有效值。接着前面的例子继续描述，is_show为1时表示展示，is_show为2时表示不展示，其他情况则认为is_show未设置值。
此方案笔者还是比较认可的，唯一问题就是和开发者的默认习惯略微不符。
使用oneof oneof 的用意是达到 C 语言 union 数据类型的效果，但是诸多大佬还是发现它可以标识缺失字段。
message Status {  oneof show {  int32 is_show = 1;  } } message Test {  int32 bar = 1;  Status st = 2; } 上述proto文件生成对应go文件后，Test.St为Status的指针类型，故通过此方案可以区分默认值和缺失字段。但是笔者认为此方案做json序列化时十分不友好，下面是笔者的例子：
// oneof to json ot1 := oneof.Test{  Bar: 1,  St: &amp;amp;oneof.Status{  Show: &amp;amp;oneof.Status_IsShow{  IsShow: 1,  },  }, } bts, err := json.</description>
            <content type="html"><![CDATA[<p>这两天翻了翻以前的项目，发现不同项目中关于Protobuf 3缺失值和默认值的区分居然有好几种实现。今天笔者冷饭新炒，结合项目中的实现以及切身经验共总结出如下六种方案。</p>
<h3 id="增加标识字段">增加标识字段</h3>
<p>众所周知，在Go中数字类型的默认值为<code>0</code>（这里仅以数字类型举例），这在某些场景下往往会引起一定的歧义。</p>
<blockquote>
<p>以<code>is_show</code>字段为例，如果没有该字段表示不更新DB中的数据，如果有该字段且值为<code>0</code>则表示更新DB中的数据为不可见，如果有该字段且值为<code>1</code>则表示更新DB中的数据为可见。</p>
</blockquote>
<p>上述场景中，实际要解决的问题是如何区分默认值和缺失字段。增加标识字段是通过额外增加一个字段来达到区分的目的。</p>
<p>例如：增加一个<code>has_show_field</code>字段标识<code>is_show</code>是否为有效值。如果<code>has_show_field</code>为<code>true</code>则<code>is_show</code>为有效值，否则认为<code>is_show</code>未设置值。</p>
<p>此方案虽然直白，但每次设置<code>is_show</code>的值时还需设置<code>has_show_field</code>的值，甚是麻烦故笔者十分不推荐。</p>
<h3 id="字段含义和默认值区分">字段含义和默认值区分</h3>
<p>字段含义和默认值区分即不使用对应类型的默认值作为该字段的有效值。接着前面的例子继续描述，<code>is_show</code>为1时表示展示，<code>is_show</code>为2时表示不展示，其他情况则认为<code>is_show</code>未设置值。</p>
<p>此方案笔者还是比较认可的，唯一问题就是和开发者的默认习惯略微不符。</p>
<h3 id="使用oneof">使用oneof</h3>
<p>oneof 的用意是达到 C 语言 union 数据类型的效果，但是诸多大佬还是发现它可以标识缺失字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">oneof</span> <span style="color:#a6e22e">show</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述proto文件生成对应go文件后，<code>Test.St</code>为<code>Status</code>的指针类型，故通过此方案可以区分默认值和缺失字段。但是笔者认为此方案做json序列化时十分不友好，下面是笔者的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// oneof to json
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ot1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">St</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Status</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Show</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Status_IsShow</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">IsShow</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">ot1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// json to oneof failed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">jsonStr</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;Show&#34;:{&#34;is_show&#34;:1}}}`</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ot2</span> <span style="color:#a6e22e">oneof</span>.<span style="color:#a6e22e">Test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ot2</span>))
</span></span></code></pre></div><p>上述输出结果如下：</p>
<pre tabindex="0"><code>{&#34;bar&#34;:1,&#34;st&#34;:{&#34;Show&#34;:{&#34;is_show&#34;:1}}} &lt;nil&gt;
json: cannot unmarshal object into Go struct field Status.st.Show of type oneof.isStatus_Show
</code></pre><p>通过上述输出知，oneof的<code>json.Marshal</code>输出结果会额外多一层，而<code>json.Unmarshal</code>还会失败，因此使用oneof时需谨慎。</p>
<h3 id="使用wrapper类型">使用wrapper类型</h3>
<p>这应该是google官方提出的解决方案，我们看看下面的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;google/protobuf/wrappers.proto&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">google</span>.<span style="color:#a6e22e">protobuf</span>.<span style="color:#a6e22e">Int32Value</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用此方案需要引入<code>google/protobuf/wrappers.proto</code>。此方案生成对应go文件后，<code>Test.St</code>也是<code>Status</code>的指针类型。同样，我们也看一下它的json序列化效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">wra1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">St</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Status</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IsShow</span>: <span style="color:#a6e22e">wrapperspb</span>.<span style="color:#a6e22e">Int32</span>(<span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">wra1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:{&#34;value&#34;:1}}}`</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 可正常转json
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wra2</span> <span style="color:#a6e22e">wrapper</span>.<span style="color:#a6e22e">Test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wra2</span>))
</span></span></code></pre></div><p>上述输出结果如下：</p>
<pre tabindex="0"><code>{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:{&#34;value&#34;:1}}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>和oneof方案相比wrapper方案的json反序列化是没问题的，但是<code>json.Marshal</code>的输出结果也会额外多一层。另外，经笔者在本地试验，此方案无法和<code>gogoproto</code>一起使用。</p>
<h3 id="允许proto3使用optional标签">允许proto3使用<code>optional</code>标签</h3>
<p>前面几个方案估计在实践中还是不够尽善尽美。于是2020年5月16日<code>protoc v3.12.0</code>发布，该编译器允许proto3的字段也可使用 <code>optional</code>修饰。</p>
<p>下面看看例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>此方案需要使用新版本的<code>protoc</code>且必须使用<code>--experimental_allow_proto3_optional</code>开启此特性。protoc升级教程见https://github.com/protocolbuffers/protobuf#protocol-compiler-installation。下面继续看看该方案的json序列化效果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">isShow</span> <span style="color:#66d9ef">int32</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p3o1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">St</span>:  <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Status</span>{<span style="color:#a6e22e">IsShow</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">isShow</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p3o1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p3o2</span> <span style="color:#a6e22e">p3optional</span>.<span style="color:#a6e22e">Test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}}`</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3o2</span>))
</span></span></code></pre></div><p>上述输出结果如下：</p>
<pre tabindex="0"><code>{&#34;bar&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>据上述结果知，此方案与oneof以及wrapper方案的json序列化相比更加符合预期，同样，经笔者在本地试验，此方案无法和<code>gogoproto</code>一起使用。</p>
<h3 id="proto2和proto3结合使用">proto2和proto3结合使用</h3>
<p>作为一个<code>gogoproto</code>的忠实用户，笔者希望在能区分默认值和缺失值的同时还可以继续使用<code>gogoproto</code>的特性。于是便产生了proto2和proto3结合使用的野路子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// proto2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Status</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">optional</span> <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">is_show</span> = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// proto3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">message</span> <span style="color:#a6e22e">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int32</span> <span style="color:#a6e22e">bar</span> = <span style="color:#ae81ff">1</span> [(<span style="color:#a6e22e">gogoproto</span>.<span style="color:#a6e22e">moretags</span>) = <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">form</span>:<span style="color:#e6db74">&#34;more_bar&#34;</span><span style="color:#960050;background-color:#1e0010">&#39;</span>, (<span style="color:#a6e22e">gogoproto</span>.<span style="color:#a6e22e">jsontag</span>) = <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">custom_tag</span><span style="color:#960050;background-color:#1e0010">&#39;</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Status</span> <span style="color:#a6e22e">st</span> = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要区分缺失字段和默认值的message定义在语法为proto2的文件中，proto3通过<code>import</code>导入proto2的message以达区分目的。</p>
<p><code>optional</code>修饰的字段在Go中会生成指针类型，因此区分缺失值和默认值就变的十分容易了。下面看看此方案的json序列化效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// p3p2 to json
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">p3p21</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">St</span>:  <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Status</span>{<span style="color:#a6e22e">IsShow</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">isShow</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bts</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p3p21</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bts</span>), <span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p3p22</span> <span style="color:#a6e22e">p3p2</span>.<span style="color:#a6e22e">Test</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jsonStr</span> = <span style="color:#e6db74">`{&#34;custom_tag&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}}`</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">jsonStr</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3p22</span>))
</span></span></code></pre></div><p>上述输出结果如下：</p>
<pre tabindex="0"><code>{&#34;custom_tag&#34;:1,&#34;st&#34;:{&#34;is_show&#34;:1}} &lt;nil&gt;
&lt;nil&gt;
</code></pre><p>根据上述结果知，此方案不仅能够活用<code>gogoproto</code>的各种tag，其结果也和<strong>在proto3中直接使用optional</strong>效果一致。虽然笔者已经在自己的项目中使用了此方案，但是仍然要提醒一句：“写本篇文章时，笔者特意去github看了gogoproto的发布日志，gogoproto最新一个版本发布时间为<code>2019年10月14日</code>，笔者大胆预言gogoproto以后不会再更新了，所以此方案还请大家酌情使用”。</p>
<p>最后，衷心希望本文能够对各位读者有一定的帮助。</p>
<blockquote>
<p>注：</p>
<ol>
<li>文中笔者所用go版本为：go1.15.2</li>
<li>文中笔者所用protoc版本为：3.14.0</li>
<li>文章中所用完整例子：https://github.com/Isites/go-coder/blob/master/pbjson/main.go</li>
</ol>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>为什么go中的receiver name不推荐使用this或者self</title>
            <link>https://isites.gitlab.io/gopher/timeline/go-reciver/</link>
            <pubDate>Sat, 29 Aug 2020 12:20:38 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/go-reciver/</guid>
            <description>前言 在日常的开发中我们除了定义函数以外， 我们还会定义一些方法。这本来没有什么， 但是一些从PHP或者其他面向对象语言转GO的同学往往会把receiver name命名为this, self, me等。
笔者在实际项目开发中也遇到类似的同学， 屡次提醒却没有效果，于是决心写下这篇文章以便好好说服这些同学。
CR标准做法 首先我们来看一下GO推荐的标准命名Receiver Names，以下内容摘抄自https://github.com/golang/go/wiki/CodeReviewComments#receiver-names：
The name of a method&amp;#39;s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as &amp;#34;c&amp;#34; or &amp;#34;cl&amp;#34; for &amp;#34;Client&amp;#34;). Don&amp;#39;t use generic names such as &amp;#34;me&amp;#34;, &amp;#34;this&amp;#34; or &amp;#34;self&amp;#34;, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly.</description>
            <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在日常的开发中我们除了定义函数以外， 我们还会定义一些方法。这本来没有什么， 但是一些从PHP或者其他面向对象语言转GO的同学往往会把receiver name命名为<code>this</code>, <code>self</code>, <code>me</code>等。</p>
<p>笔者在实际项目开发中也遇到类似的同学， 屡次提醒却没有效果，于是决心写下这篇文章以便好好说服这些同学。</p>
<h2 id="cr标准做法">CR标准做法</h2>
<p>首先我们来看一下GO推荐的标准命名<code>Receiver Names</code>，以下内容摘抄自https://github.com/golang/go/wiki/CodeReviewComments#receiver-names：</p>
<pre tabindex="0"><code>The name of a method&#39;s receiver should be a reflection of its identity;
often a one or two letter abbreviation of its type suffices (such as &#34;c&#34; or &#34;cl&#34; for &#34;Client&#34;). 
Don&#39;t use generic names such as &#34;me&#34;, &#34;this&#34; or &#34;self&#34;, identifiers typical of object-oriented languages that gives the method a special meaning. 
In Go, the receiver of a method is just another parameter and therefore, should be named accordingly. 
...
</code></pre><p>简单翻译总结有如下2点：</p>
<ol>
<li>方法接受者名称应反映其身份， 并且不要使用<code>me</code>, <code>this</code>, <code>self</code>这些面向对象语言的典型标志符。</li>
<li>在go中方法接受者其实就是方法的另一个参数。</li>
</ol>
<h2 id="receiver是方法的第一个参数">Receiver是方法的第一个参数！</h2>
<p>上面的第二点， 可能不是很好理解，所以我们直接看下面的demo：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// T ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Println ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">Println</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;value: %v&#34;</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">T</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">T</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>) <span style="color:#75715e">// receiver作为函数的第一个参数，这个时候发生值拷贝，所以方法内部的t变量只是真实t变量的一个拷贝，这和this的含义是不相符的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">value</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">value</span>: <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>通过上面的demo， 我们知道接受者可以直接作为第一个参数传递给方法的。而<code>t.Println()</code>应该就是Go中的一种语法糖了。</p>
<p>到这里可能有同学又要问了， 既然Go提供了这种语糖，那我们这样命名有什么问题呢？笔者先不着急解释， 我们继续看下面的demo：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Test ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Test</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">A</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SetA ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#a6e22e">Test</span>) <span style="color:#a6e22e">SetA</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// SetA1 ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Test</span>) <span style="color:#a6e22e">SetA1</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;demo1:&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">SetA</span>(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">A</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Test</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">A</span>: <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;demo2:&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t1</span>.<span style="color:#a6e22e">A</span>)
</span></span><span style="display:flex;"><span>	(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t1</span>).<span style="color:#a6e22e">SetA1</span>(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t1</span>.<span style="color:#a6e22e">A</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">demo1</span>:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">demo2</span>:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">6</span>
</span></span></code></pre></div><p>看上面的demo我们知道， 当receiver不是指针时调用<code>SetA</code>其值根本没有改变。</p>
<p>因为Go中都是值传递，所以你如果对SetA的receiver的名称命名为<code>this</code>, <code>self</code>等，它就已经失去了本身的意义——“调用一个对象的方法就是向该对象传递一条消息”。而且对象本身的属性也并不一定会发生改变。</p>
<p><strong>综上</strong>: 请各位读者在对receiver命名时不要再用<code>this</code>, <code>self</code>等具有特殊含义的名称啦。</p>
<h2 id="receiver是可以为nil的">Receiver是可以为nil的！！！</h2>
<p>最近在研读<code>h2_bundle.go</code>的时候，发现了一段特殊的代码，顿时惊出一身冷汗，姑在本文补充一下，以防止自己和各位读者踩坑。</p>
<p>源代码截图如下：
<img src="https://note.youdao.com/yws/api/personal/file/WEBf28c8ce7424f4cc7a7620f735a83b9f1?method=download&amp;shareKey=829323e04d513a68e5cfe3c9d61d2a45" alt=""></p>
<p>惊出我一身冷汗的正是图中标红的部分，<strong>receiver居然还要判断为nil</strong>！在我的潜意识里一直是这样认为的，receiver默认都是有值的，直接使用就行了。这简直颠覆我的认知，吓得我赶紧写了个demo验证一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>) <span style="color:#a6e22e">testV</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">A</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">testV</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上述输出如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf867c728b16230b0a82d6f9cd9d134ab?method=download&amp;shareKey=bc9e10dedff781d0406ed40e850a8b22" alt=""></p>
<p><code>a.test()</code>能够正常输出，只有在处理变量结构体内部变量<code>v</code>才报出panic！！！还好本文前面已经介绍了<code>Receiver是方法的第一个参数</code>。正因为是第一个参数所以仅仅作为参数传递时即使是<code>nil</code>也能够正常调用函数，而在真正使用的地方报出panic。</p>
<p>鉴于receiver如此特殊，所以特意在本文完成之后补充后续内容以时刻提醒自己和各位读者。</p>
<blockquote>
<p>本部分于20200827日晚补充。</p>
</blockquote>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>深入剖析go中字符串的编码问题——特殊字符的string怎么转byte？</title>
            <link>https://isites.gitlab.io/gopher/timeline/go-string-encode/</link>
            <pubDate>Mon, 24 Aug 2020 23:47:48 +0800</pubDate>
            
            <guid>https://isites.gitlab.io/gopher/timeline/go-string-encode/</guid>
            <description>前言 前段时间发表了Go中的HTTP请求之——HTTP1.1请求流程分析，所以这两天本来打算研究HTTP2.0的请求源码，结果发现太复杂就跑去逛知乎了，然后就发现了一个非常有意思的提问“golang 特殊字符的string怎么转成[]byte?”。为了转换一下心情， 便有了此篇文章。
问题 原问题我就不码字了，直接上图： 看到问题，我的第一反应是ASCII码值范围应该是0~127呀，怎么会超过127呢？直到实际运行的时候才发现上图的特殊字符是‘’（如果无法展示，记住该特殊字符的unicode是\u0081），并不是英文中的句号。
unicode和utf-8的恩怨纠葛 百度百科已经把unicode和utf-8介绍的很详细了，所以这里就不做过多的阐述，仅摘抄部分和本文相关的定义：
 Unicode为每个字符设定了统一并且唯一的二进制编码，通常用两个字节表示一个字符。 UTF-8是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。  go中的字符 众所周知，go中能表示字符的有两种类型，分别是byte和rune，byte和rune的定义分别是：type byte = uint8和type rune = int32。
uint8范围是0-255，只能够表示有限个unicode字符，超过255的范围就会编译报错。根据上述关于unicode的定义，4字节的rune完全兼容两字节的unicode。
我们用下面的代码来验证：
var ( 	c1 byte = &amp;#39;a&amp;#39; 	c2 byte = &amp;#39;新&amp;#39; 	c3 rune = &amp;#39;新&amp;#39; 	) 	fmt.Println(c1, c2, c3) 上述的程序根本无法运行，因为第二行编译会报错，vscode给到了十分详细的提示：&#39;新&#39; (untyped rune constant 26032) overflows byte。
接下来，我们通过下面的代码来验证字符和unicode和整型的等价关系：
	fmt.Printf(&amp;#34;0x%x, %d\n&amp;#34;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;) //输出：0x81, 129 	fmt.Println(0x81 == &amp;#39;&amp;#39;, &amp;#39;\u0081&amp;#39; == &amp;#39;&amp;#39;, 129 == &amp;#39;&amp;#39;) // 输出：true true true 	//\u0081输出到屏幕上后不展示， 所以换了大写字母A来输出 	fmt.</description>
            <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>前段时间发表了<a href="https://mp.weixin.qq.com/s/6WYhwaRrjv6W6NZCNw2CeA">Go中的HTTP请求之——HTTP1.1请求流程分析</a>，所以这两天本来打算研究HTTP2.0的请求源码，结果发现太复杂就跑去逛知乎了，然后就发现了一个非常有意思的提问“golang 特殊字符的string怎么转成[]byte?”。为了转换一下心情， 便有了此篇文章。</p>
<h3 id="问题">问题</h3>
<p>原问题我就不码字了，直接上图：
<img src="https://note.youdao.com/yws/api/personal/file/WEB33623d72a9ae4985e77f6c9247854c20?method=download&amp;shareKey=575343bfecd80b0d40ef4f53ed002e8b" alt=""></p>
<p>看到问题，我的第一反应是ASCII码值范围应该是<code>0~127</code>呀，怎么会超过127呢？直到实际运行的时候才发现上图的特殊字符是‘’（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>），并不是英文中的句号。</p>
<h3 id="unicode和utf-8的恩怨纠葛">unicode和utf-8的恩怨纠葛</h3>
<p>百度百科已经把unicode和utf-8介绍的很详细了，所以这里就不做过多的阐述，仅摘抄部分和本文相关的定义：</p>
<ul>
<li>Unicode为每个字符设定了统一并且唯一的二进制编码，<strong>通常用两个字节表示一个字符</strong>。</li>
<li>UTF-8是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。UTF-8的特点是对不同范围的字符使用不同长度的编码。<strong>对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同</strong>。</li>
</ul>
<h3 id="go中的字符">go中的字符</h3>
<p>众所周知，go中能表示字符的有两种类型，分别是<code>byte</code>和<code>rune</code>，byte和rune的定义分别是：<code>type byte = uint8</code>和<code>type rune = int32</code>。</p>
<p>uint8范围是0-255，只能够表示有限个unicode字符，超过255的范围就会编译报错。根据上述关于unicode的定义，4字节的rune完全兼容两字节的unicode。</p>
<p>我们用下面的代码来验证：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c1</span> <span style="color:#66d9ef">byte</span> = <span style="color:#e6db74">&#39;a&#39;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c2</span> <span style="color:#66d9ef">byte</span> = <span style="color:#e6db74">&#39;新&#39;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c3</span> <span style="color:#66d9ef">rune</span> = <span style="color:#e6db74">&#39;新&#39;</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c1</span>, <span style="color:#a6e22e">c2</span>, <span style="color:#a6e22e">c3</span>)
</span></span></code></pre></div><p>上述的程序根本无法运行，因为第二行编译会报错，vscode给到了十分详细的提示：<code>'新' (untyped rune constant 26032) overflows byte</code>。</p>
<p>接下来，我们通过下面的代码来验证<code>字符</code>和<code>unicode</code>和整型的等价关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;0x%x, %d\n&#34;</span>, <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#75715e">//输出：0x81, 129
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#ae81ff">0x81</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#e6db74">&#39;\u0081&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>, <span style="color:#ae81ff">129</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;&#39;</span>) <span style="color:#75715e">// 输出：true true true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">//\u0081输出到屏幕上后不展示， 所以换了大写字母A来输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%c\n&#34;</span>, <span style="color:#ae81ff">65</span>) <span style="color:#75715e">// 输出：A
</span></span></span></code></pre></div><p>根据上面的代码输出的3个<code>true</code>可以知道，<strong>字符和unicode和整形是等价</strong>，并且整型也能转回字符的表现形式。</p>
<h3 id="go中的字符串是utf8编码的">go中的字符串是utf8编码的</h3>
<p>根据golang官方博客<a href="https://blog.golang.org/strings">https://blog.golang.org/strings</a>的原文：</p>
<pre tabindex="0"><code>
Go source code is always UTF-8.
A string holds arbitrary bytes.
A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.
</code></pre><p>翻译整理过来其实也就是两点：</p>
<ol>
<li>go中的代码总是用utf8编码，并且字符串能够存储任何字节。</li>
<li>没有经过字节级别的转义，那么字符串是一个标准的utf8序列。</li>
</ol>
<p>有了前面的基础知识和字符串是一个标准的utf8序列这一结论后我们接下来对字符串“”（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>）手动编码。</p>
<p>Unicode到UTF-8的编码方对照表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Unicode编码(十六进制)</th>
<th style="text-align:left">UTF-8 字节流(二进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">000000-00007F</td>
<td style="text-align:left">0xxxxxxx</td>
</tr>
<tr>
<td style="text-align:left">000080-0007FF</td>
<td style="text-align:left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">000800-00FFFF</td>
<td style="text-align:left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td style="text-align:left">010000-10FFFF</td>
<td style="text-align:left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>字符‘’（如果无法展示，记住该特殊字符的unicode是<code>\u0081</code>）的二进制表示为<code>10000001</code>，16进制表示为<code>0x81</code>。</p>
<p>根据unicode转utf8的对照表，0x7f &lt; 0x81 &lt; 0x7ff，所以此特殊字符需占两个字节，并且要套用的utf8模版是<code>110xxxxx 10xxxxxx</code>。</p>
<p>我们按照下面的步骤对<code>10000001</code>转为utf8的二进制序列：</p>
<p>第一步：根据x数量对特殊字符的高位补0。x的数量是11，所以需要对特殊字符的高位补3个0，此时特殊字符的二进制表示为：<code>00010000001</code>。</p>
<p>第二步：x有两个部分，且长度分别是5和6，所以对<code>00010000001</code>由底位向高位分别截取6位和5位，得到<code>000001</code>和<code>00010</code>。</p>
<p>第三步：将<code>000001</code>和<code>00010</code>由低位向高位填充至模版<code>110xxxxx 10xxxxxx</code>，可得到utf8的二进制序列为：<code>11000010 10000001</code>。</p>
<p>我们通过go对二进制转为整型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d, %d\n&#34;</span>, <span style="color:#ae81ff">0b11000010</span>, <span style="color:#ae81ff">0b10000001</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：194, 129
</span></span></span></code></pre></div><p><strong>综上</strong>：当用字符转字节时输出的是字符本身的整型值，当用字符串转字节切片时，实际上是输出的是utf8的字节切片序列(go中的字符串存储的就是utf8字节切片)。此时，我们回顾一下最开始的问题，就会发现输出是完全符合预期的。</p>
<h3 id="go中的rune">go中的rune</h3>
<p>笔者在这里猜测提问者期望的结果是“字符串转字节切片和字符转字节的结果保持一致”，这时<code>rune</code>就派上用场了，我们看看使用rune的效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]rune(<span style="color:#e6db74">&#34;&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 输出：[129]
</span></span></span></code></pre></div><p>由上可知用rune切片去转字符串时，它是直接将每个字符转为对应的unicode。</p>
<p>我们通过下面的代码模拟字符串转为[]rune切片和[]rune切片转为字符串的过程：</p>
<p>字符串转为rune切片:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#75715e">// 字符串直接转为[]rune切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> []rune(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%x &#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">bs</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">DecodeRune</span>(<span style="color:#a6e22e">bs</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%x &#34;</span>, <span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bs</span> = <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">w</span>:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 输出:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 65b0 4e16 754c 6742 8d27 94fa
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 65b0 4e16 754c 6742 8d27 94fa
</span></span></span></code></pre></div><p>上述代码中<code>utf8.DecodeRune</code>的作用是通过传入的utf8字节序列转为一个rune即unicode。</p>
<p>rune切片转为字符串:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#75715e">// rune切片转为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rs</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">rune</span>{<span style="color:#ae81ff">0x65b0</span>, <span style="color:#ae81ff">0x4e16</span>, <span style="color:#ae81ff">0x754c</span>, <span style="color:#ae81ff">0x6742</span>, <span style="color:#ae81ff">0x8d27</span>, <span style="color:#ae81ff">0x94fa</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">rs</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">utf8bs</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">rs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">EncodeRune</span>(<span style="color:#a6e22e">bs</span>, <span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">utf8bs</span> = append(<span style="color:#a6e22e">utf8bs</span>, <span style="color:#a6e22e">bs</span>[:<span style="color:#a6e22e">w</span>]<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">utf8bs</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 输出:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 新世界杂货铺
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 新世界杂货铺
</span></span></span></code></pre></div><p>上述代码中<code>utf8.EncodeRune</code>的作用是将一个rune转为utf8字节序列。</p>
<p><strong>综上</strong>：对于无法确定字符串中仅有单字节的字符的情况， 请使用<code>rune</code>，每一个rune类型代表一个unicode字符，并且它可以和字符串做无缝切换。</p>
<h3 id="理解go中的字符串其实是字节切片">理解go中的字符串其实是字节切片</h3>
<p>前面已经提到了字符串能够存储任意字节数据，而且是一个标准的utf8格式的字节切片。那么本节将会通过代码来加深印象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(<span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>], <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 输出：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// [230 150 176 228 184 150 231 149 140 230 157 130 232 180 167 233 147 186]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 230 150 176 228 184 150 231 149 140 230 157 130 232 180 167 233 147 186
</span></span></span></code></pre></div><p>由上述的代码可知，我们通过游标按字节访问字符串得到的结果和字符串转为字节切片是一样的，因此可以再次确认字符串和字节切片是等价的。</p>
<p>通常情况下我们的字符串都是标准utf8格式的字节切片，但这并不是说明字符串只能存储utf8格式的字节切片，<strong>go中的字符串可以存储任意的字节数据</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">65</span>, <span style="color:#ae81ff">73</span>, <span style="color:#ae81ff">230</span>, <span style="color:#ae81ff">150</span>, <span style="color:#ae81ff">176</span>, <span style="color:#ae81ff">255</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">bs</span>))         <span style="color:#75715e">// 将随机的字节切片转为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(string(<span style="color:#a6e22e">bs</span>))) <span style="color:#75715e">// 将字符串再次转回字节切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rs</span> <span style="color:#f92672">:=</span> []rune(string(<span style="color:#a6e22e">bs</span>)) <span style="color:#75715e">// 将字符串转为字节rune切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">rs</span>)          <span style="color:#75715e">// 输出rune切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">rs</span>))  <span style="color:#75715e">// 将rune切片转为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">bs</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utf8</span>.<span style="color:#a6e22e">DecodeRune</span>(<span style="color:#a6e22e">bs</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d: 0x%x &#34;</span>, <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">r</span>) <span style="color:#75715e">// 输出rune的值和其对应的16进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">bs</span> = <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">w</span>:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>([]byte(string(<span style="color:#a6e22e">rs</span>))) <span style="color:#75715e">// 将rune切片转为字符串后再次转为字节切片
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 输出：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// AI新�
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 230 150 176 255]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 26032 65533]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// AI新�
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 65: 0x41 73: 0x49 26032: 0x65b0 65533: 0xfffd 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// [65 73 230 150 176 239 191 189]
</span></span></span></code></pre></div><p>仔细阅读上面的代码和输出，前5行的输出应该是没有疑问的。但是第6行输出却和预期有出入。</p>
<p>前面提到了字符串可以存储任意的字节数据，那如果存储的字节数据不是标准的utf8字节切片就会出现上面的问题。</p>
<p>我们已经知道通过<code>utf8.DecodeRune</code>可以将字节切片转为rune。那如果碰到不符合utf8编码规范的字节切片时，utf8.DecodeRune会返回一个容错的unicode<code>\uFFFD</code>，这个unicode对应上面输出的16进制<code>0xfffd</code>。</p>
<p>问题也就出现在这个容错的unicode<code>\uFFFD</code>上，因为字节切片不符合utf8编码规范无法得到正确的unicode，既<code>\uFFFD</code>占据了本应该是正确的unicode所在的位置。这个时候再将已经含有容错字符的rune切片转为字符串时，字符串存储的就是合法的utf8字节切片了，因此第六行输出的是含有<code>\uFFFD</code>的合法utf8字节切片，也就产生了和最初始的字节切片不一致的情况了。</p>
<p>⚠️：<strong>在平时的开发中要注意rune切片和byte切片的相互转换一定要基于没有乱码的字符串(内部是符合utf8编码规则的字节切片)，否则容易出现上述类似的错误</strong>。</p>
<h3 id="字符串的多种表示方式">字符串的多种表示方式</h3>
<p>本节算是扩展了，在开发中还是尽量别用这种特殊的表示方式，虽然看起来很高级但是可读性太差。</p>
<p>下面直接看代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">bs</span> <span style="color:#f92672">:=</span> []byte([]byte(<span style="color:#e6db74">&#34;新&#34;</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">bs</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;0x%x &#34;</span>, <span style="color:#a6e22e">bs</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\xe6\x96\xb0&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\xe6\x96\xb0世界杂货铺&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#39;\u65b0&#39;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;新&#39;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;\u65b0世界杂货铺&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;新世界杂货铺&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 输出:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 0xe6 0x96 0xb0 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>目前笔者仅发现unicode和单字节的16进制可以直接用在字符串中， 欢迎读者提供更多的表示方式以供交流。</p>
<p>最后，祝大家读完此篇文章后能够有所收获。</p>
<p>【关注公众号】</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa3ee67b2b867e98cb5c587f4adfa6801?method=download&amp;shareKey=0fbb95d0aec6170b854e7b890d50d559" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
