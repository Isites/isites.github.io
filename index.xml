<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gopher指北</title>
    <link>https://gopher-north.gitee.io/</link>
    <description>Recent content on Gopher指北</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Jul 2021 22:09:00 +0800</lastBuildDate><atom:link href="https://gopher-north.gitee.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>讲的是切片，但好像又不只是切片？</title>
      <link>https://gopher-north.gitee.io/timeline/slice/</link>
      <pubDate>Mon, 26 Jul 2021 22:09:00 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/slice/</guid>
      <description>[TOC]
我内心一直有一个欲望，想要高声呼喊“我胡汉三又回来了”，而现在就是合适的时机。
正式开干之前有点手生，太久没有写技术类的文章，总有点怠惰，不得不说坚持确实是一件很难的事情。如果不是因为愧疚和写点东西能让自己稍微平静下来一些，我可能还将继续怠惰下去。
另外还有一件很有意思的事情分享一下。前一篇在公众号上的文章仅思考就花了近一个月，写只花了一天，而技术文章我一般边思考边写平均耗时一周。结果是不会骗人的，前一篇文章阅读量首次突破一千，果然这届读者的思想深度至少也有一个月那么多，老许佩服佩服。
切片底层结构 切片和结构体的互转 其他不扯多了，我们还是回归本篇主题。 在正式了解切片底层结构之前， 我们先看几行代码。
type mySlice struct { data uintptr len int cap int } s := mySlice{} fmt.Println(fmt.Sprintf(&amp;#34;%+v&amp;#34;, s)) // {data:0 len:0 cap:0} s1 := make([]int, 10) s1[2] = 2 fmt.Println(fmt.Sprintf(&amp;#34;%+v, len(%d), cap(%d)&amp;#34;, s1, len(s1), cap(s1))) // [0 0 2 0 0 0 0 0 0 0], len(10), cap(10) s = *(*mySlice)(unsafe.Pointer(&amp;amp;s1)) fmt.Println(fmt.Sprintf(&amp;#34;%+v&amp;#34;, s)) // {data:824634515456 len:10 cap:10} fmt.Printf(&amp;#34;%p, %v\n&amp;#34;, s1, unsafe.Pointer(s.data)) // 0xc0000c2000, 0xc0000c2000  在上述代码中，通过获取切片的地址，并将其转为*mySlice, 成功获得了切片的长度和容量。以及一个类似于指针一样的东西。而这个指针就是指向存储真实数据的数组，下面我们来进行验证。</description>
    </item>
    
    <item>
      <title>天涯未远，上海再见，百度再见</title>
      <link>https://gopher-north.gitee.io/timeline/leave-sh/</link>
      <pubDate>Sun, 06 Jun 2021 10:59:48 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/leave-sh/</guid>
      <description>关于离开想说的都在标题里。
离开的原因有很多，但是老许并不打算在这里详细阐述。说的越多都是在反复鞭尸自己的无能，老许对此次的离开总结为两个字——“败犬”（并无意冒犯他人，仅仅是对自己的总结。如果有兴趣交流的可以在公众号后台私我）。
以下为老许近一个多月的反思，这份反思没有什么大道理，更没有什么必须记住的知识点，老许写下来只是希望和各位读者有一个平等交流的机会。
一个无解的行业现状 &amp;ldquo;居安思危&amp;rdquo;，古人诚不欺我。我自认为在百度工作期间还是成长了很多，但是难免有松懈的时候，因此总的算下来是以一种平缓的速度进步。很长一段时间内老许都满足于现状，直到在金三银四的浪潮里开始挣扎。
“没有进步应该下十八层地狱，进步的慢更是一种原罪”，这是老许不由自主的感叹。以leetcode为例，不刷个一两百道题仿佛都不好意思出去面试。不知道这是不是内卷的一种。如果是，那一定是这个行业的人越来越多造成的。在程序猿从业人口越来越多的情况下，已经身在其中的人真是一刻也不容松懈呀。
 写下这一段我也很犹豫，总有散播焦虑的嫌疑，但事实上这就是我真实的感受。
 我简直毫无自控力 我简直毫无自控力，这个感悟来自于接受offer之后，把“某音”又重新装了回来。为什么会存在把它卸载这个事情呢？源自于开始找工作之后发现它严重影响了我的复习时间。明明知道应该把大量时间花在复习上，却总是不知不觉间刷起了短视频。虽然最近又把“某音”卸载了，但是又开始沉迷于某小破站。果然自控力对我来说就是扯淡。
和我等凡人不同，有些人明明已经成为了神，还是以极强的自控力给自己制定各种OKR和学习计划。看到这类人的时候，老许充分意识到作为一名凡夫俗子还是有点好高骛远了。他们欲带皇冠必承其重，我也不奢求自己有超强的自控力，只要在主次不颠倒的情况下，劳逸结合，按照合理的节奏前进即可，为达这个目的哪怕是以卸载这种强硬手段。
关于学习的反思 很早以前有人告诉我，“好记性不如烂笔头，但是最终你依旧要把它记在脑子里面才行”。这句话我深以为然，也是一直如此践行着。因此很多东西我做笔记也只是为了记住，而今终于自食恶果。
相信很多人都有这样一种感觉，年纪越大记忆力越来越差。我之前对某些知识点记忆不熟，也归咎于这个原因。我虽然做了笔记，但是没有对知识点做一个系统性的梳理，因此在我脑海中的知识点是杂乱无序的，自然忘的快。
幸运的是，我周边有这样的人在记忆知识点时会利用脑图做系统性的梳理。发现这一点时我幡然醒悟，我以前一直没有用一个有效的方法去记知识点。这个方法并不是什么秘密，很多人都知道但是并没有去使用。我相信这些人都和我一样只是缺少一个鹈鹕灌顶大彻大悟的契机。因此，我发自内心的感谢和我相遇的每一个人。
两个人的知识点不可能完全重合，因为你不可能看完所有的书，也不可能遇到他人遇到的所有实际问题，所以除了认真学习，获取知识点的另外一种有效途径就是交流和分享
对未来的规划和选择 这一段心里想了很多很多，有关于公司的选择，有关于未来的发展计划，但这些我自己也充满了不自信，所以就不在这里献丑了。
老许继续写下这段的原因是提醒自己现在的我还有选择的权利，如果有一天连选择的权利都没有了才是真正的穷途末路。虽然对未来依旧忐忑，但对老许来说一定会坚持的三件事是运动、挣钱和学习。相信这对所有人来说都是一样的（仿佛一句废话）。
最后，很庆幸有这样的一段时间，让自己重新思考，或许前路依旧迷雾重重，但依旧要砥砺前行。
最后的最后，感谢这一路上遇见的人和事。
【关注公众号】</description>
    </item>
    
    <item>
      <title>有趣！一行代码居然无法获取请求的完整URL</title>
      <link>https://gopher-north.gitee.io/timeline/get-full-url/</link>
      <pubDate>Mon, 29 Mar 2021 19:36:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/get-full-url/</guid>
      <description>缘起 做Web服务的时候，可能会有这样一个业务场景，获取一个HTTP请求的完整URL。很巧，老许就碰到了这样的业务场景。面对如此简单的需求，CV大法根本没有展示才能的机会。啪啪啪，获取请求的完整URL代码就出来了。
当时离验证只差一步，老许信心满满，很快，打脸来得很快就像龙卷风。。。
从图中可以知道，req.URL中的Scheme和Host均为空，所以r.URL.String()无法得到完整的请求连接。这个结果让老许一阵激动，万万没想到有一天我也有机会发现Go源码中可能遗漏的赋值。老许强行按耐住心中的激动，准备好好研究一番，万一成为了Go的Contributor呢^ω^。最后发现官方实现没有问题，因此就有了今天这篇文章。
HTTP1.1中为什么无法获取完整的连接 HTTP1.1的Server读取请求并构建Request.URL对象的逻辑在request.go文件的readRequest方法中，下面老许对其源码做一个简单分析总结。
 读取请求的第一行，HTTP请求的第一行又称为请求行。  // First line: GET /index.html HTTP/1.0 var s string if s, err = tp.ReadLine(); err != nil { return nil, err } 将请求行的内容分别解析为req.Method、req.RequestURI和req.Proto。  var ok bool req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s) 将req.RequestURI解析为req.URL。  rawurl := req.RequestURI if req.URL, err = url.ParseRequestURI(rawurl); err != nil { return nil, err }  注：当请求方法是CONNECT时，上述流程略有变化
 通过上面的流程我们知道req.URL的数据来源为req.RequestURI，而req.RequestURI到底是什么让我们继续阅读后文。
请求资源 根据rfc7230中的定义， 请求行分为请求方法、请求资源和HTTP版本，分别对应上述的req.Method、req.RequestURI和req.Proto（request-target在本文均被译作请求资源）。
关于请求方法有哪些想必不用老许在这儿科普了吧。至于常用的HTTP版本无非就是HTTP1.1和HTTP2。 下面主要介绍请求资源的几种形式。
origin-form 这种形式是请求资源中最常见的形式，其格式定义如下。</description>
    </item>
    
    <item>
      <title>白话Go内存模型&amp;Happen-Before</title>
      <link>https://gopher-north.gitee.io/timeline/go-memory-model/</link>
      <pubDate>Thu, 04 Mar 2021 18:53:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/go-memory-model/</guid>
      <description>Go内存模型明确指出，一个goroutine如何才能观察到其他goroutine对同一变量的写操作。
当多个goroutine并发同时存取同一个数据时必须把并发的存取操作序列化。在Go中保证读写的序列化可以通过channel通信或者其他同步原语（例如sync包中的互斥锁、读写锁和sync/atomic中的原子操作）。
Happens Before 在单goroutine中，读取和写入的行为一定是和程序指定的执行顺序表现一致。换言之，编译器和处理器在不改变语言规范所定义的行为前提下才可以对单个goroutine中的指令进行重排序。
a := 1 b := 2 由于指令重排序，b := 2可能先于a := 1执行。单goroutine中，该执行顺序的调整并不会影响最终结果。但多个goroutine场景下可能就会出现问题。
var a, b int // goroutine A go func() { a := 5 b := 1 }() // goroutine B go func() { for b == 1 {} fmt.Println(a) }() 执行上述代码时，预期goroutine B能够正常输出5，但因为指令重排序，b := 1可能先于a := 5执行，最终goroutine B可能输出0。
 注：上述例子是个不正确的示例，仅作说明用。
 为了明确读写的操作的要求，Go中引入了happens before，它表示执行内存操作的一种偏序关系。
happens-before的作用 多个goroutine访问共享变量时，它们必须建立同步事件来确保happens-before条件，以此确保读能够观察预期的写。
什么是Happens Before 如果事件e1发生在事件e2之前，那么我们说e2发生在e1之后。 同样，如果e1不在e2之前发生也没有在e2之后发生，那么我们说e1和e2同时发生。
在单个goroutine中，happens-before的顺序就是程序执行的顺序。那happens-before到底是什么顺序呢？我们看看下面的条件。
如果对于一个变量v的读操作r和写操作w满足下述两个条件，r才允许观察到w：
 r没有发生在w之前。 没有其他写操作发生在w之后和r之前。  为了保证变量v的一个读操作r能够观察到一个特定的写操作w，需要确保w是唯一允许被r观察的写操作。那么，如果 r、w 都满足以下条件，r就能确保观察到w：</description>
    </item>
    
    <item>
      <title>1分钟内的Linux性能分析法</title>
      <link>https://gopher-north.gitee.io/timeline/60-linux/</link>
      <pubDate>Mon, 01 Feb 2021 20:30:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/60-linux/</guid>
      <description>本着“拿来主义”的精神，吸收他人长处为己用。老许翻译一篇Linux性能分析相关的文章分享给各位读者，同时也加深自己的印象。
 你登录到具有性能问题的Linux服务器时，第一分钟要检查什么？
在Netflix，我们拥有庞大的Linux EC2云实例，以及大量的性能分析工具来监视和调查它们的性能。这些工具包括Atlas和Vector。Atlas用于全云监控，Vector用于按需实例分析。这些工具能帮助我们解决大部分问题，但有时候我们仍需登录实例并运行一些标准的Linux性能工具。
 Atlas：根据github上面的文档老许简单说一下自己的认知。一个可以管理基于时间维度数据的后端，同时具有内存存储功能可以非常快速地收集和报告大量指标。
Vector：Vector是一个主机上的性能监视框架，它可以将各种指标展示在工程师的浏览器上面。
 总结 在这篇文章中，Netflix性能工程团队将向您展示通过命令行进行性能分析是，前60秒应该使用那些Linux标准工具。在60秒内，你可以通过以下10个命令来全面了解系统资源使用情况和正在运行的进程。首先寻找错误和饱和指标，因为他们很容易理解，然后是资源利用率。饱和是指资源负载超出其处理能力，其可以表现为一个请求队列的长度或者等待时间。
uptime dmesg | tail vmstat 1 mpstat -P ALL 1 pidstat 1 iostat -xz 1 free -m sar -n DEV 1 sar -n TCP,ETCP 1 top 其中一些命令需要安装sysstat软件包。这些命令暴露的指标是一种帮助你完成USE Method（Utilization Saturation and Errors Method）——一种查找性能瓶颈的方法。这涉及检查所有资源（CPU、内存、磁盘等）利用率，饱和度和错误等指标。同时还需注意通过排除法可以逐步缩小资源检查范围。
以下各节通过生产系统中的示例总结了这些命令。这些命令的更多信息，请参考使用手册。
uptime $ uptime 23:51:26 up 21:31, 1 user, load average: 30.02, 26.43, 19.02 这是一种快速查看平均负载的方法，它指示了等待运行的进程数量。在Linux系统上，这些数字包括要在CPU上运行的进程以及处于I/O（通常是磁盘I/O）阻塞的进程。这提供了资源负载的大概状态，没有其他工具就无法理解更多。仅值得一看。
这三个数字分别代表着1分钟、5分钟和15分钟内的平均负载。这三个指标让我们了解负载是如何随时间变化的。例如，你被要求检查有问题的服务器，而1分钟的值远低于15分钟的值，则意味着你可能登录的太晚而错过了问题现场。
在上面的例子中，最近的平均负载增加，一分钟值达到30，而15分钟值达到19。数字如此之大意味着很多：可能是CPU需求（可以通过后文中介绍的vmstat或mpstat命令来确认）。
dmesg | tail $ dmesg | tail [1880957.563150] perl invoked oom-killer: gfp_mask=0x280da, order=0, oom_score_adj=0 [.</description>
    </item>
    
    <item>
      <title>Go中的SSRF攻防战</title>
      <link>https://gopher-north.gitee.io/timeline/go-ssrf/</link>
      <pubDate>Tue, 19 Jan 2021 20:30:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/go-ssrf/</guid>
      <description>写在最前面 “年年岁岁花相似，岁岁年年人不同”，没有什么是永恒的，很多东西都将成为过去式。比如，我以前在文章中自称“笔者”，细细想来这个称呼还是有一定的距离感，经过一番深思熟虑后，我打算将文章中的自称改为“老许”。
关于自称，老许就不扯太远了，下面还是回到本篇的主旨。
什么是SSRF SSRF英文全拼为Server Side Request Forgery，翻译为服务端请求伪造。攻击者在未能取得服务器权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。关于内网资源的访问控制，想必大家心里都有数。
上面这个说法如果不好懂，那老许就直接举一个实际例子。现在很多写作平台都支持通过URL的方式上传图片，如果服务器对URL校验不严格，此时就为恶意攻击者提供了访问内网资源的可能。
“千里之堤，溃于蚁穴”，任何可能造成风险的漏洞我们程序员都不应忽视，而且这类漏洞很有可能会成为别人绩效的垫脚石。为了不成为垫脚石，下面老许就和各位读者一起看一下SSRF的攻防回合。
回合一：千变万化的内网地址 为什么用“千变万化”这个词？老许先不回答，请各位读者耐心往下看。下面，老许用182.61.200.7（www.baidu.com的一个IP地址）这个IP和各位读者一起复习一下IPv4的不同表示方式。
   格式 值 描述     点分十进制 182.61.200.7 常规表现方式   点分八进制 0266.075.0310.07 每个字节被单独转换为八进制   点分十六进制 0xb6.0x3d.0xc8.0x7 每个字节被单独转换为十六进制   十进制 3057502215 用十进制写出的32位整数   八进制 026617344007 用八进制写出32位整数   十六进制 0xb63dc807 用十六进制写出32位整数   点分混合制（4） 182.0x3d.0310.7等 点分格式中，每个字节都可用任意的进制表达   点分混合制（3） 182.0x3d.0144007等 将后面16位用八进制表示   点分混合制（2） 182.4048903等 将后面24为用10进制表示    注意⚠️：点分混合制中，以点分割地每一部分均可以写作不同的进制（仅限于十、八和十六进制）。
上面仅是IPv4的不同表现方式，IPv6的地址也有三种不同表示方式。而这三种表现方式又可以有不同的写法。下面以IPv6中的回环地址0:0:0:0:0:0:0:1为例。</description>
    </item>
    
    <item>
      <title>2020总结：稍微努力了一下，依旧是咸鱼一条</title>
      <link>https://gopher-north.gitee.io/timeline/2020summary/</link>
      <pubDate>Thu, 31 Dec 2020 00:12:48 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/2020summary/</guid>
      <description>2020最深刻的印记是新冠疫情，于笔者最深刻的印记是在这一年下定决心做了一些新的尝试。既然有了新的尝试，笔者也就随大流来一发年终总结。
关于“新世界杂货铺”这个名字 2020的年终总结，最想谈的就是新世界杂货铺这个名字。为什么想先谈名字呢？因为笔者最近正在思考要不要换个名字，毕竟这个名字和公众号的内容实在没什么直接联系。笔者一度怀疑就是因为这个名字才导致笔者的粉丝增长缓慢。
先说一说为什么叫这个名字吧。专注于技术分享但是又不止于技术分享故谓之“杂货铺”，比如笔者曾经深夜偷偷发了一篇“7年，爷青结，感谢春物的陪伴！”这样的文章，以后只会更多！对笔者而言，做公众号是一次崭新的尝试所以最终才取名为“新世界杂货铺”。名字的由来差不多就是这样，至于明年要不要换个名字，笔者还在犹豫，姑且走一步看一步吧。
关于分享 毫无疑问，2020年的上半年算是废了，到下半年笔者才下定决心做出改变。而改变的第一步，笔者选择了百家号。
2020年7月5日，正式在百家号发布笔者的第一篇原创文章。在百家号发表几篇文章后，笔者差点丧失继续创作的动力（因为某些原因，笔者就不描述过多细节了）。直到2020年8月，笔者将主要创作平台移至公众号、简书和掘金等平台，才有了继续下去的动力。
说实话，持续原创输出十分不易，特别是冬天到了笔者就更加懒了，笔者坚持码下的每一个字对笔者而言都是自我挑战成功的硕果。截止目前，笔者已在公众号发布21篇原创，创作不易，但是笔者仍然想坚持下去，只为心中不迷茫！
关于粉丝 自己写的文章有几斤几两笔者还是比较清楚，所以对于粉丝数量十分佛系。
毕竟粉丝少，只能这样安慰自己，要不然为什么想换名字呢？果然，男人的嘴骗人的鬼！
粉丝数量能拿出手的就只有简书，截止目前已有5k+的粉丝量。
据笔者观察，这5k的粉丝几乎都是僵尸粉，估摸着是为了增加我在简书创作的动力才将我推送给新注册的用户。不管怎么样，这个粉丝量还是令笔者很舒心。这暗示已经非常明显了！
健康和体重 就健康而言笔者还是有些感触。去年年末，因为肾结石去了趟医院。每每回忆起当时的情形都令笔者十分后悔，后悔自己为什么不多喝水，为什么一直坐着，为什么不多运动！在此，特意提醒各位读者一定要多运动多喝水，少坐！
鉴于笔者曾经遭受了非人的折磨，所以从2020年初开始就坚持做俯卧撑，并买了站立办公椅。比较遗憾的是笔者从11月才开始记录俯卧撑的数量，截止到12月底两个月共完成2085个俯卧撑。
健康是一方面，另一方面笔者也希望自己能够跨入瘦子的行列。笔者还特意为自己设定了一个奖励，只要体重减到130就奖励自己一副贵一点的眼镜。然而都已经到年底了，这个目标还遥遥无期，果然每一个胖子都非一日之功。
看过的书 又到了晒书的时间，以下是笔者今年已经读完的书。
万万没想到笔者这种不常看书的人一年时间也能读完4本，由此可见不积跬步，无以至千里，古人诚不欺我。
这四本书中，笔者最喜欢第二本。该书全名为《好好吃饭：无须自控力，三观最正的瘦身指南》，只看书名相信各位读者就应该明白笔者为什么喜欢这本书了。对了，笔者一般都使用微信读书，欢迎各位道友加好友一起交流。
春暖花开，面朝2021 每一篇年终总结的最后都会立一些Flag，本篇亦不例外。
Flag1：一定要保持一个健康的身体，最好是能瘦下来，毕竟笔者的眼镜确实该换了。
Flag2：持续学习输出，粉丝也能持续增长就更好了。
鉴于笔者对自己有一个较为全面的认知，所以Flag就不立多了，多了也只是自己骗自己。
最后一口毒鸡汤 细细想来，2020于我来说和大部分人一样，稍微努力了一下，然而依旧是条咸鱼。工作没有什么变化，生活没有什么变化，经济状况还是没有什么变化。这是最好的结果，也是最坏的结果，或许有些时候真的要豁出去才能打破常规。
不矫情了，笔者最后祝愿所有人在新的一年里平淡且美好！
【关注公众号】</description>
    </item>
    
    <item>
      <title>码了2000多行代码就是为了讲清楚TLS握手流程（续）</title>
      <link>https://gopher-north.gitee.io/timeline/gotls1.2/</link>
      <pubDate>Sun, 13 Dec 2020 23:47:48 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/gotls1.2/</guid>
      <description>在“码了2000多行代码就是为了讲清楚TLS握手流程”这一篇文章的最后挖了一个坑，今天这篇文章就是为了填坑而来，因此本篇主要分析TLS1.2的握手流程。
在写前一篇文章时，笔者的Demo只支持解析TLS1.3握手流程中发送的消息，写本篇时，笔者的Demo已经可以解析TLS1.x握手流程中的消息，有兴趣的读者请至文末获取Demo源码。
结论先行 为保证各位读者对TLS1.2的握手流程有一个大概的框架，本篇依旧结论先行。
单向认证 单向认证客户端不需要证书，客户端验证服务端证书合法即可访问。
下面是笔者运行Demo打印的调试信息：
根据调试信息知，TLS1.2单向认证中总共收发数据四次，Client和Server从这四次数据中分别读取不同的信息以达到握手的目的。
笔者将调试信息转换为下述时序图，以方便各位读者理解。
双向认证 双向认证不仅服务端要有证书，客户端也需要证书，只有客户端和服务端证书均合法才可继续访问（笔者的Demo如何开启双向认证请参考前一篇文章中HTTPS双向认证部分）。
下面是笔者运行Demo打印的调试信息：
同单向认证一样，笔者将调试信息转换为下述时序图。
双向认证和单向认证相比，Server发消息给Client时会额外发送一个certificateRequestMsg消息，Client收到此消息后会将证书信息（certificateMsg）和签名信息（certificateVerifyMsg）发送给Server。
双向认证中，Client和Server发送的消息变多了，但是总的数据收发仍然只有四次。
总结 1、单向认证和双向认证中，总的数据收发仅四次（比TLS1.3多一次数据收发），单次发送的数据中包含一个或者多个消息。
2、TLS1.2中除了finishedMsg其余消息均未加密。
3、在TLS1.2中，ChangeCipherSpec消息之后的所有数据均会做加密处理，它的作用在TLS1.2中更像是一个开启加密的开关（TLS1.3中忽略此消息，并不做任何处理）。
和TLS1.3的比较 消息格式的变化 对比本篇的时序图和前篇的时序图很容易发现部分消息格式发生了变化。下面是certificateMsg和certificateMsgTLS13的定义：
// TLS1.2 type certificateMsg struct { raw []byte certificates [][]byte } // TLS1.3 type certificateMsgTLS13 struct { raw []byte certificate tls.Certificate ocspStapling bool scts bool } 其他消息的定义笔者就不一一列举了，这里仅列出格式发生变化的消息。
   TLS1.2 TLS1.3     certificateRequestMsg certificateRequestMsgTLS13   certificateMsg certificateMsgTLS13    消息类型的变化 TLS1.2和TLS1.3有相同的消息类型也有各自独立的消息类型。下面是笔者例子中TLS1.2和TLS1.3各自独有的消息类型：
   TLS1.</description>
    </item>
    
    <item>
      <title>区分Protobuf 3中缺失值和默认值</title>
      <link>https://gopher-north.gitee.io/timeline/gopb3/</link>
      <pubDate>Tue, 01 Dec 2020 12:20:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/gopb3/</guid>
      <description>这两天翻了翻以前的项目，发现不同项目中关于Protobuf 3缺失值和默认值的区分居然有好几种实现。今天笔者冷饭新炒，结合项目中的实现以及切身经验共总结出如下六种方案。
增加标识字段 众所周知，在Go中数字类型的默认值为0（这里仅以数字类型举例），这在某些场景下往往会引起一定的歧义。
 以is_show字段为例，如果没有该字段表示不更新DB中的数据，如果有该字段且值为0则表示更新DB中的数据为不可见，如果有该字段且值为1则表示更新DB中的数据为可见。
 上述场景中，实际要解决的问题是如何区分默认值和缺失字段。增加标识字段是通过额外增加一个字段来达到区分的目的。
例如：增加一个has_show_field字段标识is_show是否为有效值。如果has_show_field为true则is_show为有效值，否则认为is_show未设置值。
此方案虽然直白，但每次设置is_show的值时还需设置has_show_field的值，甚是麻烦故笔者十分不推荐。
字段含义和默认值区分 字段含义和默认值区分即不使用对应类型的默认值作为该字段的有效值。接着前面的例子继续描述，is_show为1时表示展示，is_show为2时表示不展示，其他情况则认为is_show未设置值。
此方案笔者还是比较认可的，唯一问题就是和开发者的默认习惯略微不符。
使用oneof oneof 的用意是达到 C 语言 union 数据类型的效果，但是诸多大佬还是发现它可以标识缺失字段。
message Status { oneof show { int32 is_show = 1; } } message Test { int32 bar = 1; Status st = 2; } 上述proto文件生成对应go文件后，Test.St为Status的指针类型，故通过此方案可以区分默认值和缺失字段。但是笔者认为此方案做json序列化时十分不友好，下面是笔者的例子：
// oneof to json ot1 := oneof.Test{ Bar: 1, St: &amp;amp;oneof.Status{ Show: &amp;amp;oneof.Status_IsShow{ IsShow: 1, }, }, } bts, err := json.Marshal(ot1) fmt.Println(string(bts), err) // json to oneof failed jsonStr := `{&amp;#34;bar&amp;#34;:1,&amp;#34;st&amp;#34;:{&amp;#34;Show&amp;#34;:{&amp;#34;is_show&amp;#34;:1}}}` var ot2 oneof.</description>
    </item>
    
    <item>
      <title>为什么go中的receiver name不推荐使用this或者self</title>
      <link>https://gopher-north.gitee.io/timeline/go-reciver/</link>
      <pubDate>Sat, 29 Aug 2020 12:20:38 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/go-reciver/</guid>
      <description>前言 在日常的开发中我们除了定义函数以外， 我们还会定义一些方法。这本来没有什么， 但是一些从PHP或者其他面向对象语言转GO的同学往往会把receiver name命名为this, self, me等。
笔者在实际项目开发中也遇到类似的同学， 屡次提醒却没有效果，于是决心写下这篇文章以便好好说服这些同学。
CR标准做法 首先我们来看一下GO推荐的标准命名Receiver Names，以下内容摘抄自https://github.com/golang/go/wiki/CodeReviewComments#receiver-names：
The name of a method&#39;s receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as &amp;quot;c&amp;quot; or &amp;quot;cl&amp;quot; for &amp;quot;Client&amp;quot;). Don&#39;t use generic names such as &amp;quot;me&amp;quot;, &amp;quot;this&amp;quot; or &amp;quot;self&amp;quot;, identifiers typical of object-oriented languages that gives the method a special meaning. In Go, the receiver of a method is just another parameter and therefore, should be named accordingly.</description>
    </item>
    
    <item>
      <title>深入剖析go中字符串的编码问题——特殊字符的string怎么转byte？</title>
      <link>https://gopher-north.gitee.io/timeline/go-string-encode/</link>
      <pubDate>Mon, 24 Aug 2020 23:47:48 +0800</pubDate>
      
      <guid>https://gopher-north.gitee.io/timeline/go-string-encode/</guid>
      <description>前言 前段时间发表了Go中的HTTP请求之——HTTP1.1请求流程分析，所以这两天本来打算研究HTTP2.0的请求源码，结果发现太复杂就跑去逛知乎了，然后就发现了一个非常有意思的提问“golang 特殊字符的string怎么转成[]byte?”。为了转换一下心情， 便有了此篇文章。
问题 原问题我就不码字了，直接上图： 看到问题，我的第一反应是ASCII码值范围应该是0~127呀，怎么会超过127呢？直到实际运行的时候才发现上图的特殊字符是‘’（如果无法展示，记住该特殊字符的unicode是\u0081），并不是英文中的句号。
unicode和utf-8的恩怨纠葛 百度百科已经把unicode和utf-8介绍的很详细了，所以这里就不做过多的阐述，仅摘抄部分和本文相关的定义：
 Unicode为每个字符设定了统一并且唯一的二进制编码，通常用两个字节表示一个字符。 UTF-8是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符。UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。  go中的字符 众所周知，go中能表示字符的有两种类型，分别是byte和rune，byte和rune的定义分别是：type byte = uint8和type rune = int32。
uint8范围是0-255，只能够表示有限个unicode字符，超过255的范围就会编译报错。根据上述关于unicode的定义，4字节的rune完全兼容两字节的unicode。
我们用下面的代码来验证：
var ( c1 byte = &amp;#39;a&amp;#39; c2 byte = &amp;#39;新&amp;#39; c3 rune = &amp;#39;新&amp;#39; ) fmt.Println(c1, c2, c3) 上述的程序根本无法运行，因为第二行编译会报错，vscode给到了十分详细的提示：&#39;新&#39; (untyped rune constant 26032) overflows byte。
接下来，我们通过下面的代码来验证字符和unicode和整型的等价关系：
fmt.Printf(&amp;#34;0x%x, %d\n&amp;#34;, &amp;#39;&amp;#39;, &amp;#39;&amp;#39;) //输出：0x81, 129 	fmt.Println(0x81 == &amp;#39;&amp;#39;, &amp;#39;\u0081&amp;#39; == &amp;#39;&amp;#39;, 129 == &amp;#39;&amp;#39;) // 输出：true true true 	//\u0081输出到屏幕上后不展示， 所以换了大写字母A来输出 	fmt.</description>
    </item>
    
  </channel>
</rss>
